<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libpktlab - The PacketLab Utility Library: pktctrl.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libpktlab - The PacketLab Utility Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">pktctrl.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The pktlab pktctrl module.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="a00005_source.html">pktlab.h</a>&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;poll.h&gt;</code><br />
<code>#include &lt;sys/select.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for pktctrl.h:</div>
<div class="dyncontent">
<div class="center"><img src="a00009.png" border="0" usemap="#apktctrl_8h" alt=""/></div>
<map name="apktctrl_8h" id="apktctrl_8h">
<area shape="rect" title="The pktlab pktctrl module." alt="" coords="221,5,291,32"/>
<area shape="rect" href="a00005.html" title="General utilities for pktlab." alt="" coords="258,80,326,107"/>
<area shape="rect" title=" " alt="" coords="5,155,80,181"/>
<area shape="rect" title=" " alt="" coords="104,155,173,181"/>
<area shape="rect" title=" " alt="" coords="198,155,263,181"/>
<area shape="rect" title=" " alt="" coords="351,80,404,107"/>
<area shape="rect" title=" " alt="" coords="428,80,521,107"/>
<area shape="rect" title=" " alt="" coords="600,155,659,181"/>
<area shape="rect" title=" " alt="" coords="288,155,371,181"/>
<area shape="rect" title=" " alt="" coords="395,155,477,181"/>
<area shape="rect" title=" " alt="" coords="501,155,576,181"/>
</map>
</div>
</div>
<p><a href="a00008_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a0a63d13642d37570b6a161e3f830569f"><td class="memItemLeft" align="right" valign="top"><a id="a0a63d13642d37570b6a161e3f830569f" name="a0a63d13642d37570b6a161e3f830569f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTCTRL_SNIKEY_LEN_MIN</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a0a63d13642d37570b6a161e3f830569f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum pktlab snikey length. <br /></td></tr>
<tr class="separator:a0a63d13642d37570b6a161e3f830569f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af081808ed66d67031e4bc6a89223c8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#a1af081808ed66d67031e4bc6a89223c8">PKTCTRL_SNIKEY_LEN_MAX</a>&#160;&#160;&#160;63</td></tr>
<tr class="memdesc:a1af081808ed66d67031e4bc6a89223c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum pktlab snikey length.  <a href="a00008.html#a1af081808ed66d67031e4bc6a89223c8">More...</a><br /></td></tr>
<tr class="separator:a1af081808ed66d67031e4bc6a89223c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a8283eda26e1df5c5c05a9fb2e3332837"><td class="memItemLeft" align="right" valign="top"><a id="a8283eda26e1df5c5c05a9fb2e3332837" name="a8283eda26e1df5c5c05a9fb2e3332837"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#a8283eda26e1df5c5c05a9fb2e3332837">pktctrl_err</a> { <br />
&#160;&#160;<b>PKTCTRL_SUCCESS</b> = 0
, <b>PKTCTRL_INVAL</b> = 1
, <b>PKTCTRL_MAP_ERR</b> = 2
, <b>PKTCTRL_KEY_NOT_FOUND</b> = 3
, <br />
&#160;&#160;<b>PKTCTRL_SSL_FAILURE</b> = 4
, <b>PKTCTRL_BAD_CERT</b> = 5
, <b>PKTCTRL_BAD_CERTKEY</b> = 6
, <b>PKTCTRL_IN_PROGRESS</b> = 7
, <br />
&#160;&#160;<b>PKTCTRL_UNKNOWN_FAULT</b> = 127
<br />
 }</td></tr>
<tr class="memdesc:a8283eda26e1df5c5c05a9fb2e3332837"><td class="mdescLeft">&#160;</td><td class="mdescRight">pktctrl module defined error values. <br /></td></tr>
<tr class="separator:a8283eda26e1df5c5c05a9fb2e3332837"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8279507226b23643acd873e2dfc5a3cd"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="a00234.html">pktctrl_obj</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#a8279507226b23643acd873e2dfc5a3cd">pktctrl_create_obj</a> (void)</td></tr>
<tr class="memdesc:a8279507226b23643acd873e2dfc5a3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get initialized pktctrl session object struct.  <a href="a00008.html#a8279507226b23643acd873e2dfc5a3cd">More...</a><br /></td></tr>
<tr class="separator:a8279507226b23643acd873e2dfc5a3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305c2ee2d888933d2f112086fbcf4d27"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="a00238.html">pktctrl_keycert_store</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#a305c2ee2d888933d2f112086fbcf4d27">pktctrl_create_keycert_store</a> (void)</td></tr>
<tr class="memdesc:a305c2ee2d888933d2f112086fbcf4d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get initialized pktctrl key certificate storage struct.  <a href="a00008.html#a305c2ee2d888933d2f112086fbcf4d27">More...</a><br /></td></tr>
<tr class="separator:a305c2ee2d888933d2f112086fbcf4d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e0704e458c3dbc88b5ab2dea05ce20"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#ad2e0704e458c3dbc88b5ab2dea05ce20">pktctrl_set_server_keycert</a> (struct <a class="el" href="a00238.html">pktctrl_keycert_store</a> *store, const char *snikey, struct <a class="el" href="a00230.html">pktlab_certificate</a> **cert_ls, uint_fast32_t certnum, struct <a class="el" href="a00222.html">pktlab_publickey</a> **root_ls, uint_fast32_t rootnum)</td></tr>
<tr class="memdesc:ad2e0704e458c3dbc88b5ab2dea05ce20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load server certificate chain and trusted roots for some snikey into pktctrl key certificate storage struct.  <a href="a00008.html#ad2e0704e458c3dbc88b5ab2dea05ce20">More...</a><br /></td></tr>
<tr class="separator:ad2e0704e458c3dbc88b5ab2dea05ce20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0295dbf65e80898d7bfe33b5d5e9774"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#af0295dbf65e80898d7bfe33b5d5e9774">pktctrl_get_server_keycert</a> (struct <a class="el" href="a00238.html">pktctrl_keycert_store</a> *store, const char *snikey, struct <a class="el" href="a00230.html">pktlab_certificate</a> ***cert_ls, uint_fast32_t *certnum, struct <a class="el" href="a00222.html">pktlab_publickey</a> ***root_ls, uint_fast32_t *rootnum)</td></tr>
<tr class="memdesc:af0295dbf65e80898d7bfe33b5d5e9774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get loaded server certificate chain and trusted roots for some snikey from server pktctrl key certificate storage struct.  <a href="a00008.html#af0295dbf65e80898d7bfe33b5d5e9774">More...</a><br /></td></tr>
<tr class="separator:af0295dbf65e80898d7bfe33b5d5e9774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be7d2f5f60414ca68ef56e8da539af4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#a1be7d2f5f60414ca68ef56e8da539af4">pktctrl_clear_server_keycert</a> (struct <a class="el" href="a00238.html">pktctrl_keycert_store</a> *store, const char *snikey)</td></tr>
<tr class="memdesc:a1be7d2f5f60414ca68ef56e8da539af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete server certificate chain and trusted roots entry for some snikey from server pktctrl key certificate storage struct.  <a href="a00008.html#a1be7d2f5f60414ca68ef56e8da539af4">More...</a><br /></td></tr>
<tr class="separator:a1be7d2f5f60414ca68ef56e8da539af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaccfd58551186821c1f6b90d0b341763"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#aaccfd58551186821c1f6b90d0b341763">pktctrl_set_server_keycert_default</a> (struct <a class="el" href="a00238.html">pktctrl_keycert_store</a> *store, const char *snikey)</td></tr>
<tr class="memdesc:aaccfd58551186821c1f6b90d0b341763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set server pktctrl key certificate storage default entry.  <a href="a00008.html#aaccfd58551186821c1f6b90d0b341763">More...</a><br /></td></tr>
<tr class="separator:aaccfd58551186821c1f6b90d0b341763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f117b16610d1d34d88d245925e327d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#a54f117b16610d1d34d88d245925e327d">pktctrl_clear_server_keycert_default</a> (struct <a class="el" href="a00238.html">pktctrl_keycert_store</a> *store)</td></tr>
<tr class="memdesc:a54f117b16610d1d34d88d245925e327d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear server pktctrl key certificate storage default entry.  <a href="a00008.html#a54f117b16610d1d34d88d245925e327d">More...</a><br /></td></tr>
<tr class="separator:a54f117b16610d1d34d88d245925e327d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c89252994eea5f11e93a3f0353ef2f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#a29c89252994eea5f11e93a3f0353ef2f">pktctrl_set_client_keycert</a> (struct <a class="el" href="a00238.html">pktctrl_keycert_store</a> *store, struct <a class="el" href="a00230.html">pktlab_certificate</a> **cert_ls, uint_fast32_t certnum, struct <a class="el" href="a00222.html">pktlab_publickey</a> **root_ls, uint_fast32_t rootnum)</td></tr>
<tr class="memdesc:a29c89252994eea5f11e93a3f0353ef2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load client certificate chain and trusted roots into pktctrl key certificate storage struct.  <a href="a00008.html#a29c89252994eea5f11e93a3f0353ef2f">More...</a><br /></td></tr>
<tr class="separator:a29c89252994eea5f11e93a3f0353ef2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a512472a6e50b85f39812d0d53bf54"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#a92a512472a6e50b85f39812d0d53bf54">pktctrl_get_client_keycert</a> (struct <a class="el" href="a00238.html">pktctrl_keycert_store</a> *store, struct <a class="el" href="a00230.html">pktlab_certificate</a> ***cert_ls, uint_fast32_t *certnum, struct <a class="el" href="a00222.html">pktlab_publickey</a> ***root_ls, uint_fast32_t *rootnum)</td></tr>
<tr class="memdesc:a92a512472a6e50b85f39812d0d53bf54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get loaded client certificate chain and trusted roots from client pktctrl key certificate storage struct.  <a href="a00008.html#a92a512472a6e50b85f39812d0d53bf54">More...</a><br /></td></tr>
<tr class="separator:a92a512472a6e50b85f39812d0d53bf54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b8e30906df870b6414f177bc2472f06"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#a2b8e30906df870b6414f177bc2472f06">pktctrl_clear_client_keycert</a> (struct <a class="el" href="a00238.html">pktctrl_keycert_store</a> *store)</td></tr>
<tr class="memdesc:a2b8e30906df870b6414f177bc2472f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete client certificate chain and trusted roots from client pktctrl key certificate storage struct.  <a href="a00008.html#a2b8e30906df870b6414f177bc2472f06">More...</a><br /></td></tr>
<tr class="separator:a2b8e30906df870b6414f177bc2472f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec80c881e4b3cf697876096ea7f55b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#aaec80c881e4b3cf697876096ea7f55b0">pktctrl_accept</a> (int fd, int auth_mode, struct <a class="el" href="a00226.html">pktlab_privatekey</a> *serverkey, struct <a class="el" href="a00238.html">pktctrl_keycert_store</a> *store, struct <a class="el" href="a00234.html">pktctrl_obj</a> *ctrlobj, struct <a class="el" href="a00230.html">pktlab_certificate</a> ***peer_cert_ls, uint_fast32_t *peer_cert_num)</td></tr>
<tr class="memdesc:aaec80c881e4b3cf697876096ea7f55b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform TLS server-side handshake to establish TLS pktctrl session.  <a href="a00008.html#aaec80c881e4b3cf697876096ea7f55b0">More...</a><br /></td></tr>
<tr class="separator:aaec80c881e4b3cf697876096ea7f55b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeac3c0ac9e90bedb7d097befc57bcca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#aeeac3c0ac9e90bedb7d097befc57bcca">pktctrl_connect</a> (int fd, int auth_mode, const char *snikey, struct <a class="el" href="a00226.html">pktlab_privatekey</a> *clientkey, struct <a class="el" href="a00238.html">pktctrl_keycert_store</a> *store, struct <a class="el" href="a00234.html">pktctrl_obj</a> *ctrlobj, struct <a class="el" href="a00230.html">pktlab_certificate</a> ***peer_cert_ls, uint_fast32_t *peer_cert_num)</td></tr>
<tr class="memdesc:aeeac3c0ac9e90bedb7d097befc57bcca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform TLS client-side handshake to establish TLS pktctrl session.  <a href="a00008.html#aeeac3c0ac9e90bedb7d097befc57bcca">More...</a><br /></td></tr>
<tr class="separator:aeeac3c0ac9e90bedb7d097befc57bcca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2542ce6ffff4135a1dc4457f9dde1601"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#a2542ce6ffff4135a1dc4457f9dde1601">pktctrl_raw_session</a> (int fd, struct <a class="el" href="a00234.html">pktctrl_obj</a> *ctrlobj)</td></tr>
<tr class="memdesc:a2542ce6ffff4135a1dc4457f9dde1601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up pktctrl session object struct to establish barebone TCP pktctrl session.  <a href="a00008.html#a2542ce6ffff4135a1dc4457f9dde1601">More...</a><br /></td></tr>
<tr class="separator:a2542ce6ffff4135a1dc4457f9dde1601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9e994bb2d046ae32776f6e485b7654"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#a3f9e994bb2d046ae32776f6e485b7654">pktctrl_prepare_select</a> (int *nfds, fd_set *restrict rset, fd_set *restrict wset, bool want_read, bool want_write, struct <a class="el" href="a00234.html">pktctrl_obj</a> *ctrlobj)</td></tr>
<tr class="memdesc:a3f9e994bb2d046ae32776f6e485b7654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up arguments to select() for read/write operation on established pktctrl session based on intention.  <a href="a00008.html#a3f9e994bb2d046ae32776f6e485b7654">More...</a><br /></td></tr>
<tr class="separator:a3f9e994bb2d046ae32776f6e485b7654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad443d74d362a4b19e54a4c856eb2ae06"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#ad443d74d362a4b19e54a4c856eb2ae06">pktctrl_process_select</a> (const fd_set *restrict rset, const fd_set *restrict wset, struct <a class="el" href="a00234.html">pktctrl_obj</a> *ctrlobj, bool *readable, bool *writable)</td></tr>
<tr class="memdesc:ad443d74d362a4b19e54a4c856eb2ae06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process select() results to identify if read/write operation on established pktctrl session can be performed.  <a href="a00008.html#ad443d74d362a4b19e54a4c856eb2ae06">More...</a><br /></td></tr>
<tr class="separator:ad443d74d362a4b19e54a4c856eb2ae06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36b67cd64a437597c7f0c644cbfe2d4"><td class="memItemLeft" align="right" valign="top"><a id="af36b67cd64a437597c7f0c644cbfe2d4" name="af36b67cd64a437597c7f0c644cbfe2d4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>pktctrl_prepare_poll</b> (struct pollfd *restrict pfd, bool want_read, bool want_write, struct <a class="el" href="a00234.html">pktctrl_obj</a> *ctrlobj)</td></tr>
<tr class="separator:af36b67cd64a437597c7f0c644cbfe2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1d25729ae78fbb762126171d6652e3"><td class="memItemLeft" align="right" valign="top"><a id="a6d1d25729ae78fbb762126171d6652e3" name="a6d1d25729ae78fbb762126171d6652e3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>pktctrl_process_poll</b> (const struct pollfd *restrict pfd, struct <a class="el" href="a00234.html">pktctrl_obj</a> *ctrlobj, bool *readable, bool *writable)</td></tr>
<tr class="separator:a6d1d25729ae78fbb762126171d6652e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd20ed6c8d0d9e3a0a73d5d61c420234"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#abd20ed6c8d0d9e3a0a73d5d61c420234">pktctrl_read_message</a> (struct <a class="el" href="a00234.html">pktctrl_obj</a> *ctrlobj, struct <a class="el" href="a00042.html">pktlab_message</a> **msgptr)</td></tr>
<tr class="memdesc:abd20ed6c8d0d9e3a0a73d5d61c420234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read pktctrl message from established pktctrl session.  <a href="a00008.html#abd20ed6c8d0d9e3a0a73d5d61c420234">More...</a><br /></td></tr>
<tr class="separator:abd20ed6c8d0d9e3a0a73d5d61c420234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ec6e10884502f16184ac0921e173be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#a50ec6e10884502f16184ac0921e173be">pktctrl_write_message</a> (struct <a class="el" href="a00234.html">pktctrl_obj</a> *ctrlobj, const struct <a class="el" href="a00042.html">pktlab_message</a> *msg)</td></tr>
<tr class="memdesc:a50ec6e10884502f16184ac0921e173be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write pktctrl message to established pktctrl session.  <a href="a00008.html#a50ec6e10884502f16184ac0921e173be">More...</a><br /></td></tr>
<tr class="separator:a50ec6e10884502f16184ac0921e173be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ace6f70ba59b0b91eafc514984dbfc1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#a3ace6f70ba59b0b91eafc514984dbfc1">pktctrl_flush_write</a> (struct <a class="el" href="a00234.html">pktctrl_obj</a> *ctrlobj)</td></tr>
<tr class="memdesc:a3ace6f70ba59b0b91eafc514984dbfc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush established pktctrl session internal writer buffer.  <a href="a00008.html#a3ace6f70ba59b0b91eafc514984dbfc1">More...</a><br /></td></tr>
<tr class="separator:a3ace6f70ba59b0b91eafc514984dbfc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1c3e03af53207bfa064567492a39ee"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#a0d1c3e03af53207bfa064567492a39ee">pktctrl_write_unsent</a> (const struct <a class="el" href="a00234.html">pktctrl_obj</a> *ctrlobj)</td></tr>
<tr class="memdesc:a0d1c3e03af53207bfa064567492a39ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get established pktctrl session internal writer buffered content length.  <a href="a00008.html#a0d1c3e03af53207bfa064567492a39ee">More...</a><br /></td></tr>
<tr class="separator:a0d1c3e03af53207bfa064567492a39ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4c0ae98db6704c052253da9a8ffc57"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#aef4c0ae98db6704c052253da9a8ffc57">pktctrl_read</a> (struct <a class="el" href="a00234.html">pktctrl_obj</a> *obj, void *buf, size_t nbyte)</td></tr>
<tr class="memdesc:aef4c0ae98db6704c052253da9a8ffc57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bytes from established pktctrl session.  <a href="a00008.html#aef4c0ae98db6704c052253da9a8ffc57">More...</a><br /></td></tr>
<tr class="separator:aef4c0ae98db6704c052253da9a8ffc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5f99bb21f5998b1b9ada05240c2dfc"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#a8a5f99bb21f5998b1b9ada05240c2dfc">pktctrl_write</a> (struct <a class="el" href="a00234.html">pktctrl_obj</a> *obj, const void *buf, size_t nbyte)</td></tr>
<tr class="memdesc:a8a5f99bb21f5998b1b9ada05240c2dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write bytes to established pktctrl session.  <a href="a00008.html#a8a5f99bb21f5998b1b9ada05240c2dfc">More...</a><br /></td></tr>
<tr class="separator:a8a5f99bb21f5998b1b9ada05240c2dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59496f54f99e75fd674feb9b133aa37"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#ab59496f54f99e75fd674feb9b133aa37">pktctrl_close</a> (struct <a class="el" href="a00234.html">pktctrl_obj</a> *obj)</td></tr>
<tr class="memdesc:ab59496f54f99e75fd674feb9b133aa37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close and free an allocated pktctrl session object struct.  <a href="a00008.html#ab59496f54f99e75fd674feb9b133aa37">More...</a><br /></td></tr>
<tr class="separator:ab59496f54f99e75fd674feb9b133aa37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b28634e273d44048fac47190c02592"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#a94b28634e273d44048fac47190c02592">pktctrl_cleanup_keycert_store</a> (struct <a class="el" href="a00238.html">pktctrl_keycert_store</a> *store)</td></tr>
<tr class="memdesc:a94b28634e273d44048fac47190c02592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an allocated pktctrl key certificate storage struct.  <a href="a00008.html#a94b28634e273d44048fac47190c02592">More...</a><br /></td></tr>
<tr class="separator:a94b28634e273d44048fac47190c02592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41202c999aa3855527f3071a1b34f7a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#ac41202c999aa3855527f3071a1b34f7a">pktctrl_is_established</a> (struct <a class="el" href="a00234.html">pktctrl_obj</a> *obj)</td></tr>
<tr class="memdesc:ac41202c999aa3855527f3071a1b34f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a pktctrl session object is established.  <a href="a00008.html#ac41202c999aa3855527f3071a1b34f7a">More...</a><br /></td></tr>
<tr class="separator:ac41202c999aa3855527f3071a1b34f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397284764f311338125d986add53f6b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#a397284764f311338125d986add53f6b0">pktctrl_is_valid_snikey</a> (const char *snikey)</td></tr>
<tr class="memdesc:a397284764f311338125d986add53f6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if '\0'-terminated string is a valid snikey.  <a href="a00008.html#a397284764f311338125d986add53f6b0">More...</a><br /></td></tr>
<tr class="separator:a397284764f311338125d986add53f6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45538721942c809d798a9df19fe3fde2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#a45538721942c809d798a9df19fe3fde2">pktctrl_gen_snikey</a> (char **buf)</td></tr>
<tr class="memdesc:a45538721942c809d798a9df19fe3fde2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate random '\0'-terminated valid snikey of PKTCTRL_SNIKEY_LEN_MAX length.  <a href="a00008.html#a45538721942c809d798a9df19fe3fde2">More...</a><br /></td></tr>
<tr class="separator:a45538721942c809d798a9df19fe3fde2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >The pktlab pktctrl module. </p>
<p >For pktlab protocol message communication among pktlab entities. Note snikey is the same as SNI in normal TLS context. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a1af081808ed66d67031e4bc6a89223c8" name="a1af081808ed66d67031e4bc6a89223c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af081808ed66d67031e4bc6a89223c8">&#9670;&nbsp;</a></span>PKTCTRL_SNIKEY_LEN_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKTCTRL_SNIKEY_LEN_MAX&#160;&#160;&#160;63</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum pktlab snikey length. </p>
<p >Defined to be 63 for TLS library compatibility, as 63 is the maximum domain name label length. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aaec80c881e4b3cf697876096ea7f55b0" name="aaec80c881e4b3cf697876096ea7f55b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec80c881e4b3cf697876096ea7f55b0">&#9670;&nbsp;</a></span>pktctrl_accept()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktctrl_accept </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>auth_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="a00226.html">pktlab_privatekey</a> *&#160;</td>
          <td class="paramname"><em>serverkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="a00238.html">pktctrl_keycert_store</a> *&#160;</td>
          <td class="paramname"><em>store</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="a00234.html">pktctrl_obj</a> *&#160;</td>
          <td class="paramname"><em>ctrlobj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="a00230.html">pktlab_certificate</a> ***&#160;</td>
          <td class="paramname"><em>peer_cert_ls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t *&#160;</td>
          <td class="paramname"><em>peer_cert_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform TLS server-side handshake to establish TLS pktctrl session. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>File descriptor for an established TCP connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">auth_mode</td><td>The certificate chain verification mode to use. One of enum pktlab_auth_mode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">serverkey</td><td>Pointer to a loaded pktlab private key struct to be used as TLS server key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">store</td><td>Pointer to a loaded server pktctrl key certificate storage struct. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctrlobj</td><td>Pointer to an initialized pktctrl session object struct. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">peer_cert_ls</td><td>Pointer to return client certificate chain. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">peer_cert_num</td><td>The number of returned client certificates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An enum pktctrl_err value:<ol type="1">
<li>PKTCTRL_SUCCESS for success. ctrlobj is an established session object upon return.</li>
<li>PKTCTRL_INVAL for bad argument.</li>
<li>PKTCTRL_IN_PROGRESS for TLS handshake in progress.</li>
<li>PKTCTRL_SSL_FAILURE for TLS handshake error.</li>
<li>PKTCTRL_UNKNOWN_FAULT for other unknown errors.</li>
</ol>
</dd></dl>
<ul>
<li>ctrlobj &amp; fd should be freed &amp; closed after <a class="el" href="a00008.html#aaec80c881e4b3cf697876096ea7f55b0" title="Perform TLS server-side handshake to establish TLS pktctrl session.">pktctrl_accept()</a> returned PKTCTRL_SSL_FAILURE or PKTCTRL_UNKNOWN_FAULT.</li>
<li>If peer_cert_ls and peer_cert_num are both non-NULL, verified client certificates (if any) are returned.</li>
<li>If fd is non-blocking, PKTCTRL_IN_PROGRESS may be returned. One should then use <a class="el" href="a00008.html#a3f9e994bb2d046ae32776f6e485b7654" title="Set up arguments to select() for read/write operation on established pktctrl session based on intenti...">pktctrl_prepare_select()</a> and <a class="el" href="a00008.html#ad443d74d362a4b19e54a4c856eb2ae06" title="Process select() results to identify if read/write operation on established pktctrl session can be pe...">pktctrl_process_select()</a> with select() in sys/select.h to retry later.</li>
<li>If fd is blocking, <a class="el" href="a00008.html#aaec80c881e4b3cf697876096ea7f55b0" title="Perform TLS server-side handshake to establish TLS pktctrl session.">pktctrl_accept()</a> should block until success or failure.</li>
<li>When TLS handshake is ongoing for a ctrlobj/fd (i.e. <a class="el" href="a00008.html#aaec80c881e4b3cf697876096ea7f55b0" title="Perform TLS server-side handshake to establish TLS pktctrl session.">pktctrl_accept()</a> hasn't returned or returned PKTCTRL_IN_PROGRESS), the passed in arguments should remain unchanged (including in scope/not freed).</li>
<li>See also <a class="el" href="a00005.html#a089f44157f1aa8884833afa2d951f1b9" title="Allocate initialized pktlab private key struct.">pktlab_create_privatekey()</a>, <a class="el" href="a00005.html#a9eaff9c7a04dab9e1346a9cfb9128e01" title="Load pktlab private key struct via PEM-encoded private key char array.">pktlab_load_privatekey_pem()</a>, <a class="el" href="a00005.html#a14401636d8628029fba6b0d65948bed7" title="Load pktlab private key struct via raw PKCS8 byte array.">pktlab_load_privatekey_der()</a>, <a class="el" href="a00005.html#a9276942f170f7919afced0fba4f2b81f" title="Load pktlab private key struct via raw private key byte array.">pktlab_load_privatekey_raw()</a>, <a class="el" href="a00008.html#a305c2ee2d888933d2f112086fbcf4d27" title="Get initialized pktctrl key certificate storage struct.">pktctrl_create_keycert_store()</a>, <a class="el" href="a00008.html#ad2e0704e458c3dbc88b5ab2dea05ce20" title="Load server certificate chain and trusted roots for some snikey into pktctrl key certificate storage ...">pktctrl_set_server_keycert()</a>, <a class="el" href="a00008.html#aaccfd58551186821c1f6b90d0b341763" title="Set server pktctrl key certificate storage default entry.">pktctrl_set_server_keycert_default()</a>, <a class="el" href="a00008.html#a8279507226b23643acd873e2dfc5a3cd" title="Get initialized pktctrl session object struct.">pktctrl_create_obj()</a>, <a class="el" href="a00008.html#ab59496f54f99e75fd674feb9b133aa37" title="Close and free an allocated pktctrl session object struct.">pktctrl_close()</a>, <a class="el" href="a00008.html#abd20ed6c8d0d9e3a0a73d5d61c420234" title="Read pktctrl message from established pktctrl session.">pktctrl_read_message()</a>, <a class="el" href="a00008.html#a50ec6e10884502f16184ac0921e173be" title="Write pktctrl message to established pktctrl session.">pktctrl_write_message()</a>. </li>
</ul>

</div>
</div>
<a id="a94b28634e273d44048fac47190c02592" name="a94b28634e273d44048fac47190c02592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94b28634e273d44048fac47190c02592">&#9670;&nbsp;</a></span>pktctrl_cleanup_keycert_store()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktctrl_cleanup_keycert_store </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00238.html">pktctrl_keycert_store</a> *&#160;</td>
          <td class="paramname"><em>store</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an allocated pktctrl key certificate storage struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">store</td><td>Pointer to an allocated pktctrl key certificate storage struct to free. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An enum pktctrl_err value:<ol type="1">
<li>PKTCTRL_SUCCESS for success.</li>
<li>PKTCTRL_UNKNOWN_FAULT for other unknown errors.</li>
</ol>
</dd></dl>
<ul>
<li>Note the loaded keys and certificates are NOT freed.</li>
<li>Do not call <a class="el" href="a00008.html#a94b28634e273d44048fac47190c02592" title="Free an allocated pktctrl key certificate storage struct.">pktctrl_cleanup_keycert_store()</a> again if failed. </li>
</ul>

</div>
</div>
<a id="a2b8e30906df870b6414f177bc2472f06" name="a2b8e30906df870b6414f177bc2472f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b8e30906df870b6414f177bc2472f06">&#9670;&nbsp;</a></span>pktctrl_clear_client_keycert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktctrl_clear_client_keycert </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00238.html">pktctrl_keycert_store</a> *&#160;</td>
          <td class="paramname"><em>store</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete client certificate chain and trusted roots from client pktctrl key certificate storage struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">store</td><td>Pointer to a client pktctrl key certificate storage struct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An enum pktctrl_err value:<ol type="1">
<li>PKTCTRL_SUCCESS for success.</li>
<li>PKTCTRL_INVAL for bad argument.</li>
<li>PKTCTRL_UNKNOWN_FAULT for other unknown errors.</li>
</ol>
</dd></dl>
<ul>
<li><a class="el" href="a00008.html#a2b8e30906df870b6414f177bc2472f06" title="Delete client certificate chain and trusted roots from client pktctrl key certificate storage struct.">pktctrl_clear_client_keycert()</a> works the same as if calling <a class="el" href="a00008.html#a29c89252994eea5f11e93a3f0353ef2f" title="Load client certificate chain and trusted roots into pktctrl key certificate storage struct.">pktctrl_set_client_keycert()</a> with NULL cert_ls and NULL root_ls.</li>
<li>Note though cleared, the loaded cert_ls and root_ls (and their content) are NOT freed.</li>
<li>See also <a class="el" href="a00008.html#a305c2ee2d888933d2f112086fbcf4d27" title="Get initialized pktctrl key certificate storage struct.">pktctrl_create_keycert_store()</a>, <a class="el" href="a00008.html#a29c89252994eea5f11e93a3f0353ef2f" title="Load client certificate chain and trusted roots into pktctrl key certificate storage struct.">pktctrl_set_client_keycert()</a>, <a class="el" href="a00008.html#a92a512472a6e50b85f39812d0d53bf54" title="Get loaded client certificate chain and trusted roots from client pktctrl key certificate storage str...">pktctrl_get_client_keycert()</a>, <a class="el" href="a00008.html#a94b28634e273d44048fac47190c02592" title="Free an allocated pktctrl key certificate storage struct.">pktctrl_cleanup_keycert_store()</a>. </li>
</ul>

</div>
</div>
<a id="a1be7d2f5f60414ca68ef56e8da539af4" name="a1be7d2f5f60414ca68ef56e8da539af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1be7d2f5f60414ca68ef56e8da539af4">&#9670;&nbsp;</a></span>pktctrl_clear_server_keycert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktctrl_clear_server_keycert </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00238.html">pktctrl_keycert_store</a> *&#160;</td>
          <td class="paramname"><em>store</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>snikey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete server certificate chain and trusted roots entry for some snikey from server pktctrl key certificate storage struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">store</td><td>Pointer to a server pktctrl key certificate storage struct. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">snikey</td><td>Pointer to the target '\0'-terminated snikey. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An enum pktctrl_err value:<ol type="1">
<li>PKTCTRL_SUCCESS for success.</li>
<li>PKTCTRL_INVAL for bad argument.</li>
<li>PKTCTRL_MAP_ERR for internal map error.</li>
<li>PKTCTRL_UNKNOWN_FAULT for other unknown errors.</li>
</ol>
</dd></dl>
<ul>
<li>store should be freed after <a class="el" href="a00008.html#a1be7d2f5f60414ca68ef56e8da539af4" title="Delete server certificate chain and trusted roots entry for some snikey from server pktctrl key certi...">pktctrl_clear_server_keycert()</a> returned PKTCTRL_MAP_ERR.</li>
<li><a class="el" href="a00008.html#a1be7d2f5f60414ca68ef56e8da539af4" title="Delete server certificate chain and trusted roots entry for some snikey from server pktctrl key certi...">pktctrl_clear_server_keycert()</a> works the same as if calling <a class="el" href="a00008.html#ad2e0704e458c3dbc88b5ab2dea05ce20" title="Load server certificate chain and trusted roots for some snikey into pktctrl key certificate storage ...">pktctrl_set_server_keycert()</a> with NULL cert_ls and NULL root_ls. The corresponding entry is deleted for the supplied snikey.</li>
<li>Note though entry is deleted, the loaded cert_ls and root_ls (and their content) are NOT freed.</li>
<li>See also <a class="el" href="a00008.html#a305c2ee2d888933d2f112086fbcf4d27" title="Get initialized pktctrl key certificate storage struct.">pktctrl_create_keycert_store()</a>, <a class="el" href="a00008.html#ad2e0704e458c3dbc88b5ab2dea05ce20" title="Load server certificate chain and trusted roots for some snikey into pktctrl key certificate storage ...">pktctrl_set_server_keycert()</a>, <a class="el" href="a00008.html#af0295dbf65e80898d7bfe33b5d5e9774" title="Get loaded server certificate chain and trusted roots for some snikey from server pktctrl key certifi...">pktctrl_get_server_keycert()</a>, <a class="el" href="a00008.html#aaccfd58551186821c1f6b90d0b341763" title="Set server pktctrl key certificate storage default entry.">pktctrl_set_server_keycert_default()</a>, <a class="el" href="a00008.html#a54f117b16610d1d34d88d245925e327d" title="Clear server pktctrl key certificate storage default entry.">pktctrl_clear_server_keycert_default()</a>, <a class="el" href="a00008.html#a94b28634e273d44048fac47190c02592" title="Free an allocated pktctrl key certificate storage struct.">pktctrl_cleanup_keycert_store()</a>. </li>
</ul>

</div>
</div>
<a id="a54f117b16610d1d34d88d245925e327d" name="a54f117b16610d1d34d88d245925e327d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f117b16610d1d34d88d245925e327d">&#9670;&nbsp;</a></span>pktctrl_clear_server_keycert_default()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktctrl_clear_server_keycert_default </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00238.html">pktctrl_keycert_store</a> *&#160;</td>
          <td class="paramname"><em>store</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear server pktctrl key certificate storage default entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">store</td><td>Pointer to a server pktctrl key certificate storage struct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An enum pktctrl_err value:<ol type="1">
<li>PKTCTRL_SUCCESS for success.</li>
<li>PKTCTRL_INVAL for bad argument.</li>
<li>PKTCTRL_UNKNOWN_FAULT for other unknown errors.</li>
</ol>
</dd></dl>
<ul>
<li>See also <a class="el" href="a00008.html#a305c2ee2d888933d2f112086fbcf4d27" title="Get initialized pktctrl key certificate storage struct.">pktctrl_create_keycert_store()</a>, <a class="el" href="a00008.html#ad2e0704e458c3dbc88b5ab2dea05ce20" title="Load server certificate chain and trusted roots for some snikey into pktctrl key certificate storage ...">pktctrl_set_server_keycert()</a>, <a class="el" href="a00008.html#af0295dbf65e80898d7bfe33b5d5e9774" title="Get loaded server certificate chain and trusted roots for some snikey from server pktctrl key certifi...">pktctrl_get_server_keycert()</a>, <a class="el" href="a00008.html#a1be7d2f5f60414ca68ef56e8da539af4" title="Delete server certificate chain and trusted roots entry for some snikey from server pktctrl key certi...">pktctrl_clear_server_keycert()</a>, <a class="el" href="a00008.html#aaccfd58551186821c1f6b90d0b341763" title="Set server pktctrl key certificate storage default entry.">pktctrl_set_server_keycert_default()</a>, <a class="el" href="a00008.html#a94b28634e273d44048fac47190c02592" title="Free an allocated pktctrl key certificate storage struct.">pktctrl_cleanup_keycert_store()</a>. </li>
</ul>

</div>
</div>
<a id="ab59496f54f99e75fd674feb9b133aa37" name="ab59496f54f99e75fd674feb9b133aa37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59496f54f99e75fd674feb9b133aa37">&#9670;&nbsp;</a></span>pktctrl_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktctrl_close </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00234.html">pktctrl_obj</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close and free an allocated pktctrl session object struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">obj</td><td>Pointer to an allocated pktctrl session object struct to free. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An enum pktctrl_err value:<ol type="1">
<li>PKTCTRL_SUCCESS for success.</li>
<li>PKTCTRL_UNKNOWN_FAULT for other unknown errors.</li>
</ol>
</dd></dl>
<ul>
<li><a class="el" href="a00008.html#ab59496f54f99e75fd674feb9b133aa37" title="Close and free an allocated pktctrl session object struct.">pktctrl_close()</a> also performs TLS shutdown if applicable.</li>
<li>Note the underlying file descriptor is NOT closed.</li>
<li>Do not call <a class="el" href="a00008.html#ab59496f54f99e75fd674feb9b133aa37" title="Close and free an allocated pktctrl session object struct.">pktctrl_close()</a> again if failed. </li>
</ul>

</div>
</div>
<a id="aeeac3c0ac9e90bedb7d097befc57bcca" name="aeeac3c0ac9e90bedb7d097befc57bcca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeac3c0ac9e90bedb7d097befc57bcca">&#9670;&nbsp;</a></span>pktctrl_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktctrl_connect </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>auth_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>snikey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="a00226.html">pktlab_privatekey</a> *&#160;</td>
          <td class="paramname"><em>clientkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="a00238.html">pktctrl_keycert_store</a> *&#160;</td>
          <td class="paramname"><em>store</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="a00234.html">pktctrl_obj</a> *&#160;</td>
          <td class="paramname"><em>ctrlobj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="a00230.html">pktlab_certificate</a> ***&#160;</td>
          <td class="paramname"><em>peer_cert_ls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t *&#160;</td>
          <td class="paramname"><em>peer_cert_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform TLS client-side handshake to establish TLS pktctrl session. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>File descriptor for an established TCP connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">auth_mode</td><td>The certificate chain verification mode to use. One of enum pktlab_auth_mode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">snikey</td><td>Pointer to a '\0'-terminated snikey or NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clientkey</td><td>Pointer to a loaded pktlab private key struct to be used as TLS client key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">store</td><td>Pointer to a loaded client pktctrl key certificate storage struct. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctrlobj</td><td>Pointer to an initialized pktctrl session object struct. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">peer_cert_ls</td><td>Pointer to return client certificate chain. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">peer_cert_num</td><td>The number of returned client certificates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An enum pktctrl_err value:<ol type="1">
<li>PKTCTRL_SUCCESS for success. ctrlobj is an established session object upon return.</li>
<li>PKTCTRL_INVAL for bad argument.</li>
<li>PKTCTRL_BAD_CERT for certificate rejected by underlying TLS implementation.</li>
<li>PKTCTRL_BAD_CERTKEY for private key rejected by underlying TLS implementation.</li>
<li>PKTCTRL_IN_PROGRESS for TLS handshake in progress.</li>
<li>PKTCTRL_SSL_FAILURE for TLS handshake error.</li>
<li>PKTCTRL_UNKNOWN_FAULT for other unknown errors.</li>
</ol>
</dd></dl>
<ul>
<li>ctrlobj &amp; fd should be freed &amp; closed after <a class="el" href="a00008.html#aeeac3c0ac9e90bedb7d097befc57bcca" title="Perform TLS client-side handshake to establish TLS pktctrl session.">pktctrl_connect()</a> returned error other than PKTCTRL_INVAL or PKTCTRL_IN_PROGRESS.</li>
<li>If peer_cert_ls and peer_cert_num are both non-NULL, verified server certificates are returned.</li>
<li>If fd is non-blocking, PKTCTRL_IN_PROGRESS may be returned. One should then use <a class="el" href="a00008.html#a3f9e994bb2d046ae32776f6e485b7654" title="Set up arguments to select() for read/write operation on established pktctrl session based on intenti...">pktctrl_prepare_select()</a> and <a class="el" href="a00008.html#ad443d74d362a4b19e54a4c856eb2ae06" title="Process select() results to identify if read/write operation on established pktctrl session can be pe...">pktctrl_process_select()</a> with select() in sys/select.h to retry later.</li>
<li>If fd is blocking, <a class="el" href="a00008.html#aeeac3c0ac9e90bedb7d097befc57bcca" title="Perform TLS client-side handshake to establish TLS pktctrl session.">pktctrl_connect()</a> should block until success or failure.</li>
<li>When TLS handshake is ongoing for a ctrlobj/fd (i.e. <a class="el" href="a00008.html#aeeac3c0ac9e90bedb7d097befc57bcca" title="Perform TLS client-side handshake to establish TLS pktctrl session.">pktctrl_connect()</a> hasn't returned or returned PKTCTRL_IN_PROGRESS), the passed in arguments should remain unchanged (including in scope/not freed).</li>
<li>See also <a class="el" href="a00005.html#a089f44157f1aa8884833afa2d951f1b9" title="Allocate initialized pktlab private key struct.">pktlab_create_privatekey()</a>, <a class="el" href="a00005.html#a9eaff9c7a04dab9e1346a9cfb9128e01" title="Load pktlab private key struct via PEM-encoded private key char array.">pktlab_load_privatekey_pem()</a>, <a class="el" href="a00005.html#a14401636d8628029fba6b0d65948bed7" title="Load pktlab private key struct via raw PKCS8 byte array.">pktlab_load_privatekey_der()</a>, <a class="el" href="a00005.html#a9276942f170f7919afced0fba4f2b81f" title="Load pktlab private key struct via raw private key byte array.">pktlab_load_privatekey_raw()</a>, <a class="el" href="a00008.html#a305c2ee2d888933d2f112086fbcf4d27" title="Get initialized pktctrl key certificate storage struct.">pktctrl_create_keycert_store()</a>, <a class="el" href="a00008.html#ad2e0704e458c3dbc88b5ab2dea05ce20" title="Load server certificate chain and trusted roots for some snikey into pktctrl key certificate storage ...">pktctrl_set_server_keycert()</a>, <a class="el" href="a00008.html#aaccfd58551186821c1f6b90d0b341763" title="Set server pktctrl key certificate storage default entry.">pktctrl_set_server_keycert_default()</a>, <a class="el" href="a00008.html#a8279507226b23643acd873e2dfc5a3cd" title="Get initialized pktctrl session object struct.">pktctrl_create_obj()</a>, <a class="el" href="a00008.html#ab59496f54f99e75fd674feb9b133aa37" title="Close and free an allocated pktctrl session object struct.">pktctrl_close()</a>, <a class="el" href="a00008.html#abd20ed6c8d0d9e3a0a73d5d61c420234" title="Read pktctrl message from established pktctrl session.">pktctrl_read_message()</a>, <a class="el" href="a00008.html#a50ec6e10884502f16184ac0921e173be" title="Write pktctrl message to established pktctrl session.">pktctrl_write_message()</a>. </li>
</ul>

</div>
</div>
<a id="a305c2ee2d888933d2f112086fbcf4d27" name="a305c2ee2d888933d2f112086fbcf4d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a305c2ee2d888933d2f112086fbcf4d27">&#9670;&nbsp;</a></span>pktctrl_create_keycert_store()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="a00238.html">pktctrl_keycert_store</a> * pktctrl_create_keycert_store </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get initialized pktctrl key certificate storage struct. </p>
<dl class="section return"><dt>Returns</dt><dd>An allocated and initialized pktctrl key certificate storage struct, or NULL if failed.</dd></dl>
<ul>
<li>The returned allocated struct should be freed with <a class="el" href="a00008.html#a94b28634e273d44048fac47190c02592" title="Free an allocated pktctrl key certificate storage struct.">pktctrl_cleanup_keycert_store()</a>.</li>
<li>See also <a class="el" href="a00008.html#ad2e0704e458c3dbc88b5ab2dea05ce20" title="Load server certificate chain and trusted roots for some snikey into pktctrl key certificate storage ...">pktctrl_set_server_keycert()</a>, <a class="el" href="a00008.html#af0295dbf65e80898d7bfe33b5d5e9774" title="Get loaded server certificate chain and trusted roots for some snikey from server pktctrl key certifi...">pktctrl_get_server_keycert()</a>, <a class="el" href="a00008.html#a1be7d2f5f60414ca68ef56e8da539af4" title="Delete server certificate chain and trusted roots entry for some snikey from server pktctrl key certi...">pktctrl_clear_server_keycert()</a>, <a class="el" href="a00008.html#aaccfd58551186821c1f6b90d0b341763" title="Set server pktctrl key certificate storage default entry.">pktctrl_set_server_keycert_default()</a>, <a class="el" href="a00008.html#a54f117b16610d1d34d88d245925e327d" title="Clear server pktctrl key certificate storage default entry.">pktctrl_clear_server_keycert_default()</a>, <a class="el" href="a00008.html#a29c89252994eea5f11e93a3f0353ef2f" title="Load client certificate chain and trusted roots into pktctrl key certificate storage struct.">pktctrl_set_client_keycert()</a>, <a class="el" href="a00008.html#a92a512472a6e50b85f39812d0d53bf54" title="Get loaded client certificate chain and trusted roots from client pktctrl key certificate storage str...">pktctrl_get_client_keycert()</a>, <a class="el" href="a00008.html#a2b8e30906df870b6414f177bc2472f06" title="Delete client certificate chain and trusted roots from client pktctrl key certificate storage struct.">pktctrl_clear_client_keycert()</a>, <a class="el" href="a00008.html#a94b28634e273d44048fac47190c02592" title="Free an allocated pktctrl key certificate storage struct.">pktctrl_cleanup_keycert_store()</a>. </li>
</ul>

</div>
</div>
<a id="a8279507226b23643acd873e2dfc5a3cd" name="a8279507226b23643acd873e2dfc5a3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8279507226b23643acd873e2dfc5a3cd">&#9670;&nbsp;</a></span>pktctrl_create_obj()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="a00234.html">pktctrl_obj</a> * pktctrl_create_obj </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get initialized pktctrl session object struct. </p>
<dl class="section return"><dt>Returns</dt><dd>An allocated and initialized pktctrl session object struct, or NULL if failed.</dd></dl>
<ul>
<li>The returned allocated struct should be freed with <a class="el" href="a00008.html#ab59496f54f99e75fd674feb9b133aa37" title="Close and free an allocated pktctrl session object struct.">pktctrl_close()</a>. </li>
</ul>

</div>
</div>
<a id="a3ace6f70ba59b0b91eafc514984dbfc1" name="a3ace6f70ba59b0b91eafc514984dbfc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ace6f70ba59b0b91eafc514984dbfc1">&#9670;&nbsp;</a></span>pktctrl_flush_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktctrl_flush_write </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00234.html">pktctrl_obj</a> *&#160;</td>
          <td class="paramname"><em>ctrlobj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush established pktctrl session internal writer buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctrlobj</td><td>Pointer to an established pktctrl session object struct.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li><a class="el" href="a00008.html#a3ace6f70ba59b0b91eafc514984dbfc1" title="Flush established pktctrl session internal writer buffer.">pktctrl_flush_write()</a> functions the same as <a class="el" href="a00005.html#a524fb1985afe251a4ba072fd9176fd98" title="Flush pktlab writer internal buffer.">pktlab_flush_writer()</a> except passing in an established pktctrl session object struct than a writer. Note one does not need to create a writer for ctrlobj as an internal one is used.</li>
<li>See <a class="el" href="a00005.html#a524fb1985afe251a4ba072fd9176fd98" title="Flush pktlab writer internal buffer.">pktlab_flush_writer()</a> for more information on behavior. </li>
</ul>

</div>
</div>
<a id="a45538721942c809d798a9df19fe3fde2" name="a45538721942c809d798a9df19fe3fde2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45538721942c809d798a9df19fe3fde2">&#9670;&nbsp;</a></span>pktctrl_gen_snikey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktctrl_gen_snikey </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate random '\0'-terminated valid snikey of PKTCTRL_SNIKEY_LEN_MAX length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf</td><td>Pointer to return allocated snikey. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An enum pktctrl_err value:<ol type="1">
<li>PKTCTRL_SUCCESS for success. *buf points to a valid snikey upon return.</li>
<li>PKTCTRL_INVAL for bad argument.</li>
<li>PKTCTRL_UNKNOWN_FAULT for other unknown errors.</li>
</ol>
</dd></dl>
<ul>
<li>The returned buf should be freed with free() in stdlib.h. </li>
</ul>

</div>
</div>
<a id="a92a512472a6e50b85f39812d0d53bf54" name="a92a512472a6e50b85f39812d0d53bf54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a512472a6e50b85f39812d0d53bf54">&#9670;&nbsp;</a></span>pktctrl_get_client_keycert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktctrl_get_client_keycert </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00238.html">pktctrl_keycert_store</a> *&#160;</td>
          <td class="paramname"><em>store</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="a00230.html">pktlab_certificate</a> ***&#160;</td>
          <td class="paramname"><em>cert_ls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t *&#160;</td>
          <td class="paramname"><em>certnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="a00222.html">pktlab_publickey</a> ***&#160;</td>
          <td class="paramname"><em>root_ls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t *&#160;</td>
          <td class="paramname"><em>rootnum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get loaded client certificate chain and trusted roots from client pktctrl key certificate storage struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">store</td><td>Pointer to a client pktctrl key certificate storage struct. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cert_ls</td><td>Pointer to return the loaded client certificate chain. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">certnum</td><td>Pointer to return the number of client certificates loaded. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">root_ls</td><td>Pointer to return the loaded trusted roots. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rootnum</td><td>Pointer to return the number of trusted roots loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An enum pktctrl_err value:<ol type="1">
<li>PKTCTRL_SUCCESS for success.</li>
<li>PKTCTRL_INVAL for bad argument.</li>
<li>PKTCTRL_UNKNOWN_FAULT for other unknown errors.</li>
</ol>
</dd></dl>
<ul>
<li>It is allowed for cert_ls/certnum/root_ls/rootnum to be NULL. No value is returned in that case.</li>
<li>See also <a class="el" href="a00008.html#a305c2ee2d888933d2f112086fbcf4d27" title="Get initialized pktctrl key certificate storage struct.">pktctrl_create_keycert_store()</a>, <a class="el" href="a00008.html#a29c89252994eea5f11e93a3f0353ef2f" title="Load client certificate chain and trusted roots into pktctrl key certificate storage struct.">pktctrl_set_client_keycert()</a>, <a class="el" href="a00008.html#a2b8e30906df870b6414f177bc2472f06" title="Delete client certificate chain and trusted roots from client pktctrl key certificate storage struct.">pktctrl_clear_client_keycert()</a>, <a class="el" href="a00008.html#a94b28634e273d44048fac47190c02592" title="Free an allocated pktctrl key certificate storage struct.">pktctrl_cleanup_keycert_store()</a>. </li>
</ul>

</div>
</div>
<a id="af0295dbf65e80898d7bfe33b5d5e9774" name="af0295dbf65e80898d7bfe33b5d5e9774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0295dbf65e80898d7bfe33b5d5e9774">&#9670;&nbsp;</a></span>pktctrl_get_server_keycert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktctrl_get_server_keycert </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00238.html">pktctrl_keycert_store</a> *&#160;</td>
          <td class="paramname"><em>store</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>snikey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="a00230.html">pktlab_certificate</a> ***&#160;</td>
          <td class="paramname"><em>cert_ls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t *&#160;</td>
          <td class="paramname"><em>certnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="a00222.html">pktlab_publickey</a> ***&#160;</td>
          <td class="paramname"><em>root_ls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t *&#160;</td>
          <td class="paramname"><em>rootnum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get loaded server certificate chain and trusted roots for some snikey from server pktctrl key certificate storage struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">store</td><td>Pointer to a server pktctrl key certificate storage struct. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">snikey</td><td>Pointer to the target '\0'-terminated snikey. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cert_ls</td><td>Pointer to return the loaded server certificate chain. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">certnum</td><td>Pointer to return the number of server certificates loaded. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">root_ls</td><td>Pointer to return the loaded trusted roots. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rootnum</td><td>Pointer to return the number of trusted roots loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An enum pktctrl_err value:<ol type="1">
<li>PKTCTRL_SUCCESS for success.</li>
<li>PKTCTRL_INVAL for bad argument.</li>
<li>PKTCTRL_KEY_NOT_FOUND for snikey not present in internal map.</li>
<li>PKTCTRL_UNKNOWN_FAULT for other unknown errors.</li>
</ol>
</dd></dl>
<ul>
<li>It is allowed for cert_ls/certnum/root_ls/rootnum to be NULL. No value is returned in that case.</li>
<li>See also <a class="el" href="a00008.html#a305c2ee2d888933d2f112086fbcf4d27" title="Get initialized pktctrl key certificate storage struct.">pktctrl_create_keycert_store()</a>, <a class="el" href="a00008.html#ad2e0704e458c3dbc88b5ab2dea05ce20" title="Load server certificate chain and trusted roots for some snikey into pktctrl key certificate storage ...">pktctrl_set_server_keycert()</a>, <a class="el" href="a00008.html#a1be7d2f5f60414ca68ef56e8da539af4" title="Delete server certificate chain and trusted roots entry for some snikey from server pktctrl key certi...">pktctrl_clear_server_keycert()</a>, <a class="el" href="a00008.html#aaccfd58551186821c1f6b90d0b341763" title="Set server pktctrl key certificate storage default entry.">pktctrl_set_server_keycert_default()</a>, <a class="el" href="a00008.html#a54f117b16610d1d34d88d245925e327d" title="Clear server pktctrl key certificate storage default entry.">pktctrl_clear_server_keycert_default()</a>, <a class="el" href="a00008.html#a94b28634e273d44048fac47190c02592" title="Free an allocated pktctrl key certificate storage struct.">pktctrl_cleanup_keycert_store()</a>. </li>
</ul>

</div>
</div>
<a id="ac41202c999aa3855527f3071a1b34f7a" name="ac41202c999aa3855527f3071a1b34f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41202c999aa3855527f3071a1b34f7a">&#9670;&nbsp;</a></span>pktctrl_is_established()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pktctrl_is_established </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00234.html">pktctrl_obj</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a pktctrl session object is established. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>Pointer to a pktctrl session object struct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if obj is established, false otherwise. </dd></dl>

</div>
</div>
<a id="a397284764f311338125d986add53f6b0" name="a397284764f311338125d986add53f6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a397284764f311338125d986add53f6b0">&#9670;&nbsp;</a></span>pktctrl_is_valid_snikey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pktctrl_is_valid_snikey </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>snikey</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if '\0'-terminated string is a valid snikey. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">snikey</td><td>Pointer to a '\0'-terminated string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if string is valid snikey, false otherwise.</dd></dl>
<ul>
<li>A valid snikey is a string of length in [PKTCTRL_SNIKEY_LEN_MIN,PKTCTRL_SNIKEY_LEN_MAX] consisting only of lowercase letters (a-z) and digits (0-9). </li>
</ul>

</div>
</div>
<a id="a3f9e994bb2d046ae32776f6e485b7654" name="a3f9e994bb2d046ae32776f6e485b7654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9e994bb2d046ae32776f6e485b7654">&#9670;&nbsp;</a></span>pktctrl_prepare_select()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktctrl_prepare_select </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nfds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fd_set *restrict&#160;</td>
          <td class="paramname"><em>rset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fd_set *restrict&#160;</td>
          <td class="paramname"><em>wset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>want_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>want_write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="a00234.html">pktctrl_obj</a> *&#160;</td>
          <td class="paramname"><em>ctrlobj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up arguments to select() for read/write operation on established pktctrl session based on intention. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">nfds</td><td>Pointer to update the nfds value to select on the ctrlobj fd. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rset</td><td>Read fdset. May be set for ctrlobj fd. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">wset</td><td>Write fdset. May be set for ctrlobj fd. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">want_read</td><td>Intention on wanting to read from ctrlobj. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">want_write</td><td>Intention on wanting to write to ctrlobj. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctrlobj</td><td>Pointer to an established pktctrl session object struct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An enum pktctrl_err value:<ol type="1">
<li>PKTCTRL_SUCCESS for success. rset and wset are set based on the read/write intention passed in. nfds is updated to cover the ctrlobj fd.</li>
<li>PKTCTRL_INVAL for bad argument.</li>
</ol>
</dd></dl>
<ul>
<li>In case of intending to call select() to continue on the TLS handshake, both want_read and want_write should be set.</li>
<li>rset and wset is not zeroed by <a class="el" href="a00008.html#a3f9e994bb2d046ae32776f6e485b7654" title="Set up arguments to select() for read/write operation on established pktctrl session based on intenti...">pktctrl_prepare_select()</a>.</li>
<li>Note <a class="el" href="a00008.html#a3f9e994bb2d046ae32776f6e485b7654" title="Set up arguments to select() for read/write operation on established pktctrl session based on intenti...">pktctrl_prepare_select()</a> should be used when setting up a select call for a ctrlobj fd, as <a class="el" href="a00008.html#a3f9e994bb2d046ae32776f6e485b7654" title="Set up arguments to select() for read/write operation on established pktctrl session based on intenti...">pktctrl_prepare_select()</a> contains internal logic on handling scenarios where for a TLS connection, to read may require selecting on write and vice versa.</li>
<li>See also <a class="el" href="a00008.html#a8279507226b23643acd873e2dfc5a3cd" title="Get initialized pktctrl session object struct.">pktctrl_create_obj()</a>, <a class="el" href="a00008.html#aaec80c881e4b3cf697876096ea7f55b0" title="Perform TLS server-side handshake to establish TLS pktctrl session.">pktctrl_accept()</a>, <a class="el" href="a00008.html#aeeac3c0ac9e90bedb7d097befc57bcca" title="Perform TLS client-side handshake to establish TLS pktctrl session.">pktctrl_connect()</a>, <a class="el" href="a00008.html#a2542ce6ffff4135a1dc4457f9dde1601" title="Set up pktctrl session object struct to establish barebone TCP pktctrl session.">pktctrl_raw_session()</a>, <a class="el" href="a00008.html#ad443d74d362a4b19e54a4c856eb2ae06" title="Process select() results to identify if read/write operation on established pktctrl session can be pe...">pktctrl_process_select()</a>. </li>
</ul>

</div>
</div>
<a id="ad443d74d362a4b19e54a4c856eb2ae06" name="ad443d74d362a4b19e54a4c856eb2ae06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad443d74d362a4b19e54a4c856eb2ae06">&#9670;&nbsp;</a></span>pktctrl_process_select()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktctrl_process_select </td>
          <td>(</td>
          <td class="paramtype">const fd_set *restrict&#160;</td>
          <td class="paramname"><em>rset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fd_set *restrict&#160;</td>
          <td class="paramname"><em>wset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="a00234.html">pktctrl_obj</a> *&#160;</td>
          <td class="paramname"><em>ctrlobj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>readable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>writable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process select() results to identify if read/write operation on established pktctrl session can be performed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rset</td><td>select()-set read fdset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wset</td><td>select()-set write fdset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctrlobj</td><td>Pointer to an established pktctrl session object struct. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">readable</td><td>Pointer to return if read operation can be performed on ctrlobj. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">writable</td><td>Pointer to return if write operation can be performed on ctrlobj. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An enum pktctrl_err value:<ol type="1">
<li>PKTCTRL_SUCCESS for success. readable and writable are set.</li>
<li>PKTCTRL_INVAL for bad argument.</li>
</ol>
</dd></dl>
<ul>
<li>The in progress TLS handshake (<a class="el" href="a00008.html#aaec80c881e4b3cf697876096ea7f55b0" title="Perform TLS server-side handshake to establish TLS pktctrl session.">pktctrl_accept()</a>/pktctrl_connect()) for ctrlobj can be continued when either readable or writable is set.</li>
<li>Note <a class="el" href="a00008.html#ad443d74d362a4b19e54a4c856eb2ae06" title="Process select() results to identify if read/write operation on established pktctrl session can be pe...">pktctrl_process_select()</a> should be used when parsing a select call return values for a ctrlobj fd, as <a class="el" href="a00008.html#ad443d74d362a4b19e54a4c856eb2ae06" title="Process select() results to identify if read/write operation on established pktctrl session can be pe...">pktctrl_process_select()</a> contains internal logic on handling scenarios where for a TLS connection, readable may require write being set and vice versa.</li>
<li>See also <a class="el" href="a00008.html#a8279507226b23643acd873e2dfc5a3cd" title="Get initialized pktctrl session object struct.">pktctrl_create_obj()</a>, <a class="el" href="a00008.html#aaec80c881e4b3cf697876096ea7f55b0" title="Perform TLS server-side handshake to establish TLS pktctrl session.">pktctrl_accept()</a>, <a class="el" href="a00008.html#aeeac3c0ac9e90bedb7d097befc57bcca" title="Perform TLS client-side handshake to establish TLS pktctrl session.">pktctrl_connect()</a>, <a class="el" href="a00008.html#a2542ce6ffff4135a1dc4457f9dde1601" title="Set up pktctrl session object struct to establish barebone TCP pktctrl session.">pktctrl_raw_session()</a>, <a class="el" href="a00008.html#a3f9e994bb2d046ae32776f6e485b7654" title="Set up arguments to select() for read/write operation on established pktctrl session based on intenti...">pktctrl_prepare_select()</a>. </li>
</ul>

</div>
</div>
<a id="a2542ce6ffff4135a1dc4457f9dde1601" name="a2542ce6ffff4135a1dc4457f9dde1601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2542ce6ffff4135a1dc4457f9dde1601">&#9670;&nbsp;</a></span>pktctrl_raw_session()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktctrl_raw_session </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="a00234.html">pktctrl_obj</a> *&#160;</td>
          <td class="paramname"><em>ctrlobj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up pktctrl session object struct to establish barebone TCP pktctrl session. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>File descriptor for an established TCP connection. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctrlobj</td><td>Pointer to an initialized pktctrl session object struct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An enum pktctrl_err value:<ol type="1">
<li>PKTCTRL_SUCCESS for success. ctrlobj is an established session object upon return.</li>
<li>PKTCTRL_INVAL for bad argument.</li>
<li>PKTCTRL_UNKNOWN_FAULT for other unknown errors.</li>
</ol>
</dd></dl>
<ul>
<li>ctrlobj &amp; fd should be freed &amp; closed after <a class="el" href="a00008.html#a2542ce6ffff4135a1dc4457f9dde1601" title="Set up pktctrl session object struct to establish barebone TCP pktctrl session.">pktctrl_raw_session()</a> returned PKTCTRL_UNKNOWN_FAULT.</li>
<li><a class="el" href="a00008.html#a2542ce6ffff4135a1dc4457f9dde1601" title="Set up pktctrl session object struct to establish barebone TCP pktctrl session.">pktctrl_raw_session()</a> should not block whether fd is blocking or not.</li>
<li><a class="el" href="a00008.html#a2542ce6ffff4135a1dc4457f9dde1601" title="Set up pktctrl session object struct to establish barebone TCP pktctrl session.">pktctrl_raw_session()</a> is especially useful when writing experiment programs that work with the pktlabec general experiment controller. See pktlabec repo README for more information.</li>
<li>See also <a class="el" href="a00008.html#a8279507226b23643acd873e2dfc5a3cd" title="Get initialized pktctrl session object struct.">pktctrl_create_obj()</a>, <a class="el" href="a00008.html#abd20ed6c8d0d9e3a0a73d5d61c420234" title="Read pktctrl message from established pktctrl session.">pktctrl_read_message()</a>, <a class="el" href="a00008.html#a50ec6e10884502f16184ac0921e173be" title="Write pktctrl message to established pktctrl session.">pktctrl_write_message()</a>. </li>
</ul>

</div>
</div>
<a id="aef4c0ae98db6704c052253da9a8ffc57" name="aef4c0ae98db6704c052253da9a8ffc57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef4c0ae98db6704c052253da9a8ffc57">&#9670;&nbsp;</a></span>pktctrl_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t pktctrl_read </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00234.html">pktctrl_obj</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbyte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read bytes from established pktctrl session. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">obj</td><td>Pointer to an established pktctrl session object struct. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Pointer to buffer for storing the read bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buflen</td><td>Attempted read length (must be &gt; 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read, 0 for EOF, or &lt; 0 for error (see errno for more information).</dd></dl>
<ul>
<li><a class="el" href="a00008.html#aef4c0ae98db6704c052253da9a8ffc57" title="Read bytes from established pktctrl session.">pktctrl_read()</a> should not be called after calling <a class="el" href="a00008.html#abd20ed6c8d0d9e3a0a73d5d61c420234" title="Read pktctrl message from established pktctrl session.">pktctrl_read_message()</a> with obj.</li>
<li>To read pktlab protocol messages, <a class="el" href="a00008.html#abd20ed6c8d0d9e3a0a73d5d61c420234" title="Read pktctrl message from established pktctrl session.">pktctrl_read_message()</a> is recommended instead. </li>
</ul>

</div>
</div>
<a id="abd20ed6c8d0d9e3a0a73d5d61c420234" name="abd20ed6c8d0d9e3a0a73d5d61c420234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd20ed6c8d0d9e3a0a73d5d61c420234">&#9670;&nbsp;</a></span>pktctrl_read_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktctrl_read_message </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00234.html">pktctrl_obj</a> *&#160;</td>
          <td class="paramname"><em>ctrlobj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="a00042.html">pktlab_message</a> **&#160;</td>
          <td class="paramname"><em>msgptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read pktctrl message from established pktctrl session. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctrlobj</td><td>Pointer to an established pktctrl session object struct. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">msgptr</td><td>Pointer to return an allocated fields-set msg that was read.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li><a class="el" href="a00008.html#abd20ed6c8d0d9e3a0a73d5d61c420234" title="Read pktctrl message from established pktctrl session.">pktctrl_read_message()</a> functions the same as <a class="el" href="a00005.html#adb3ef3c891d623ca8152429834b4fde0" title="pktlab reader read message.">pktlab_read_message()</a> except passing in an established pktctrl session object struct than a reader. Note one does not need to create a reader for ctrlobj as an internal one is used.</li>
<li>See <a class="el" href="a00005.html#adb3ef3c891d623ca8152429834b4fde0" title="pktlab reader read message.">pktlab_read_message()</a> for more information on behavior. </li>
</ul>

</div>
</div>
<a id="a29c89252994eea5f11e93a3f0353ef2f" name="a29c89252994eea5f11e93a3f0353ef2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c89252994eea5f11e93a3f0353ef2f">&#9670;&nbsp;</a></span>pktctrl_set_client_keycert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktctrl_set_client_keycert </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00238.html">pktctrl_keycert_store</a> *&#160;</td>
          <td class="paramname"><em>store</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="a00230.html">pktlab_certificate</a> **&#160;</td>
          <td class="paramname"><em>cert_ls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>certnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="a00222.html">pktlab_publickey</a> **&#160;</td>
          <td class="paramname"><em>root_ls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>rootnum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load client certificate chain and trusted roots into pktctrl key certificate storage struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">store</td><td>Pointer to an initialized/client pktctrl key certificate storage struct. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cert_ls</td><td>Array of pointers to loaded pktlab certificate structs to be loaded as the client certificate chain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">certnum</td><td>The number of certificates being loaded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root_ls</td><td>Array of pointers to loaded pktlab public key structs to be loaded as the remote party certificate chain trusted roots. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rootnum</td><td>The number of public keys being loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An enum pktctrl_err value:<ol type="1">
<li>PKTCTRL_SUCCESS for success.</li>
<li>PKTCTRL_INVAL for bad argument.</li>
<li>PKTCTRL_UNKNOWN_FAULT for other unknown errors.</li>
</ol>
</dd></dl>
<ul>
<li>When an initialized pktctrl key certificate storage struct is called with <a class="el" href="a00008.html#a29c89252994eea5f11e93a3f0353ef2f" title="Load client certificate chain and trusted roots into pktctrl key certificate storage struct.">pktctrl_set_client_keycert()</a> successfully, the key certificate storage is marked as a "client" key certificate storage and can only be used with <a class="el" href="a00008.html#aeeac3c0ac9e90bedb7d097befc57bcca" title="Perform TLS client-side handshake to establish TLS pktctrl session.">pktctrl_connect()</a> afterwards for TLS client-side connection establishment.</li>
<li>The loaded cert_ls and root_ls are used to perform the TLS handshake. Note no ordering on cert_ls is needed EXCEPT the first certificate should contain the public key corresponding to clientkey in <a class="el" href="a00008.html#aeeac3c0ac9e90bedb7d097befc57bcca" title="Perform TLS client-side handshake to establish TLS pktctrl session.">pktctrl_connect()</a>. No ordering on root_ls is needed.</li>
<li>It is allowed for cert_ls to be NULL. This will result in not supplying any client certificate during the TLS handshake.</li>
<li>It is allowed for root_ls to be NULL as well. This will result in accepting whatever root the server certificate chain contains during the TLS handshake (the certificate chain form is still checked).</li>
<li>Certificate struct(s) in cert_ls (and cert_ls itself) and public key struct(s) in root_ls (and root_ls itself) must not go out of scope/freed when store is still being used as they are not copied by this function into store.</li>
<li>When cert_ls/root_ls is NULL, certnum/rootnum must be 0 and vice versa.</li>
<li>See also <a class="el" href="a00008.html#a305c2ee2d888933d2f112086fbcf4d27" title="Get initialized pktctrl key certificate storage struct.">pktctrl_create_keycert_store()</a>, <a class="el" href="a00008.html#a92a512472a6e50b85f39812d0d53bf54" title="Get loaded client certificate chain and trusted roots from client pktctrl key certificate storage str...">pktctrl_get_client_keycert()</a>, <a class="el" href="a00008.html#a2b8e30906df870b6414f177bc2472f06" title="Delete client certificate chain and trusted roots from client pktctrl key certificate storage struct.">pktctrl_clear_client_keycert()</a>, <a class="el" href="a00008.html#a94b28634e273d44048fac47190c02592" title="Free an allocated pktctrl key certificate storage struct.">pktctrl_cleanup_keycert_store()</a>. </li>
</ul>

</div>
</div>
<a id="ad2e0704e458c3dbc88b5ab2dea05ce20" name="ad2e0704e458c3dbc88b5ab2dea05ce20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e0704e458c3dbc88b5ab2dea05ce20">&#9670;&nbsp;</a></span>pktctrl_set_server_keycert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktctrl_set_server_keycert </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00238.html">pktctrl_keycert_store</a> *&#160;</td>
          <td class="paramname"><em>store</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>snikey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="a00230.html">pktlab_certificate</a> **&#160;</td>
          <td class="paramname"><em>cert_ls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>certnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="a00222.html">pktlab_publickey</a> **&#160;</td>
          <td class="paramname"><em>root_ls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>rootnum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load server certificate chain and trusted roots for some snikey into pktctrl key certificate storage struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">store</td><td>Pointer to an initialized/server pktctrl key certificate storage struct. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">snikey</td><td>Pointer to the target '\0'-terminated snikey. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cert_ls</td><td>Array of pointers to loaded pktlab certificate structs to be loaded as the server certificate chain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">certnum</td><td>The number of certificates being loaded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root_ls</td><td>Array of pointers to loaded pktlab public key structs to be loaded as the remote party certificate chain trusted roots. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rootnum</td><td>The number of public keys being loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An enum pktctrl_err value:<ol type="1">
<li>PKTCTRL_SUCCESS for success.</li>
<li>PKTCTRL_INVAL for bad argument.</li>
<li>PKTCTRL_MAP_ERR for internal map error.</li>
<li>PKTCTRL_UNKNOWN_FAULT for other unknown errors.</li>
</ol>
</dd></dl>
<ul>
<li>store should be freed after <a class="el" href="a00008.html#ad2e0704e458c3dbc88b5ab2dea05ce20" title="Load server certificate chain and trusted roots for some snikey into pktctrl key certificate storage ...">pktctrl_set_server_keycert()</a> returned PKTCTRL_MAP_ERR.</li>
<li>When an initialized pktctrl key certificate storage struct is called with <a class="el" href="a00008.html#ad2e0704e458c3dbc88b5ab2dea05ce20" title="Load server certificate chain and trusted roots for some snikey into pktctrl key certificate storage ...">pktctrl_set_server_keycert()</a> successfully, the key certificate storage is marked as a "server" key certificate storage and can only be used with <a class="el" href="a00008.html#aaec80c881e4b3cf697876096ea7f55b0" title="Perform TLS server-side handshake to establish TLS pktctrl session.">pktctrl_accept()</a> afterwards for TLS server-side connection establishment.</li>
<li>Effectively, each successful non-NULL cert_ls call will result in an insertion/update of an entry (key being the snikey while values being cert_ls and root_ls) in the internal storage map. Afterwards, when supplying the storage to <a class="el" href="a00008.html#aaec80c881e4b3cf697876096ea7f55b0" title="Perform TLS server-side handshake to establish TLS pktctrl session.">pktctrl_accept()</a> call, the internal map is looked up to see if there is an entry matching the incoming TLS client supplied snikey. If such an entry exists, the corresponding cert_ls and root_ls is used to perform the TLS handshake. Note if no such entry exists, the handshake is failed. No ordering on cert_ls is needed EXCEPT the first certificate should contain the public key corresponding to serverkey in <a class="el" href="a00008.html#aaec80c881e4b3cf697876096ea7f55b0" title="Perform TLS server-side handshake to establish TLS pktctrl session.">pktctrl_accept()</a>. No ordering on root_ls is needed.</li>
<li>OTOH, for successful NULL cert_ls calls (root_ls must be NULL in these kind of calls), the corresponding entry is deleted for the supplied snikey.</li>
<li>It is allowed for root_ls to be NULL for the non-NULL cert_ls case. This will result in accepting whatever root the client certificate chain contains during the TLS handshake (the certificate chain form is still checked).</li>
<li>Certificate struct(s) in cert_ls (and cert_ls itself) and public key struct(s) in root_ls (and root_ls itself) must not go out of scope/freed when store is still being used as they are not copied by this function into store.</li>
<li>When cert_ls/root_ls is NULL, certnum/rootnum must be 0 and vice versa.</li>
<li>See also <a class="el" href="a00008.html#a305c2ee2d888933d2f112086fbcf4d27" title="Get initialized pktctrl key certificate storage struct.">pktctrl_create_keycert_store()</a>, <a class="el" href="a00008.html#af0295dbf65e80898d7bfe33b5d5e9774" title="Get loaded server certificate chain and trusted roots for some snikey from server pktctrl key certifi...">pktctrl_get_server_keycert()</a>, <a class="el" href="a00008.html#a1be7d2f5f60414ca68ef56e8da539af4" title="Delete server certificate chain and trusted roots entry for some snikey from server pktctrl key certi...">pktctrl_clear_server_keycert()</a>, <a class="el" href="a00008.html#aaccfd58551186821c1f6b90d0b341763" title="Set server pktctrl key certificate storage default entry.">pktctrl_set_server_keycert_default()</a>, <a class="el" href="a00008.html#a54f117b16610d1d34d88d245925e327d" title="Clear server pktctrl key certificate storage default entry.">pktctrl_clear_server_keycert_default()</a>, <a class="el" href="a00008.html#a94b28634e273d44048fac47190c02592" title="Free an allocated pktctrl key certificate storage struct.">pktctrl_cleanup_keycert_store()</a>. </li>
</ul>

</div>
</div>
<a id="aaccfd58551186821c1f6b90d0b341763" name="aaccfd58551186821c1f6b90d0b341763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaccfd58551186821c1f6b90d0b341763">&#9670;&nbsp;</a></span>pktctrl_set_server_keycert_default()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktctrl_set_server_keycert_default </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00238.html">pktctrl_keycert_store</a> *&#160;</td>
          <td class="paramname"><em>store</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>snikey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set server pktctrl key certificate storage default entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">store</td><td>Pointer to a server pktctrl key certificate storage struct. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">snikey</td><td>Pointer to the target '\0'-terminated snikey. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An enum pktctrl_err value:<ol type="1">
<li>PKTCTRL_SUCCESS for success.</li>
<li>PKTCTRL_INVAL for bad argument.</li>
<li>PKTCTRL_KEY_NOT_FOUND for snikey not present in internal map.</li>
<li>PKTCTRL_UNKNOWN_FAULT for other unknown errors.</li>
</ol>
</dd></dl>
<ul>
<li>Note when setting a snikey to be the default entry, whenever an incoming TLS client forgoes providing any snikey for TLS handshake, the cert_ls and root_ls for the set snikey entry is used to continue the handshake.</li>
<li>Subsequent successful <a class="el" href="a00008.html#aaccfd58551186821c1f6b90d0b341763" title="Set server pktctrl key certificate storage default entry.">pktctrl_set_server_keycert_default()</a> call overwrites the set default entry.</li>
<li>Setting default entry is not required prior to calling <a class="el" href="a00008.html#aaec80c881e4b3cf697876096ea7f55b0" title="Perform TLS server-side handshake to establish TLS pktctrl session.">pktctrl_accept()</a>.</li>
<li>See also <a class="el" href="a00008.html#a305c2ee2d888933d2f112086fbcf4d27" title="Get initialized pktctrl key certificate storage struct.">pktctrl_create_keycert_store()</a>, <a class="el" href="a00008.html#ad2e0704e458c3dbc88b5ab2dea05ce20" title="Load server certificate chain and trusted roots for some snikey into pktctrl key certificate storage ...">pktctrl_set_server_keycert()</a>, <a class="el" href="a00008.html#af0295dbf65e80898d7bfe33b5d5e9774" title="Get loaded server certificate chain and trusted roots for some snikey from server pktctrl key certifi...">pktctrl_get_server_keycert()</a>, <a class="el" href="a00008.html#a1be7d2f5f60414ca68ef56e8da539af4" title="Delete server certificate chain and trusted roots entry for some snikey from server pktctrl key certi...">pktctrl_clear_server_keycert()</a>, <a class="el" href="a00008.html#a54f117b16610d1d34d88d245925e327d" title="Clear server pktctrl key certificate storage default entry.">pktctrl_clear_server_keycert_default()</a>, <a class="el" href="a00008.html#a94b28634e273d44048fac47190c02592" title="Free an allocated pktctrl key certificate storage struct.">pktctrl_cleanup_keycert_store()</a>. </li>
</ul>

</div>
</div>
<a id="a8a5f99bb21f5998b1b9ada05240c2dfc" name="a8a5f99bb21f5998b1b9ada05240c2dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a5f99bb21f5998b1b9ada05240c2dfc">&#9670;&nbsp;</a></span>pktctrl_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t pktctrl_write </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00234.html">pktctrl_obj</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbyte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write bytes to established pktctrl session. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">obj</td><td>Pointer to an established pktctrl session object struct. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Target write bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buflen</td><td>Attempted write length (must be &gt; 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written, or &lt; 0 for error (see errno for more information).</dd></dl>
<ul>
<li><a class="el" href="a00008.html#a8a5f99bb21f5998b1b9ada05240c2dfc" title="Write bytes to established pktctrl session.">pktctrl_write()</a> should not be called after calling <a class="el" href="a00008.html#a50ec6e10884502f16184ac0921e173be" title="Write pktctrl message to established pktctrl session.">pktctrl_write_message()</a> with obj.</li>
<li>To write pktlab protocol messages, <a class="el" href="a00008.html#a50ec6e10884502f16184ac0921e173be" title="Write pktctrl message to established pktctrl session.">pktctrl_write_message()</a> is recommended instead. </li>
</ul>

</div>
</div>
<a id="a50ec6e10884502f16184ac0921e173be" name="a50ec6e10884502f16184ac0921e173be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ec6e10884502f16184ac0921e173be">&#9670;&nbsp;</a></span>pktctrl_write_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktctrl_write_message </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00234.html">pktctrl_obj</a> *&#160;</td>
          <td class="paramname"><em>ctrlobj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="a00042.html">pktlab_message</a> *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write pktctrl message to established pktctrl session. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctrlobj</td><td>Pointer to an established pktctrl session object struct. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Pointer to a fields-set msg struct.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li><a class="el" href="a00008.html#a50ec6e10884502f16184ac0921e173be" title="Write pktctrl message to established pktctrl session.">pktctrl_write_message()</a> functions the same as <a class="el" href="a00005.html#ae50455dc8d68498355c5dd5094a8770d" title="pktlab writer write message.">pktlab_write_message()</a> except passing in an established pktctrl session object struct than a writer. Note one does not need to create a writer for ctrlobj as an internal one is used.</li>
<li>See <a class="el" href="a00005.html#ae50455dc8d68498355c5dd5094a8770d" title="pktlab writer write message.">pktlab_write_message()</a> for more information on behavior. </li>
</ul>

</div>
</div>
<a id="a0d1c3e03af53207bfa064567492a39ee" name="a0d1c3e03af53207bfa064567492a39ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1c3e03af53207bfa064567492a39ee">&#9670;&nbsp;</a></span>pktctrl_write_unsent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t pktctrl_write_unsent </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="a00234.html">pktctrl_obj</a> *&#160;</td>
          <td class="paramname"><em>ctrlobj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get established pktctrl session internal writer buffered content length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctrlobj</td><td>Pointer to an established pktctrl session object struct.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li><a class="el" href="a00008.html#a0d1c3e03af53207bfa064567492a39ee" title="Get established pktctrl session internal writer buffered content length.">pktctrl_write_unsent()</a> functions the same as <a class="el" href="a00005.html#aae8895ba48507b6ec6af8fb007c61d31" title="Get writer internal buffered content length.">pktlab_writer_unsent()</a> except passing in an established pktctrl session object struct than a writer. Note one does not need to create a writer for ctrlobj as an internal one is used.</li>
<li>See <a class="el" href="a00005.html#aae8895ba48507b6ec6af8fb007c61d31" title="Get writer internal buffered content length.">pktlab_writer_unsent()</a> for more information on behavior. </li>
</ul>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
