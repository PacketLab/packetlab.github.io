<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libpktlab - The PacketLab Utility Library: pktlab.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libpktlab - The PacketLab Utility Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pktlab.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>General utilities for pktlab.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;time.h&gt;</code><br />
<code>#include &lt;arpa/inet.h&gt;</code><br />
<code>#include &lt;sys/time.h&gt;</code><br />
<code>#include &lt;sys/uio.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for pktlab.h:</div>
<div class="dyncontent">
<div class="center"><img src="pktlab_8h__incl.png" border="0" usemap="#pktlab_8h" alt=""/></div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="pktlab_8h__dep__incl.png" border="0" usemap="#pktlab_8hdep" alt=""/></div>
</div>
</div>
<p><a href="pktlab_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpktlab__namevalue__pair.html">pktlab_namevalue_pair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for encoding/decoding experiment descriptor (xdescr)/endpoint attribute (dattr) in xpub and xsub messages.  <a href="structpktlab__namevalue__pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpktlab__aux__field.html">pktlab_aux_field</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure of auxiliary field in <a class="el" href="structpktlab__cert__detail.html" title="Structure for storing pktlab certificate detail information, including cert_info and cert_limit.">pktlab_cert_detail</a>.  <a href="structpktlab__aux__field.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpktlab__channel.html">pktlab_channel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for encoding/decoding channel lists in xpub and xsub messages.  <a href="structpktlab__channel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpktlab__ebpf__instr.html">pktlab_ebpf_instr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for encoding/decoding pktlab eBPF programs in cdata &amp; ncap msg. Represents one eBPF instruction.  <a href="structpktlab__ebpf__instr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpktlab__uri.html">pktlab_uri</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for storing decoded pktlab URI information.  <a href="structpktlab__uri.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpktlab__vmem__region.html">pktlab_vmem_region</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpktlab__message.html">pktlab_message</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for storing the decoded form of pktlab messages.  <a href="structpktlab__message.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpktlab__valid__dest.html">pktlab_valid_dest</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for storing pktlab valid destination information.  <a href="structpktlab__valid__dest.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpktlab__burst__rate.html">pktlab_burst_rate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for storing pktlab burst rate information.  <a href="structpktlab__burst__rate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpktlab__decoded__certificate.html">pktlab_decoded_certificate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for storing decoded pktlab certificate information.  <a href="structpktlab__decoded__certificate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpktlab__cert__detail.html">pktlab_cert_detail</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for storing pktlab certificate detail information, including cert_info and cert_limit.  <a href="structpktlab__cert__detail.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a828da653ba76766cc9fcd6db197ea215"><td class="memItemLeft" align="right" valign="top"><a id="a828da653ba76766cc9fcd6db197ea215"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_IP4_ADDR_LEN</b>&#160;&#160;&#160;PKTLAB_IPV4_WO_MSK_ADDR_LEN</td></tr>
<tr class="separator:a828da653ba76766cc9fcd6db197ea215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f313d0eb7af544e52780eef461bee3"><td class="memItemLeft" align="right" valign="top"><a id="a10f313d0eb7af544e52780eef461bee3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_IP4_MASK_LEN</b>&#160;&#160;&#160;(PKTLAB_IPV4_W_MSK_ADDR_LEN-PKTLAB_IPV4_W_MSK_ADDR_LEN)</td></tr>
<tr class="separator:a10f313d0eb7af544e52780eef461bee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7543ce64bca97ec7ab8c82a3ff9b69d0"><td class="memItemLeft" align="right" valign="top"><a id="a7543ce64bca97ec7ab8c82a3ff9b69d0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_IP6_ADDR_LEN</b>&#160;&#160;&#160;PKTLAB_IPV6_ADDR_LEN</td></tr>
<tr class="separator:a7543ce64bca97ec7ab8c82a3ff9b69d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d503002b7aad4957a85955dab1b0c89"><td class="memItemLeft" align="right" valign="top"><a id="a2d503002b7aad4957a85955dab1b0c89"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_IPV4_W_MSK_ADDR_LEN</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:a2d503002b7aad4957a85955dab1b0c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf463e5af5b971053f1cb52fadd2e3e1"><td class="memItemLeft" align="right" valign="top"><a id="aaf463e5af5b971053f1cb52fadd2e3e1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_IPV4_WO_MSK_ADDR_LEN</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:aaf463e5af5b971053f1cb52fadd2e3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7b2894171a6b5ab02f668e57c05057"><td class="memItemLeft" align="right" valign="top"><a id="abd7b2894171a6b5ab02f668e57c05057"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_IPV6_ADDR_LEN</b>&#160;&#160;&#160;16</td></tr>
<tr class="separator:abd7b2894171a6b5ab02f668e57c05057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dcc95fb64c62467d5e78f717b3e00a2"><td class="memItemLeft" align="right" valign="top"><a id="a0dcc95fb64c62467d5e78f717b3e00a2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_ADDRLEN_MAX</b>&#160;&#160;&#160;PKTLAB_IP6_ADDR_LEN</td></tr>
<tr class="separator:a0dcc95fb64c62467d5e78f717b3e00a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa9fd4fcc5d5ae4a8c4e08710a2c718"><td class="memItemLeft" align="right" valign="top"><a id="aeaa9fd4fcc5d5ae4a8c4e08710a2c718"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_PORTLEN_MAX</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:aeaa9fd4fcc5d5ae4a8c4e08710a2c718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fac7fa614ab3f3b62966afd1090e1bf"><td class="memItemLeft" align="right" valign="top"><a id="a3fac7fa614ab3f3b62966afd1090e1bf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_DEFAULT_ADDR_STR</b>&#160;&#160;&#160;&quot;127.0.0.1&quot;</td></tr>
<tr class="separator:a3fac7fa614ab3f3b62966afd1090e1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b039e6d2880990b5800ec15fce3aad"><td class="memItemLeft" align="right" valign="top"><a id="a16b039e6d2880990b5800ec15fce3aad"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a16b039e6d2880990b5800ec15fce3aad">PKTLAB_DEFAULT_EXP_PORT_STR</a>&#160;&#160;&#160;&quot;20556&quot;</td></tr>
<tr class="memdesc:a16b039e6d2880990b5800ec15fce3aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default controller experiment listening port string. <br /></td></tr>
<tr class="separator:a16b039e6d2880990b5800ec15fce3aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e29c5b0bedbc85790de13769ed1392"><td class="memItemLeft" align="right" valign="top"><a id="a88e29c5b0bedbc85790de13769ed1392"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a88e29c5b0bedbc85790de13769ed1392">PKTLAB_DEFAULT_PUB_PORT_STR</a>&#160;&#160;&#160;&quot;20556&quot;</td></tr>
<tr class="memdesc:a88e29c5b0bedbc85790de13769ed1392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default broker experiment publication port string. <br /></td></tr>
<tr class="separator:a88e29c5b0bedbc85790de13769ed1392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c01c8d966aa2ad245e9626e520ac56"><td class="memItemLeft" align="right" valign="top"><a id="a39c01c8d966aa2ad245e9626e520ac56"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a39c01c8d966aa2ad245e9626e520ac56">PKTLAB_DEFAULT_SUB_PORT_STR</a>&#160;&#160;&#160;&quot;20557&quot;</td></tr>
<tr class="memdesc:a39c01c8d966aa2ad245e9626e520ac56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default broker experiment subscription port string. <br /></td></tr>
<tr class="separator:a39c01c8d966aa2ad245e9626e520ac56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6e85ef477d5d66aaade844bfdeed52"><td class="memItemLeft" align="right" valign="top"><a id="a2a6e85ef477d5d66aaade844bfdeed52"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a2a6e85ef477d5d66aaade844bfdeed52">PKTLAB_DEFAULT_PROXY_SETUP_PORT_STR</a>&#160;&#160;&#160;&quot;20557&quot;</td></tr>
<tr class="memdesc:a2a6e85ef477d5d66aaade844bfdeed52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default proxy setup port string. <br /></td></tr>
<tr class="separator:a2a6e85ef477d5d66aaade844bfdeed52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156ea4cf7600c8163a6f779e10c2230f"><td class="memItemLeft" align="right" valign="top"><a id="a156ea4cf7600c8163a6f779e10c2230f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_DEFAULT_SPEC_STR</b>&#160;&#160;&#160;PKTLAB_DEFAULT_ADDR_STR &quot;:&quot; <a class="el" href="pktlab_8h.html#a16b039e6d2880990b5800ec15fce3aad">PKTLAB_DEFAULT_EXP_PORT_STR</a></td></tr>
<tr class="separator:a156ea4cf7600c8163a6f779e10c2230f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47cc95ca9cd146cbfeba990af672e36a"><td class="memItemLeft" align="right" valign="top"><a id="a47cc95ca9cd146cbfeba990af672e36a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a47cc95ca9cd146cbfeba990af672e36a">PKTLAB_MAX_SKT_CNT</a>&#160;&#160;&#160;0x100</td></tr>
<tr class="memdesc:a47cc95ca9cd146cbfeba990af672e36a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Endpoint maximum pktlab socket count. <br /></td></tr>
<tr class="separator:a47cc95ca9cd146cbfeba990af672e36a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470c9c80d8946a4b3bd64799f641678b"><td class="memItemLeft" align="right" valign="top"><a id="a470c9c80d8946a4b3bd64799f641678b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a470c9c80d8946a4b3bd64799f641678b">PKTLAB_MAX_LADDR_CNT</a>&#160;&#160;&#160;0x100</td></tr>
<tr class="memdesc:a470c9c80d8946a4b3bd64799f641678b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Endpoint maximum exportable local addresses. <br /></td></tr>
<tr class="separator:a470c9c80d8946a4b3bd64799f641678b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1bf6b98c2a4a7554078d0513ce2958"><td class="memItemLeft" align="right" valign="top"><a id="a3e1bf6b98c2a4a7554078d0513ce2958"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a3e1bf6b98c2a4a7554078d0513ce2958">PKTLAB_MAX_LDNSADDR_CNT</a>&#160;&#160;&#160;0x10</td></tr>
<tr class="memdesc:a3e1bf6b98c2a4a7554078d0513ce2958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Endpoint maximum exportable local DNS addresses. <br /></td></tr>
<tr class="separator:a3e1bf6b98c2a4a7554078d0513ce2958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20a892fd7aef0f5790fd0be7072fac4"><td class="memItemLeft" align="right" valign="top"><a id="ac20a892fd7aef0f5790fd0be7072fac4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_SHA256_DIGEST_LEN</b>&#160;&#160;&#160;32</td></tr>
<tr class="separator:ac20a892fd7aef0f5790fd0be7072fac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78ad6d39cd33c710b9d77d0df88a6c4"><td class="memItemLeft" align="right" valign="top"><a id="aa78ad6d39cd33c710b9d77d0df88a6c4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_ED25519_SIG_LEN</b>&#160;&#160;&#160;64</td></tr>
<tr class="separator:aa78ad6d39cd33c710b9d77d0df88a6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1acd59a98e3f919ede3ab5cf0a145526"><td class="memItemLeft" align="right" valign="top"><a id="a1acd59a98e3f919ede3ab5cf0a145526"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_TICKS_PER_SECOND</b>&#160;&#160;&#160;UINT64_C(1000000000)</td></tr>
<tr class="separator:a1acd59a98e3f919ede3ab5cf0a145526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade167148b2a156b58b895669ea77623b"><td class="memItemLeft" align="right" valign="top"><a id="ade167148b2a156b58b895669ea77623b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_TIME_MAX</b>&#160;&#160;&#160;UINT64_MAX</td></tr>
<tr class="separator:ade167148b2a156b58b895669ea77623b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef40af211a0fdbb26347859d4379d45"><td class="memItemLeft" align="right" valign="top"><a id="afef40af211a0fdbb26347859d4379d45"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_NAMEVALUE_PAIR_SEP</b>&#160;&#160;&#160;'='</td></tr>
<tr class="separator:afef40af211a0fdbb26347859d4379d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ef2420b63b44aa29be0a89609d194a"><td class="memItemLeft" align="right" valign="top"><a id="aa5ef2420b63b44aa29be0a89609d194a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_NAMEVALUE_PAIR_END</b>&#160;&#160;&#160;';'</td></tr>
<tr class="separator:aa5ef2420b63b44aa29be0a89609d194a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f173dc9dc2faa6c3483f1261e0644c"><td class="memItemLeft" align="right" valign="top"><a id="ac3f173dc9dc2faa6c3483f1261e0644c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_NAMEVALUE_NAMELEN_MIN</b>&#160;&#160;&#160;0x1</td></tr>
<tr class="separator:ac3f173dc9dc2faa6c3483f1261e0644c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5977b475928f2947b875cd87d8831b6b"><td class="memItemLeft" align="right" valign="top"><a id="a5977b475928f2947b875cd87d8831b6b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_NAMEVALUE_NAMELEN_MAX</b>&#160;&#160;&#160;0x20</td></tr>
<tr class="separator:a5977b475928f2947b875cd87d8831b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f38c898ea9d4e45ea88ea614e6afdd3"><td class="memItemLeft" align="right" valign="top"><a id="a8f38c898ea9d4e45ea88ea614e6afdd3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a8f38c898ea9d4e45ea88ea614e6afdd3">PKTLAB_NAMEVALUE_VALUELEN_MIN</a>&#160;&#160;&#160;0x1</td></tr>
<tr class="memdesc:a8f38c898ea9d4e45ea88ea614e6afdd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum xdescr/dattr pair value length. <br /></td></tr>
<tr class="separator:a8f38c898ea9d4e45ea88ea614e6afdd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad347c623d2ff18a8a21e1ae95c91a71b"><td class="memItemLeft" align="right" valign="top"><a id="ad347c623d2ff18a8a21e1ae95c91a71b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#ad347c623d2ff18a8a21e1ae95c91a71b">PKTLAB_NAMEVALUE_VALUELEN_MAX</a>&#160;&#160;&#160;0x100</td></tr>
<tr class="memdesc:ad347c623d2ff18a8a21e1ae95c91a71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum xdescr/dattr pair value length. <br /></td></tr>
<tr class="separator:ad347c623d2ff18a8a21e1ae95c91a71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9988069d8fdd3f2a6dc7e10a36df6f1"><td class="memItemLeft" align="right" valign="top"><a id="aa9988069d8fdd3f2a6dc7e10a36df6f1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_CHANNELID_LEN_MIN</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:aa9988069d8fdd3f2a6dc7e10a36df6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6997ec9232c781c27f37a51d122d5c0b"><td class="memItemLeft" align="right" valign="top"><a id="a6997ec9232c781c27f37a51d122d5c0b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_CHANNELID_LEN_MAX</b>&#160;&#160;&#160;PKTLAB_SHA256_DIGEST_LEN</td></tr>
<tr class="separator:a6997ec9232c781c27f37a51d122d5c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948ec5cfc7bffdfa2c3b72aec628104a"><td class="memItemLeft" align="right" valign="top"><a id="a948ec5cfc7bffdfa2c3b72aec628104a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a948ec5cfc7bffdfa2c3b72aec628104a">PKTLAB_EBPF_INSTR_LEN</a>&#160;&#160;&#160;sizeof(struct <a class="el" href="structpktlab__ebpf__instr.html">pktlab_ebpf_instr</a>)</td></tr>
<tr class="memdesc:a948ec5cfc7bffdfa2c3b72aec628104a"><td class="mdescLeft">&#160;</td><td class="mdescRight">pktlab eBPF program unencoded instruction size in bytes. <br /></td></tr>
<tr class="separator:a948ec5cfc7bffdfa2c3b72aec628104a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35060daf825c6fe0dde14d5dd4bf2352"><td class="memItemLeft" align="right" valign="top"><a id="a35060daf825c6fe0dde14d5dd4bf2352"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a35060daf825c6fe0dde14d5dd4bf2352">PKTLAB_ENC_EBPF_INSTR_LEN</a>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:a35060daf825c6fe0dde14d5dd4bf2352"><td class="mdescLeft">&#160;</td><td class="mdescRight">pktlab eBPF program encoded instruction length in bytes. <br /></td></tr>
<tr class="separator:a35060daf825c6fe0dde14d5dd4bf2352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09e152de2b0a20c919687ad96fa6021"><td class="memItemLeft" align="right" valign="top"><a id="af09e152de2b0a20c919687ad96fa6021"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_CURPKT</b>&#160;&#160;&#160;(0x0)</td></tr>
<tr class="separator:af09e152de2b0a20c919687ad96fa6021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd875be551040100355854ffc6f7a8f9"><td class="memItemLeft" align="right" valign="top"><a id="afd875be551040100355854ffc6f7a8f9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_CURPKT_DATA</b>&#160;&#160;&#160;(PKTLAB_VMEMADDR_CURPKT)</td></tr>
<tr class="separator:afd875be551040100355854ffc6f7a8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f5cf52c16a3f22abfe50be01a36d9e"><td class="memItemLeft" align="right" valign="top"><a id="a74f5cf52c16a3f22abfe50be01a36d9e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_CURPKT_LEN</b>&#160;&#160;&#160;(PKTLAB_VMEMADDR_CURPKT+0x1000000)</td></tr>
<tr class="separator:a74f5cf52c16a3f22abfe50be01a36d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6674ea9a3215e1b9a6fb90ad2671063e"><td class="memItemLeft" align="right" valign="top"><a id="a6674ea9a3215e1b9a6fb90ad2671063e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_CURPKT_SKTID</b>&#160;&#160;&#160;(PKTLAB_VMEMADDR_CURPKT+0x1000010)</td></tr>
<tr class="separator:a6674ea9a3215e1b9a6fb90ad2671063e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ef61539fa9c78b3933c4f6fcc6620f"><td class="memItemLeft" align="right" valign="top"><a id="a87ef61539fa9c78b3933c4f6fcc6620f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_CURPKT_SL</b>&#160;&#160;&#160;(0x1000011)</td></tr>
<tr class="separator:a87ef61539fa9c78b3933c4f6fcc6620f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabc59601d33b566dc919975713e52b2"><td class="memItemLeft" align="right" valign="top"><a id="adabc59601d33b566dc919975713e52b2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_CURPKT_DATA_FL</b>&#160;&#160;&#160;(sizeof(uint8_t)*0x1000000)</td></tr>
<tr class="separator:adabc59601d33b566dc919975713e52b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00bd2e7d7d95ce3749a3ad9dc6b451f2"><td class="memItemLeft" align="right" valign="top"><a id="a00bd2e7d7d95ce3749a3ad9dc6b451f2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_CURPKT_LEN_FL</b>&#160;&#160;&#160;(sizeof(uint32_t))</td></tr>
<tr class="separator:a00bd2e7d7d95ce3749a3ad9dc6b451f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb5e9e04bf60e0f05fd987d1214ee36"><td class="memItemLeft" align="right" valign="top"><a id="a2cb5e9e04bf60e0f05fd987d1214ee36"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_CURPKT_SKTID_FL</b>&#160;&#160;&#160;(sizeof(uint8_t))</td></tr>
<tr class="separator:a2cb5e9e04bf60e0f05fd987d1214ee36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833fb0347a83d3329242e75ab96958ac"><td class="memItemLeft" align="right" valign="top"><a id="a833fb0347a83d3329242e75ab96958ac"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM</b>&#160;&#160;&#160;(0x10000000)</td></tr>
<tr class="separator:a833fb0347a83d3329242e75ab96958ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4533a959dbc33d7a148e4cca9dabd4d8"><td class="memItemLeft" align="right" valign="top"><a id="a4533a959dbc33d7a148e4cca9dabd4d8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_IP4NO</b>&#160;&#160;&#160;(PKTLAB_VMEMADDR_SYSPARAM)</td></tr>
<tr class="separator:a4533a959dbc33d7a148e4cca9dabd4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935e5e62e8196a21790fbae615573417"><td class="memItemLeft" align="right" valign="top"><a id="a935e5e62e8196a21790fbae615573417"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_IP6NO</b>&#160;&#160;&#160;(PKTLAB_VMEMADDR_SYSPARAM+0x1)</td></tr>
<tr class="separator:a935e5e62e8196a21790fbae615573417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9bce139fcdfdecf99b6ce092a4bcf13"><td class="memItemLeft" align="right" valign="top"><a id="ae9bce139fcdfdecf99b6ce092a4bcf13"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_TRANSSUP</b>&#160;&#160;&#160;(PKTLAB_VMEMADDR_SYSPARAM+0x2)</td></tr>
<tr class="separator:ae9bce139fcdfdecf99b6ce092a4bcf13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8feaa9cbb8b33e6498e631030636d5f0"><td class="memItemLeft" align="right" valign="top"><a id="a8feaa9cbb8b33e6498e631030636d5f0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_BUFMAXDUP</b>&#160;&#160;&#160;(PKTLAB_VMEMADDR_SYSPARAM+0x6)</td></tr>
<tr class="separator:a8feaa9cbb8b33e6498e631030636d5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5f28725b9227b05fd22411b8550009"><td class="memItemLeft" align="right" valign="top"><a id="acc5f28725b9227b05fd22411b8550009"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_IP4LS</b>&#160;&#160;&#160;(PKTLAB_VMEMADDR_SYSPARAM+0x100)</td></tr>
<tr class="separator:acc5f28725b9227b05fd22411b8550009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab257144244d0b49b083a71572b0f97a9"><td class="memItemLeft" align="right" valign="top"><a id="ab257144244d0b49b083a71572b0f97a9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_IP6LS</b>&#160;&#160;&#160;(PKTLAB_VMEMADDR_SYSPARAM+0x1000)</td></tr>
<tr class="separator:ab257144244d0b49b083a71572b0f97a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b1b9c14656abd4934bd572c6cded9e"><td class="memItemLeft" align="right" valign="top"><a id="a17b1b9c14656abd4934bd572c6cded9e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_TIME</b>&#160;&#160;&#160;(PKTLAB_VMEMADDR_SYSPARAM+0x10000)</td></tr>
<tr class="separator:a17b1b9c14656abd4934bd572c6cded9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f428f3cc03d2228dea9d555def83d74"><td class="memItemLeft" align="right" valign="top"><a id="a8f428f3cc03d2228dea9d555def83d74"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_BUFMAX</b>&#160;&#160;&#160;(PKTLAB_VMEMADDR_SYSPARAM+0x10010)</td></tr>
<tr class="separator:a8f428f3cc03d2228dea9d555def83d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9674d7379a31ed1c1054bc9276f6e81"><td class="memItemLeft" align="right" valign="top"><a id="af9674d7379a31ed1c1054bc9276f6e81"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_BUFUSED</b>&#160;&#160;&#160;(PKTLAB_VMEMADDR_SYSPARAM+0x10014)</td></tr>
<tr class="separator:af9674d7379a31ed1c1054bc9276f6e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6774c4ea2a75035d16c9d28a76216459"><td class="memItemLeft" align="right" valign="top"><a id="a6774c4ea2a75035d16c9d28a76216459"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_IP4DNSNO</b>&#160;&#160;&#160;(PKTLAB_VMEMADDR_SYSPARAM+0x20000)</td></tr>
<tr class="separator:a6774c4ea2a75035d16c9d28a76216459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28cb6314a7189ea3d065dc69697caf86"><td class="memItemLeft" align="right" valign="top"><a id="a28cb6314a7189ea3d065dc69697caf86"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_IP6DNSNO</b>&#160;&#160;&#160;(PKTLAB_VMEMADDR_SYSPARAM+0x20001)</td></tr>
<tr class="separator:a28cb6314a7189ea3d065dc69697caf86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d32e296270711471e5efdd5f8e60f8b"><td class="memItemLeft" align="right" valign="top"><a id="a5d32e296270711471e5efdd5f8e60f8b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_IP4DNSLS</b>&#160;&#160;&#160;(PKTLAB_VMEMADDR_SYSPARAM+0x20010)</td></tr>
<tr class="separator:a5d32e296270711471e5efdd5f8e60f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0a4405a3880531077991a0603fdced"><td class="memItemLeft" align="right" valign="top"><a id="acf0a4405a3880531077991a0603fdced"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_IP6DNSLS</b>&#160;&#160;&#160;(PKTLAB_VMEMADDR_SYSPARAM+0x20100)</td></tr>
<tr class="separator:acf0a4405a3880531077991a0603fdced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f93b2531acd055af0055adef027c6f"><td class="memItemLeft" align="right" valign="top"><a id="a58f93b2531acd055af0055adef027c6f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_IP4HDRMOD</b>&#160;&#160;&#160;(PKTLAB_VMEMADDR_SYSPARAM+0x20200)</td></tr>
<tr class="separator:a58f93b2531acd055af0055adef027c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0298740aa497ead134f925d219ea5151"><td class="memItemLeft" align="right" valign="top"><a id="a0298740aa497ead134f925d219ea5151"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_IP6HDRMOD</b>&#160;&#160;&#160;(PKTLAB_VMEMADDR_SYSPARAM+0x20210)</td></tr>
<tr class="separator:a0298740aa497ead134f925d219ea5151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2ec956586c1d348427d45e36662d6d"><td class="memItemLeft" align="right" valign="top"><a id="aae2ec956586c1d348427d45e36662d6d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_HOSTID</b>&#160;&#160;&#160;(PKTLAB_VMEMADDR_SYSPARAM+0x30000)</td></tr>
<tr class="separator:aae2ec956586c1d348427d45e36662d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c9822b1a0449f662803b5c58ba51f6"><td class="memItemLeft" align="right" valign="top"><a id="ae2c9822b1a0449f662803b5c58ba51f6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_LATLONG</b>&#160;&#160;&#160;(PKTLAB_VMEMADDR_SYSPARAM+0x30100)</td></tr>
<tr class="separator:ae2c9822b1a0449f662803b5c58ba51f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2571046f41172bc7901d75f9524e174b"><td class="memItemLeft" align="right" valign="top"><a id="a2571046f41172bc7901d75f9524e174b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_OSINFO</b>&#160;&#160;&#160;(PKTLAB_VMEMADDR_SYSPARAM+0x30200)</td></tr>
<tr class="separator:a2571046f41172bc7901d75f9524e174b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96051d8ea2d257e21df667a69ca167ae"><td class="memItemLeft" align="right" valign="top"><a id="a96051d8ea2d257e21df667a69ca167ae"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_SL</b>&#160;&#160;&#160;(0x30400)</td></tr>
<tr class="separator:a96051d8ea2d257e21df667a69ca167ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32f969d37b885befb13e936435bebd2"><td class="memItemLeft" align="right" valign="top"><a id="ad32f969d37b885befb13e936435bebd2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_IP4NO_FL</b>&#160;&#160;&#160;(sizeof(uint8_t))</td></tr>
<tr class="separator:ad32f969d37b885befb13e936435bebd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b7f8e066b80a04772a1a355055fb17"><td class="memItemLeft" align="right" valign="top"><a id="ac3b7f8e066b80a04772a1a355055fb17"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_IP6NO_FL</b>&#160;&#160;&#160;(sizeof(uint8_t))</td></tr>
<tr class="separator:ac3b7f8e066b80a04772a1a355055fb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c93a63f0a7df6c833e8383bf02d069"><td class="memItemLeft" align="right" valign="top"><a id="a76c93a63f0a7df6c833e8383bf02d069"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_TRANSSUP_FL</b>&#160;&#160;&#160;(sizeof(uint32_t))</td></tr>
<tr class="separator:a76c93a63f0a7df6c833e8383bf02d069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31927ee9c8d6ed81a90ef64bfb8fd0d0"><td class="memItemLeft" align="right" valign="top"><a id="a31927ee9c8d6ed81a90ef64bfb8fd0d0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_IP4LS_FL</b>&#160;&#160;&#160;(sizeof(uint8_t)*PKTLAB_IPV4_W_MSK_ADDR_LEN*0x100)</td></tr>
<tr class="separator:a31927ee9c8d6ed81a90ef64bfb8fd0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7df78be1462ff86926d8d505d76763"><td class="memItemLeft" align="right" valign="top"><a id="abd7df78be1462ff86926d8d505d76763"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_IP6LS_FL</b>&#160;&#160;&#160;(sizeof(uint8_t)*PKTLAB_IPV6_ADDR_LEN*0x100)</td></tr>
<tr class="separator:abd7df78be1462ff86926d8d505d76763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499d2bd00580a962595d23391dd95d95"><td class="memItemLeft" align="right" valign="top"><a id="a499d2bd00580a962595d23391dd95d95"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_TIME_FL</b>&#160;&#160;&#160;(sizeof(<a class="el" href="pktlab_8h.html#ae9515e3477c7b07d3cf086e3a3e463c1">pktlab_time_t</a>))</td></tr>
<tr class="separator:a499d2bd00580a962595d23391dd95d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5412b415bf3905409470385268eccd2"><td class="memItemLeft" align="right" valign="top"><a id="aa5412b415bf3905409470385268eccd2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_BUFMAX_FL</b>&#160;&#160;&#160;(sizeof(uint32_t))</td></tr>
<tr class="separator:aa5412b415bf3905409470385268eccd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903bb6a251095e48eb1fbaa673800411"><td class="memItemLeft" align="right" valign="top"><a id="a903bb6a251095e48eb1fbaa673800411"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_BUFUSED_FL</b>&#160;&#160;&#160;(sizeof(uint32_t))</td></tr>
<tr class="separator:a903bb6a251095e48eb1fbaa673800411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdee59d89976dd8abd55a8d6a04649bc"><td class="memItemLeft" align="right" valign="top"><a id="afdee59d89976dd8abd55a8d6a04649bc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_IP4DNSNO_FL</b>&#160;&#160;&#160;(sizeof(uint8_t))</td></tr>
<tr class="separator:afdee59d89976dd8abd55a8d6a04649bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359e959789ee3db01ed6288fce878059"><td class="memItemLeft" align="right" valign="top"><a id="a359e959789ee3db01ed6288fce878059"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_IP6DNSNO_FL</b>&#160;&#160;&#160;(sizeof(uint8_t))</td></tr>
<tr class="separator:a359e959789ee3db01ed6288fce878059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea7e0e9d0bf2be69be39dbae07d66ef"><td class="memItemLeft" align="right" valign="top"><a id="acea7e0e9d0bf2be69be39dbae07d66ef"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_IP4DNSLS_FL</b>&#160;&#160;&#160;(sizeof(uint8_t)*PKTLAB_IPV4_WO_MSK_ADDR_LEN*0x10)</td></tr>
<tr class="separator:acea7e0e9d0bf2be69be39dbae07d66ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c755bf61eac00acc2fcd81c8f40157"><td class="memItemLeft" align="right" valign="top"><a id="a43c755bf61eac00acc2fcd81c8f40157"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_IP6DNSLS_FL</b>&#160;&#160;&#160;(sizeof(uint8_t)*PKTLAB_IPV6_ADDR_LEN*0x10)</td></tr>
<tr class="separator:a43c755bf61eac00acc2fcd81c8f40157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c84d01d00f3443f3dc04382e591269"><td class="memItemLeft" align="right" valign="top"><a id="a21c84d01d00f3443f3dc04382e591269"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_IP4HDRMOD_FL</b>&#160;&#160;&#160;(sizeof(uint8_t)*0xC)</td></tr>
<tr class="separator:a21c84d01d00f3443f3dc04382e591269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70487c3dc2efe88ebaadd481e4680d9"><td class="memItemLeft" align="right" valign="top"><a id="af70487c3dc2efe88ebaadd481e4680d9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_IP6HDRMOD_FL</b>&#160;&#160;&#160;(sizeof(uint8_t)*0x8)</td></tr>
<tr class="separator:af70487c3dc2efe88ebaadd481e4680d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1cdf2c29b3e102aab178b698c67f9b"><td class="memItemLeft" align="right" valign="top"><a id="a2f1cdf2c29b3e102aab178b698c67f9b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_HOSTID_FL</b>&#160;&#160;&#160;(sizeof(char)*0x100)</td></tr>
<tr class="separator:a2f1cdf2c29b3e102aab178b698c67f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c01cc974699b97d7ff1c11d86c7eb3"><td class="memItemLeft" align="right" valign="top"><a id="a08c01cc974699b97d7ff1c11d86c7eb3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_LATLONG_FL</b>&#160;&#160;&#160;(sizeof(char)*0x40)</td></tr>
<tr class="separator:a08c01cc974699b97d7ff1c11d86c7eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51599bc4e34fdc63de9a302c528d382c"><td class="memItemLeft" align="right" valign="top"><a id="a51599bc4e34fdc63de9a302c528d382c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SYSPARAM_OSINFO_FL</b>&#160;&#160;&#160;(sizeof(char)*0x200)</td></tr>
<tr class="separator:a51599bc4e34fdc63de9a302c528d382c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d18a8e100e38dedf6e12797a5e2f7c"><td class="memItemLeft" align="right" valign="top"><a id="a75d18a8e100e38dedf6e12797a5e2f7c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SKTINFO</b>&#160;&#160;&#160;(0x20000000)</td></tr>
<tr class="separator:a75d18a8e100e38dedf6e12797a5e2f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c87537aafc69e594cfd78eb39402d15"><td class="memItemLeft" align="right" valign="top"><a id="a1c87537aafc69e594cfd78eb39402d15"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SKTINFO_BLKLEN</b>&#160;&#160;&#160;(0x400)</td></tr>
<tr class="separator:a1c87537aafc69e594cfd78eb39402d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618727c2a57b8d9d8748d2ae0b76af53"><td class="memItemLeft" align="right" valign="top"><a id="a618727c2a57b8d9d8748d2ae0b76af53"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SKTINFO_FAMILY</b>&#160;&#160;&#160;(0x0)</td></tr>
<tr class="separator:a618727c2a57b8d9d8748d2ae0b76af53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6643abb2783f9dc275527b34e8268fd6"><td class="memItemLeft" align="right" valign="top"><a id="a6643abb2783f9dc275527b34e8268fd6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SKTINFO_PROTO</b>&#160;&#160;&#160;(0x1)</td></tr>
<tr class="separator:a6643abb2783f9dc275527b34e8268fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab765236eb340cb3813fadb0d54f4764a"><td class="memItemLeft" align="right" valign="top"><a id="ab765236eb340cb3813fadb0d54f4764a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SKTINFO_STAT</b>&#160;&#160;&#160;(0x2)</td></tr>
<tr class="separator:ab765236eb340cb3813fadb0d54f4764a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e26c532a55a7aec1d4cf4e4b42331aa"><td class="memItemLeft" align="right" valign="top"><a id="a0e26c532a55a7aec1d4cf4e4b42331aa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SKTINFO_LADDR</b>&#160;&#160;&#160;(0x10)</td></tr>
<tr class="separator:a0e26c532a55a7aec1d4cf4e4b42331aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4045de1bbb91c1482e7319f088971bd8"><td class="memItemLeft" align="right" valign="top"><a id="a4045de1bbb91c1482e7319f088971bd8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SKTINFO_RADDR</b>&#160;&#160;&#160;(0x20)</td></tr>
<tr class="separator:a4045de1bbb91c1482e7319f088971bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5f11842e2fca299b04904a4add7119"><td class="memItemLeft" align="right" valign="top"><a id="a7e5f11842e2fca299b04904a4add7119"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SKTINFO_LPORT</b>&#160;&#160;&#160;(0x30)</td></tr>
<tr class="separator:a7e5f11842e2fca299b04904a4add7119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450e64ab7999c82fa0924c4aac3214bd"><td class="memItemLeft" align="right" valign="top"><a id="a450e64ab7999c82fa0924c4aac3214bd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SKTINFO_RPORT</b>&#160;&#160;&#160;(0x32)</td></tr>
<tr class="separator:a450e64ab7999c82fa0924c4aac3214bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3957e8a4db80149630e689a0be1f26c"><td class="memItemLeft" align="right" valign="top"><a id="ac3957e8a4db80149630e689a0be1f26c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SKTINFO_RBUFSZ</b>&#160;&#160;&#160;(0x40)</td></tr>
<tr class="separator:ac3957e8a4db80149630e689a0be1f26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0b375868217c6a4338a5e22d9c0904"><td class="memItemLeft" align="right" valign="top"><a id="a3f0b375868217c6a4338a5e22d9c0904"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SKTINFO_RBUFUSED</b>&#160;&#160;&#160;(0x44)</td></tr>
<tr class="separator:a3f0b375868217c6a4338a5e22d9c0904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a44d9712a461319c52a69c605aca246"><td class="memItemLeft" align="right" valign="top"><a id="a2a44d9712a461319c52a69c605aca246"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SKTINFO_DROPSTAT</b>&#160;&#160;&#160;(0x50)</td></tr>
<tr class="separator:a2a44d9712a461319c52a69c605aca246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab065cc1321a1ea51ac1ad54882b01bba"><td class="memItemLeft" align="right" valign="top"><a id="ab065cc1321a1ea51ac1ad54882b01bba"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SKTINFO_NSENDERR</b>&#160;&#160;&#160;(0x60)</td></tr>
<tr class="separator:ab065cc1321a1ea51ac1ad54882b01bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27094f512cbc6b2acba6994d692c47b4"><td class="memItemLeft" align="right" valign="top"><a id="a27094f512cbc6b2acba6994d692c47b4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SKTINFO_NSENDERRTAG</b>&#160;&#160;&#160;(0x61)</td></tr>
<tr class="separator:a27094f512cbc6b2acba6994d692c47b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6c1edebaadb220ada9960e6377e6de"><td class="memItemLeft" align="right" valign="top"><a id="a9c6c1edebaadb220ada9960e6377e6de"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SKTINFO_NOTIFMASK</b>&#160;&#160;&#160;(0x70)</td></tr>
<tr class="separator:a9c6c1edebaadb220ada9960e6377e6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f0371e71c88c2dc70ff0a32d746d53"><td class="memItemLeft" align="right" valign="top"><a id="a66f0371e71c88c2dc70ff0a32d746d53"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SKTINFO_CTFL</b>&#160;&#160;&#160;(0x100)</td></tr>
<tr class="separator:a66f0371e71c88c2dc70ff0a32d746d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d41a7c0ffb5fdca425bac0d4ef0093"><td class="memItemLeft" align="right" valign="top"><a id="ac9d41a7c0ffb5fdca425bac0d4ef0093"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SKTINFO_SL</b>&#160;&#160;&#160;(PKTLAB_VMEMADDR_SKTINFO_BLKLEN*0x100)</td></tr>
<tr class="separator:ac9d41a7c0ffb5fdca425bac0d4ef0093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9dd43466f1a99e51ac65aa07afdac2b"><td class="memItemLeft" align="right" valign="top"><a id="ae9dd43466f1a99e51ac65aa07afdac2b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SKTINFO_PROTO_FL</b>&#160;&#160;&#160;(sizeof(uint8_t))</td></tr>
<tr class="separator:ae9dd43466f1a99e51ac65aa07afdac2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c513d7e5855042b5b0d929eed18cd5"><td class="memItemLeft" align="right" valign="top"><a id="a22c513d7e5855042b5b0d929eed18cd5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SKTINFO_STAT_FL</b>&#160;&#160;&#160;(sizeof(int8_t))</td></tr>
<tr class="separator:a22c513d7e5855042b5b0d929eed18cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48183175a7bf77de104c6e882138251"><td class="memItemLeft" align="right" valign="top"><a id="aa48183175a7bf77de104c6e882138251"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SKTINFO_LADDR_FL</b>&#160;&#160;&#160;(sizeof(uint8_t)*PKTLAB_ADDRLEN_MAX)</td></tr>
<tr class="separator:aa48183175a7bf77de104c6e882138251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d8728302d537202ca99b9bc1da7cdb"><td class="memItemLeft" align="right" valign="top"><a id="a01d8728302d537202ca99b9bc1da7cdb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SKTINFO_RADDR_FL</b>&#160;&#160;&#160;(sizeof(uint8_t)*PKTLAB_ADDRLEN_MAX)</td></tr>
<tr class="separator:a01d8728302d537202ca99b9bc1da7cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1271a42060db3c5671e545384bb3e096"><td class="memItemLeft" align="right" valign="top"><a id="a1271a42060db3c5671e545384bb3e096"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SKTINFO_LPORT_FL</b>&#160;&#160;&#160;(sizeof(uint16_t))</td></tr>
<tr class="separator:a1271a42060db3c5671e545384bb3e096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f12abe0694b1131987361d101ea64b"><td class="memItemLeft" align="right" valign="top"><a id="ae9f12abe0694b1131987361d101ea64b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SKTINFO_RPORT_FL</b>&#160;&#160;&#160;(sizeof(uint16_t))</td></tr>
<tr class="separator:ae9f12abe0694b1131987361d101ea64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350ea4356b524fb10ba9e11a685f06c9"><td class="memItemLeft" align="right" valign="top"><a id="a350ea4356b524fb10ba9e11a685f06c9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SKTINFO_RBUFSZ_FL</b>&#160;&#160;&#160;(sizeof(uint32_t))</td></tr>
<tr class="separator:a350ea4356b524fb10ba9e11a685f06c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7a5fcc3afd1f5c5db5223cd77a0087"><td class="memItemLeft" align="right" valign="top"><a id="acc7a5fcc3afd1f5c5db5223cd77a0087"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SKTINFO_RBUFUSED_FL</b>&#160;&#160;&#160;(sizeof(uint32_t))</td></tr>
<tr class="separator:acc7a5fcc3afd1f5c5db5223cd77a0087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8cacc51b61d9c27895c06cccb756d2"><td class="memItemLeft" align="right" valign="top"><a id="a4c8cacc51b61d9c27895c06cccb756d2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SKTINFO_DROPSTAT_FL</b>&#160;&#160;&#160;(sizeof(uint32_t)*2)</td></tr>
<tr class="separator:a4c8cacc51b61d9c27895c06cccb756d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3e6db9fa7d9af81dd11b97a9e7ae8e"><td class="memItemLeft" align="right" valign="top"><a id="acf3e6db9fa7d9af81dd11b97a9e7ae8e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SKTINFO_NSENDERR_FL</b>&#160;&#160;&#160;(sizeof(int8_t))</td></tr>
<tr class="separator:acf3e6db9fa7d9af81dd11b97a9e7ae8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa042b30755076206754b5f82aad46bf4"><td class="memItemLeft" align="right" valign="top"><a id="aa042b30755076206754b5f82aad46bf4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SKTINFO_NSENDERRTAG_FL</b>&#160;&#160;&#160;(sizeof(uint16_t))</td></tr>
<tr class="separator:aa042b30755076206754b5f82aad46bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb34f4d0c126b1a2092150a461bc7ee"><td class="memItemLeft" align="right" valign="top"><a id="affb34f4d0c126b1a2092150a461bc7ee"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SKTINFO_NOTIFMASK_FL</b>&#160;&#160;&#160;(sizeof(uint16_t))</td></tr>
<tr class="separator:affb34f4d0c126b1a2092150a461bc7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af347efff0be09dccc3251ec802a5d576"><td class="memItemLeft" align="right" valign="top"><a id="af347efff0be09dccc3251ec802a5d576"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_SKTINFO_CTFL_FL</b>&#160;&#160;&#160;(sizeof(uint8_t)*0x80)</td></tr>
<tr class="separator:af347efff0be09dccc3251ec802a5d576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ff9458a0658b22c911cf2580c8f48d"><td class="memItemLeft" align="right" valign="top"><a id="a73ff9458a0658b22c911cf2580c8f48d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_NSENDTSTP</b>&#160;&#160;&#160;(0x30000000)</td></tr>
<tr class="separator:a73ff9458a0658b22c911cf2580c8f48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af6a850982d0a95fca38821ba881af1"><td class="memItemLeft" align="right" valign="top"><a id="a5af6a850982d0a95fca38821ba881af1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_MONSCRATCH</b>&#160;&#160;&#160;(0x40000000)</td></tr>
<tr class="separator:a5af6a850982d0a95fca38821ba881af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08228c7a798468853d9f72b70f94cc14"><td class="memItemLeft" align="right" valign="top"><a id="a08228c7a798468853d9f72b70f94cc14"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_MONPERSIST</b>&#160;&#160;&#160;(0x50000000)</td></tr>
<tr class="separator:a08228c7a798468853d9f72b70f94cc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5913d113b779a2019a86e17e811444"><td class="memItemLeft" align="right" valign="top"><a id="a1b5913d113b779a2019a86e17e811444"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_NSENDTSTP_SL</b>&#160;&#160;&#160;(sizeof(<a class="el" href="pktlab_8h.html#ae9515e3477c7b07d3cf086e3a3e463c1">pktlab_time_t</a>)*0x10000)</td></tr>
<tr class="separator:a1b5913d113b779a2019a86e17e811444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0425665bb5afec90535a49d1fd3d200"><td class="memItemLeft" align="right" valign="top"><a id="ac0425665bb5afec90535a49d1fd3d200"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_MONSCRATCH_SL</b>&#160;&#160;&#160;(sizeof(uint8_t)*0x10000000)</td></tr>
<tr class="separator:ac0425665bb5afec90535a49d1fd3d200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc934147b9ccca9a8e27a9c9e96e6105"><td class="memItemLeft" align="right" valign="top"><a id="abc934147b9ccca9a8e27a9c9e96e6105"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_VMEMADDR_MONPERSIST_SL</b>&#160;&#160;&#160;(sizeof(uint8_t)*0x10000000)</td></tr>
<tr class="separator:abc934147b9ccca9a8e27a9c9e96e6105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9911f4375681a0853e3496fcc27a746"><td class="memItemLeft" align="right" valign="top"><a id="af9911f4375681a0853e3496fcc27a746"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_RAW_SUP_BIT_INDX</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:af9911f4375681a0853e3496fcc27a746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be572655f5130286effef5cfdeff437"><td class="memItemLeft" align="right" valign="top"><a id="a4be572655f5130286effef5cfdeff437"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_TCP_SUP_BIT_INDX</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a4be572655f5130286effef5cfdeff437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6210f3f7936568e9050892a938191037"><td class="memItemLeft" align="right" valign="top"><a id="a6210f3f7936568e9050892a938191037"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_UDP_SUP_BIT_INDX</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a6210f3f7936568e9050892a938191037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e03bd69941627c258ca1af3aa42c52"><td class="memItemLeft" align="right" valign="top"><a id="a09e03bd69941627c258ca1af3aa42c52"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_NOTIFMASK_NTAG</b>&#160;&#160;&#160;(0x1 &lt;&lt; 1)</td></tr>
<tr class="separator:a09e03bd69941627c258ca1af3aa42c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4246636280098edd10b459f5a57fdef"><td class="memItemLeft" align="right" valign="top"><a id="aa4246636280098edd10b459f5a57fdef"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_NOTIFMASK_NSTAT</b>&#160;&#160;&#160;(0x1 &lt;&lt; 2)</td></tr>
<tr class="separator:aa4246636280098edd10b459f5a57fdef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e8e6acbfa1e9221946287157c7adb0"><td class="memItemLeft" align="right" valign="top"><a id="a33e8e6acbfa1e9221946287157c7adb0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_NOTIFMASK_NDATA</b>&#160;&#160;&#160;(0x1 &lt;&lt; 3)</td></tr>
<tr class="separator:a33e8e6acbfa1e9221946287157c7adb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0fd4aa2386123b1b471b6526842bcef"><td class="memItemLeft" align="right" valign="top"><a id="ab0fd4aa2386123b1b471b6526842bcef"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_NOTIFMASK_NDROP</b>&#160;&#160;&#160;(0x1 &lt;&lt; 4)</td></tr>
<tr class="separator:ab0fd4aa2386123b1b471b6526842bcef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06941c1b9ef8422674051b9df83db814"><td class="memItemLeft" align="right" valign="top"><a id="a06941c1b9ef8422674051b9df83db814"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_NOTIFMASK_NBLOCK</b>&#160;&#160;&#160;(0x1 &lt;&lt; 5)</td></tr>
<tr class="separator:a06941c1b9ef8422674051b9df83db814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368ebebcdadee9259283f312606c8203"><td class="memItemLeft" align="right" valign="top"><a id="a368ebebcdadee9259283f312606c8203"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_MREAD_MAX</b>&#160;&#160;&#160;UINT32_C(0x10000)</td></tr>
<tr class="separator:a368ebebcdadee9259283f312606c8203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3f98b7b44a0a4eb6997ad9960292b3"><td class="memItemLeft" align="right" valign="top"><a id="a1c3f98b7b44a0a4eb6997ad9960292b3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_NDATA_MAX</b>&#160;&#160;&#160;UINT32_C(0x10000)</td></tr>
<tr class="separator:a1c3f98b7b44a0a4eb6997ad9960292b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb65359f0d7ebfe825501b474a737d4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#abb65359f0d7ebfe825501b474a737d4d">PKTLAB_IP4_PROTO</a>&#160;&#160;&#160;0x4</td></tr>
<tr class="memdesc:abb65359f0d7ebfe825501b474a737d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined IPv4 protocol family value.  <a href="pktlab_8h.html#abb65359f0d7ebfe825501b474a737d4d">More...</a><br /></td></tr>
<tr class="separator:abb65359f0d7ebfe825501b474a737d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48014a171001ff1db03930d3b01e033c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a48014a171001ff1db03930d3b01e033c">PKTLAB_IP6_PROTO</a>&#160;&#160;&#160;0x6</td></tr>
<tr class="memdesc:a48014a171001ff1db03930d3b01e033c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined IPv6 protocol family value.  <a href="pktlab_8h.html#a48014a171001ff1db03930d3b01e033c">More...</a><br /></td></tr>
<tr class="separator:a48014a171001ff1db03930d3b01e033c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87646191b516860e3f4f23aacf35596c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a87646191b516860e3f4f23aacf35596c">PKTLAB_RAW_PROTO</a>&#160;&#160;&#160;0x00</td></tr>
<tr class="memdesc:a87646191b516860e3f4f23aacf35596c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined raw socket protocol value.  <a href="pktlab_8h.html#a87646191b516860e3f4f23aacf35596c">More...</a><br /></td></tr>
<tr class="separator:a87646191b516860e3f4f23aacf35596c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c0fac40037af8b910207a6ba40471a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a51c0fac40037af8b910207a6ba40471a">PKTLAB_TCP_PROTO</a>&#160;&#160;&#160;0x06</td></tr>
<tr class="memdesc:a51c0fac40037af8b910207a6ba40471a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined TCP socket protocol value.  <a href="pktlab_8h.html#a51c0fac40037af8b910207a6ba40471a">More...</a><br /></td></tr>
<tr class="separator:a51c0fac40037af8b910207a6ba40471a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58bba85c64bbbcbb38e5d72287560fba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a58bba85c64bbbcbb38e5d72287560fba">PKTLAB_UDP_PROTO</a>&#160;&#160;&#160;0x11</td></tr>
<tr class="memdesc:a58bba85c64bbbcbb38e5d72287560fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined UDP socket protocol value.  <a href="pktlab_8h.html#a58bba85c64bbbcbb38e5d72287560fba">More...</a><br /></td></tr>
<tr class="separator:a58bba85c64bbbcbb38e5d72287560fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3412d3e3fe79e6b706043cbdaf5ef28f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a3412d3e3fe79e6b706043cbdaf5ef28f">PKTLAB_NCTL_TCP_FIN</a>&#160;&#160;&#160;0x1</td></tr>
<tr class="memdesc:a3412d3e3fe79e6b706043cbdaf5ef28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined nctl TCP fin command.  <a href="pktlab_8h.html#a3412d3e3fe79e6b706043cbdaf5ef28f">More...</a><br /></td></tr>
<tr class="separator:a3412d3e3fe79e6b706043cbdaf5ef28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da7feb81ef77f85c2ff6d1e8e89c2d0"><td class="memItemLeft" align="right" valign="top"><a id="a9da7feb81ef77f85c2ff6d1e8e89c2d0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a9da7feb81ef77f85c2ff6d1e8e89c2d0">PKTLAB_TCPEV_ESTABLISHED</a>&#160;&#160;&#160;0x0</td></tr>
<tr class="memdesc:a9da7feb81ef77f85c2ff6d1e8e89c2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined nstat code value - TCP connection established event. <br /></td></tr>
<tr class="separator:a9da7feb81ef77f85c2ff6d1e8e89c2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b169811f652a6afe085140f0d97382e"><td class="memItemLeft" align="right" valign="top"><a id="a1b169811f652a6afe085140f0d97382e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a1b169811f652a6afe085140f0d97382e">PKTLAB_TCPEV_RESET</a>&#160;&#160;&#160;0x1</td></tr>
<tr class="memdesc:a1b169811f652a6afe085140f0d97382e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined nstat code value - TCP connection reset event. <br /></td></tr>
<tr class="separator:a1b169811f652a6afe085140f0d97382e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c18bc2698e3eca252c8f852c0c2e455"><td class="memItemLeft" align="right" valign="top"><a id="a6c18bc2698e3eca252c8f852c0c2e455"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a6c18bc2698e3eca252c8f852c0c2e455">PKTLAB_TCPEV_TIMEOUT</a>&#160;&#160;&#160;0x2</td></tr>
<tr class="memdesc:a6c18bc2698e3eca252c8f852c0c2e455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined nstat code value - TCP connection timeout event. <br /></td></tr>
<tr class="separator:a6c18bc2698e3eca252c8f852c0c2e455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64048b15d5e5528303aee506927894df"><td class="memItemLeft" align="right" valign="top"><a id="a64048b15d5e5528303aee506927894df"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a64048b15d5e5528303aee506927894df">PKTLAB_TCPEV_PEERCLOSED</a>&#160;&#160;&#160;0x3</td></tr>
<tr class="memdesc:a64048b15d5e5528303aee506927894df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined nstat code value - TCP connection peer closed event. <br /></td></tr>
<tr class="separator:a64048b15d5e5528303aee506927894df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330d81a34c8b393e82743a32144ac9fd"><td class="memItemLeft" align="right" valign="top"><a id="a330d81a34c8b393e82743a32144ac9fd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a330d81a34c8b393e82743a32144ac9fd">PKTLAB_TCPEV_UNKNOWN</a>&#160;&#160;&#160;0xFF</td></tr>
<tr class="memdesc:a330d81a34c8b393e82743a32144ac9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined nstat code value - TCP connection unknown event. <br /></td></tr>
<tr class="separator:a330d81a34c8b393e82743a32144ac9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefdd8e208c54f300ae1e465c834f2752"><td class="memItemLeft" align="right" valign="top"><a id="aefdd8e208c54f300ae1e465c834f2752"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#aefdd8e208c54f300ae1e465c834f2752">PKTLAB_CDATA_HINT_FILTER</a>&#160;&#160;&#160;&quot;filter&quot;</td></tr>
<tr class="memdesc:aefdd8e208c54f300ae1e465c834f2752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined cdata hint value - filter program. <br /></td></tr>
<tr class="separator:aefdd8e208c54f300ae1e465c834f2752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220777491c2fc67e6602968552b5cc83"><td class="memItemLeft" align="right" valign="top"><a id="a220777491c2fc67e6602968552b5cc83"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a220777491c2fc67e6602968552b5cc83">PKTLAB_CDATA_HINT_MONITOR</a>&#160;&#160;&#160;&quot;monitor&quot;</td></tr>
<tr class="memdesc:a220777491c2fc67e6602968552b5cc83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined cdata hint value - monitor program. <br /></td></tr>
<tr class="separator:a220777491c2fc67e6602968552b5cc83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19bbee5a363f3e9a4280dba5d4464ad1"><td class="memItemLeft" align="right" valign="top"><a id="a19bbee5a363f3e9a4280dba5d4464ad1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a19bbee5a363f3e9a4280dba5d4464ad1">PKTLAB_HLEN</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:a19bbee5a363f3e9a4280dba5d4464ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encoded pktlab message header length. <br /></td></tr>
<tr class="separator:a19bbee5a363f3e9a4280dba5d4464ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8f611d682fe0249a916677ab003063"><td class="memItemLeft" align="right" valign="top"><a id="abf8f611d682fe0249a916677ab003063"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#abf8f611d682fe0249a916677ab003063">PKTLAB_ENCODE_IOVCNT</a>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:abf8f611d682fe0249a916677ab003063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum required iovec elements for <a class="el" href="pktlab_8h.html#a7992448d296c83dfb78ccece719687f8" title="Encode pktlab message.">pktlab_encode_message()</a>. <br /></td></tr>
<tr class="separator:abf8f611d682fe0249a916677ab003063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee680e7feb79ba834108e9bf0ae78d1"><td class="memItemLeft" align="right" valign="top"><a id="a4ee680e7feb79ba834108e9bf0ae78d1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a4ee680e7feb79ba834108e9bf0ae78d1">PKTLAB_ENCODE_BUFSZ</a>&#160;&#160;&#160;(<a class="el" href="pktlab_8h.html#a19bbee5a363f3e9a4280dba5d4464ad1">PKTLAB_HLEN</a>+32)</td></tr>
<tr class="memdesc:a4ee680e7feb79ba834108e9bf0ae78d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum required buffer size for <a class="el" href="pktlab_8h.html#a7992448d296c83dfb78ccece719687f8" title="Encode pktlab message.">pktlab_encode_message()</a>. <br /></td></tr>
<tr class="separator:a4ee680e7feb79ba834108e9bf0ae78d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06a8648c5bd937e965b2ad64e020b48"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#ac06a8648c5bd937e965b2ad64e020b48">PKTLAB_PUBLICKEY_LEN</a>&#160;&#160;&#160;32</td></tr>
<tr class="memdesc:ac06a8648c5bd937e965b2ad64e020b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw public key length for pktlab keys in bytes.  <a href="pktlab_8h.html#ac06a8648c5bd937e965b2ad64e020b48">More...</a><br /></td></tr>
<tr class="separator:ac06a8648c5bd937e965b2ad64e020b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c03ad73951df5c59a4c31afcc90237"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a05c03ad73951df5c59a4c31afcc90237">PKTLAB_PRIVATEKEY_LEN</a>&#160;&#160;&#160;32</td></tr>
<tr class="memdesc:a05c03ad73951df5c59a4c31afcc90237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw private key length for pktlab keys in bytes.  <a href="pktlab_8h.html#a05c03ad73951df5c59a4c31afcc90237">More...</a><br /></td></tr>
<tr class="separator:a05c03ad73951df5c59a4c31afcc90237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49742fc9f57d4109040fdf1a011de7d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#ab49742fc9f57d4109040fdf1a011de7d">PKTLAB_KEYID_LEN</a>&#160;&#160;&#160;PKTLAB_SHA256_DIGEST_LEN</td></tr>
<tr class="memdesc:ab49742fc9f57d4109040fdf1a011de7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key identifier length for pktlab keys in bytes.  <a href="pktlab_8h.html#ab49742fc9f57d4109040fdf1a011de7d">More...</a><br /></td></tr>
<tr class="separator:ab49742fc9f57d4109040fdf1a011de7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58765601952334f2a1df7eda84936566"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a58765601952334f2a1df7eda84936566">PKTLAB_SIGNATURE_LEN</a>&#160;&#160;&#160;PKTLAB_ED25519_SIG_LEN</td></tr>
<tr class="memdesc:a58765601952334f2a1df7eda84936566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw signature length for pktlab keys in bytes.  <a href="pktlab_8h.html#a58765601952334f2a1df7eda84936566">More...</a><br /></td></tr>
<tr class="separator:a58765601952334f2a1df7eda84936566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af670b820e48b24237b89be83c7b4d3ff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#af670b820e48b24237b89be83c7b4d3ff">PKTLAB_FILTER_DIGEST_LEN</a>&#160;&#160;&#160;PKTLAB_SHA256_DIGEST_LEN</td></tr>
<tr class="memdesc:af670b820e48b24237b89be83c7b4d3ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">pktlab filter program digest length.  <a href="pktlab_8h.html#af670b820e48b24237b89be83c7b4d3ff">More...</a><br /></td></tr>
<tr class="separator:af670b820e48b24237b89be83c7b4d3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab336cc7b06ec9ed6b6db7c64fb0ffec0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#ab336cc7b06ec9ed6b6db7c64fb0ffec0">PKTLAB_MONITOR_DIGEST_LEN</a>&#160;&#160;&#160;PKTLAB_SHA256_DIGEST_LEN</td></tr>
<tr class="memdesc:ab336cc7b06ec9ed6b6db7c64fb0ffec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">pktlab monitor program digest length.  <a href="pktlab_8h.html#ab336cc7b06ec9ed6b6db7c64fb0ffec0">More...</a><br /></td></tr>
<tr class="separator:ab336cc7b06ec9ed6b6db7c64fb0ffec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab4f78200c37f43cc8ca0900fadce03"><td class="memItemLeft" align="right" valign="top"><a id="acab4f78200c37f43cc8ca0900fadce03"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_EXT_CERT_INFO</b>&#160;&#160;&#160;&quot;1.2.3.1&quot;</td></tr>
<tr class="separator:acab4f78200c37f43cc8ca0900fadce03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77a0fc8126a91bb67fe621d6bdd68a5"><td class="memItemLeft" align="right" valign="top"><a id="aa77a0fc8126a91bb67fe621d6bdd68a5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_EXT_CERT_LIMIT</b>&#160;&#160;&#160;&quot;1.2.3.3&quot;</td></tr>
<tr class="separator:aa77a0fc8126a91bb67fe621d6bdd68a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ac2804243ac22fd0d0102487240dbd"><td class="memItemLeft" align="right" valign="top"><a id="a76ac2804243ac22fd0d0102487240dbd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_CERTTYPE_STR_SUBCMD</b>&#160;&#160;&#160;&quot;subcmd&quot;</td></tr>
<tr class="separator:a76ac2804243ac22fd0d0102487240dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb96c585d602229670077855b725a5ac"><td class="memItemLeft" align="right" valign="top"><a id="aeb96c585d602229670077855b725a5ac"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_CERTTYPE_STR_PUBCMD</b>&#160;&#160;&#160;&quot;pubcmd&quot;</td></tr>
<tr class="separator:aeb96c585d602229670077855b725a5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7e8f3b4b55a38adb6ef58bce180266"><td class="memItemLeft" align="right" valign="top"><a id="a7c7e8f3b4b55a38adb6ef58bce180266"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_CERTTYPE_STR_EXPPRIV</b>&#160;&#160;&#160;&quot;exppriv&quot;</td></tr>
<tr class="separator:a7c7e8f3b4b55a38adb6ef58bce180266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ecc94a45223bf010a55084df8c8bab7"><td class="memItemLeft" align="right" valign="top"><a id="a6ecc94a45223bf010a55084df8c8bab7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_CERTTYPE_STR_DELPRIV</b>&#160;&#160;&#160;&quot;delpriv&quot;</td></tr>
<tr class="separator:a6ecc94a45223bf010a55084df8c8bab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451a37cf76c9fb0bfd9a5903b3521f5e"><td class="memItemLeft" align="right" valign="top"><a id="a451a37cf76c9fb0bfd9a5903b3521f5e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_CERTTYPE_STR_AGENT</b>&#160;&#160;&#160;&quot;agent&quot;</td></tr>
<tr class="separator:a451a37cf76c9fb0bfd9a5903b3521f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9fff6b760db9a0a9770009a2325e935"><td class="memItemLeft" align="right" valign="top"><a id="aa9fff6b760db9a0a9770009a2325e935"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKTLAB_CERTTYPE_STR_UNKNOWN</b>&#160;&#160;&#160;&quot;unknown&quot;</td></tr>
<tr class="separator:aa9fff6b760db9a0a9770009a2325e935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01779f084ae422e1240d95da1a3444ed"><td class="memItemLeft" align="right" valign="top"><a id="a01779f084ae422e1240d95da1a3444ed"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_get16n</b>&#160;&#160;&#160;pktlab_get16b</td></tr>
<tr class="separator:a01779f084ae422e1240d95da1a3444ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423f0c585eae18d0f4e093332474aa28"><td class="memItemLeft" align="right" valign="top"><a id="a423f0c585eae18d0f4e093332474aa28"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_get24n</b>&#160;&#160;&#160;pktlab_get24b</td></tr>
<tr class="separator:a423f0c585eae18d0f4e093332474aa28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140440d7c69036f4bc93f874a482ae64"><td class="memItemLeft" align="right" valign="top"><a id="a140440d7c69036f4bc93f874a482ae64"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_get32n</b>&#160;&#160;&#160;pktlab_get32b</td></tr>
<tr class="separator:a140440d7c69036f4bc93f874a482ae64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08d47e433bc9a38ab7189ba7be12656"><td class="memItemLeft" align="right" valign="top"><a id="ab08d47e433bc9a38ab7189ba7be12656"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_get64n</b>&#160;&#160;&#160;pktlab_get64b</td></tr>
<tr class="separator:ab08d47e433bc9a38ab7189ba7be12656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc327bae588558a4bbc234b47afb7c2"><td class="memItemLeft" align="right" valign="top"><a id="affc327bae588558a4bbc234b47afb7c2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_set16n</b>&#160;&#160;&#160;pktlab_set16b</td></tr>
<tr class="separator:affc327bae588558a4bbc234b47afb7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89ee9d79a19f652bd6a1ec925b8ebf7"><td class="memItemLeft" align="right" valign="top"><a id="ae89ee9d79a19f652bd6a1ec925b8ebf7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_set24n</b>&#160;&#160;&#160;pktlab_set24b</td></tr>
<tr class="separator:ae89ee9d79a19f652bd6a1ec925b8ebf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb536200bc8fd4ac9a9e2bf74990534"><td class="memItemLeft" align="right" valign="top"><a id="a1fb536200bc8fd4ac9a9e2bf74990534"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_set32n</b>&#160;&#160;&#160;pktlab_set32b</td></tr>
<tr class="separator:a1fb536200bc8fd4ac9a9e2bf74990534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95378a8fe4d5478e3ae66310bd38f87"><td class="memItemLeft" align="right" valign="top"><a id="ac95378a8fe4d5478e3ae66310bd38f87"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_set64n</b>&#160;&#160;&#160;pktlab_set64b</td></tr>
<tr class="separator:ac95378a8fe4d5478e3ae66310bd38f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae9515e3477c7b07d3cf086e3a3e463c1"><td class="memItemLeft" align="right" valign="top">typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#ae9515e3477c7b07d3cf086e3a3e463c1">pktlab_time_t</a></td></tr>
<tr class="memdesc:ae9515e3477c7b07d3cf086e3a3e463c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable type for pktlab time.  <a href="pktlab_8h.html#ae9515e3477c7b07d3cf086e3a3e463c1">More...</a><br /></td></tr>
<tr class="separator:ae9515e3477c7b07d3cf086e3a3e463c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abedde733e174b0d37429617dce643768"><td class="memItemLeft" align="right" valign="top"><a id="abedde733e174b0d37429617dce643768"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_vmem_reader_t</b>) (const struct <a class="el" href="structpktlab__vmem__region.html">pktlab_vmem_region</a> *restrict rgn, uint_fast32_t off, uint_fast32_t len, void *restrict dst)</td></tr>
<tr class="separator:abedde733e174b0d37429617dce643768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3aad330f559cf733ce9df91908dfba"><td class="memItemLeft" align="right" valign="top"><a id="a4a3aad330f559cf733ce9df91908dfba"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_vmem_writer_t</b>) (const struct <a class="el" href="structpktlab__vmem__region.html">pktlab_vmem_region</a> *restrict rgn, uint_fast32_t off, uint_fast32_t len, const void *restrict src)</td></tr>
<tr class="separator:a4a3aad330f559cf733ce9df91908dfba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89fe04b2d2e1cd53344b3d0e8b0c7789"><td class="memItemLeft" align="right" valign="top">typedef ssize_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a89fe04b2d2e1cd53344b3d0e8b0c7789">pktlab_read_t</a>) (void *aux, void *buf, size_t buflen)</td></tr>
<tr class="memdesc:a89fe04b2d2e1cd53344b3d0e8b0c7789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer type for reader read function.  <a href="pktlab_8h.html#a89fe04b2d2e1cd53344b3d0e8b0c7789">More...</a><br /></td></tr>
<tr class="separator:a89fe04b2d2e1cd53344b3d0e8b0c7789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f306929ea68ec41259ed659a72134b"><td class="memItemLeft" align="right" valign="top">typedef ssize_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a53f306929ea68ec41259ed659a72134b">pktlab_write_t</a>) (void *aux, const void *buf, size_t nbyte)</td></tr>
<tr class="memdesc:a53f306929ea68ec41259ed659a72134b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer type for writer write function.  <a href="pktlab_8h.html#a53f306929ea68ec41259ed659a72134b">More...</a><br /></td></tr>
<tr class="separator:a53f306929ea68ec41259ed659a72134b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ad49ead2ad49df1700b526ccd019854b4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#ad49ead2ad49df1700b526ccd019854b4">pktlab_prog_type</a> { <a class="el" href="pktlab_8h.html#ad49ead2ad49df1700b526ccd019854b4aa29cf4ad46e78fe5321871fcd688ac72">PKTLAB_EBPF</a> = 0x0, 
<a class="el" href="pktlab_8h.html#ad49ead2ad49df1700b526ccd019854b4a655b6ea8f28516c086aa56775644d2d1">PKTLAB_WASM</a> = 0x1
 }</td></tr>
<tr class="memdesc:ad49ead2ad49df1700b526ccd019854b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">pktlab defined program types.  <a href="pktlab_8h.html#ad49ead2ad49df1700b526ccd019854b4">More...</a><br /></td></tr>
<tr class="separator:ad49ead2ad49df1700b526ccd019854b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd81e57a11c1eb72355c39c6106d166"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a1fd81e57a11c1eb72355c39c6106d166">pktlab_uri_type</a> { <a class="el" href="pktlab_8h.html#a1fd81e57a11c1eb72355c39c6106d166a4ea0fb6aec1a9b390d67b4f039de2a02">EXP_URI_TYPE</a> = 0, 
<a class="el" href="pktlab_8h.html#a1fd81e57a11c1eb72355c39c6106d166ade2c3206bfb5d7cb0ca959a22712a385">BROKER_URI_TYPE</a> = 1, 
<a class="el" href="pktlab_8h.html#a1fd81e57a11c1eb72355c39c6106d166aadf39f2e8a566cc3f6124a8a37f8515f">MALFORMED_URI_TYPE</a> = -1
 }</td></tr>
<tr class="memdesc:a1fd81e57a11c1eb72355c39c6106d166"><td class="mdescLeft">&#160;</td><td class="mdescRight">pktlab defined URI types.  <a href="pktlab_8h.html#a1fd81e57a11c1eb72355c39c6106d166">More...</a><br /></td></tr>
<tr class="separator:a1fd81e57a11c1eb72355c39c6106d166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9212ce549407769493906edc2d86b5e4"><td class="memItemLeft" align="right" valign="top"><a id="a9212ce549407769493906edc2d86b5e4"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_rawhdr_info</b> { <b>PKTLAB_RAWHDR_NOCHG</b> = 0, 
<b>PKTLAB_RAWHDR_CHG</b> = 1, 
<b>PKTLAB_RAWHDR_0FILL</b> = 2
 }</td></tr>
<tr class="separator:a9212ce549407769493906edc2d86b5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ad8dec6b069d1d39d95d4afa9eb97f"><td class="memItemLeft" align="right" valign="top"><a id="ab3ad8dec6b069d1d39d95d4afa9eb97f"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_socket_state</b> { <br />
&#160;&#160;<b>PKTLAB_SKTST_FREE</b> = 0, 
<b>PKTLAB_SKTST_OPENING</b> = 1, 
<b>PKTLAB_SKTST_OPEN</b> = 2, 
<b>PKTLAB_SKTST_EOF</b> = 3, 
<br />
&#160;&#160;<b>PKTLAB_SKTST_WFIN</b> = 4, 
<b>PKTLAB_SKTST_END</b> = 5, 
<b>PKTLAB_SKTST_REFUSED</b> = -1, 
<b>PKTLAB_SKTST_RESET</b> = -2, 
<br />
&#160;&#160;<b>PKTLAB_SKTST_TIMEDOUT</b> = -3, 
<b>PKTLAB_SKTST_UNREACH</b> = -4, 
<b>PKTLAB_SKTST_UNKFAULT</b> = -128
<br />
 }</td></tr>
<tr class="separator:ab3ad8dec6b069d1d39d95d4afa9eb97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e1ff2fcea22c76df5d49813ad4331c"><td class="memItemLeft" align="right" valign="top"><a id="a11e1ff2fcea22c76df5d49813ad4331c"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_nsend_err</b> { <br />
&#160;&#160;<b>PKTLAB_NSEND_SUCCESS</b> = 0, 
<b>PKTLAB_NSEND_NORES</b> = 1, 
<b>PKTLAB_NSEND_BADPKT</b> = 2, 
<b>PKTLAB_NSEND_TIMEDOUT</b> = 3, 
<br />
&#160;&#160;<b>PKTLAB_NSEND_RESET</b> = 4, 
<b>PKTLAB_NSEND_UNREACH</b> = 5, 
<b>PKTLAB_NSEND_WFIN</b> = 6, 
<b>PKTLAB_NSEND_UNKFAULT</b> = 127
<br />
 }</td></tr>
<tr class="separator:a11e1ff2fcea22c76df5d49813ad4331c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7e374911bec712eb0ae2b4b0ae950a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a2e7e374911bec712eb0ae2b4b0ae950a">pktlab_message_type</a> { <br />
&#160;&#160;<b>PKTLAB_UNDEF_MESSAGE</b> = 0x00, 
<b>PKTLAB_CDATA_MESSAGE</b> = 0x20, 
<b>PKTLAB_START_MESSAGE</b> = 0x21, 
<b>PKTLAB_END_MESSAGE</b> = 0x22, 
<br />
&#160;&#160;<b>PKTLAB_YIELD_MESSAGE</b> = 0X23, 
<b>PKTLAB_CONT_MESSAGE</b> = 0X24, 
<b>PKTLAB_MREAD_MESSAGE</b> = 0x28, 
<b>PKTLAB_MWRITE_MESSAGE</b> = 0x29, 
<br />
&#160;&#160;<b>PKTLAB_NOPEN_MESSAGE</b> = 0x2A, 
<b>PKTLAB_NCLOSE_MESSAGE</b> = 0x2B, 
<b>PKTLAB_NSEND_MESSAGE</b> = 0x2C, 
<b>PKTLAB_NCAP_MESSAGE</b> = 0x2D, 
<br />
&#160;&#160;<b>PKTLAB_NCTL_MESSAGE</b> = 0x2E, 
<b>PKTLAB_XCERT_MESSAGE</b> = 0x30, 
<b>PKTLAB_XPUB_MESSAGE</b> = 0x31, 
<b>PKTLAB_XSUB_MESSAGE</b> = 0x38, 
<br />
&#160;&#160;<b>PKTLAB_RESULT_MESSAGE</b> = 0x40, 
<b>PKTLAB_MDATA_MESSAGE</b> = 0x41, 
<b>PKTLAB_NTAG_MESSAGE</b> = 0x60, 
<b>PKTLAB_NSTAT_MESSAGE</b> = 0x61, 
<br />
&#160;&#160;<b>PKTLAB_NDATA_MESSAGE</b> = 0x62, 
<b>PKTLAB_NDROP_MESSAGE</b> = 0x63, 
<b>PKTLAB_NBLOCK_MESSAGE</b> = 0x64, 
<b>PKTLAB_SUSPD_MESSAGE</b> = 0x68, 
<br />
&#160;&#160;<b>PKTLAB_RESUMD_MESSAGE</b> = 0x69, 
<b>PKTLAB_XNOTIFY_MESSAGE</b> = 0x70, 
<b>PKTLAB_XREG_MESSAGE</b> = 0x80
<br />
 }</td></tr>
<tr class="memdesc:a2e7e374911bec712eb0ae2b4b0ae950a"><td class="mdescLeft">&#160;</td><td class="mdescRight">pktlab defined message types.  <a href="pktlab_8h.html#a2e7e374911bec712eb0ae2b4b0ae950a">More...</a><br /></td></tr>
<tr class="separator:a2e7e374911bec712eb0ae2b4b0ae950a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1908d576437c692d3be8071c75cab9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#abd1908d576437c692d3be8071c75cab9">pktlab_status</a> { <br />
&#160;&#160;<b>PKTLAB_SUCCESS</b> = 0, 
<b>PKTLAB_ECTLBADMSG</b> = 0x10, 
<b>PKTLAB_ECTLNOTSUP</b> = 0x11, 
<b>PKTLAB_ECTLMONREJ</b> = 0x12, 
<br />
&#160;&#160;<b>PKTLAB_ECTLMONUKN</b> = 0x13, 
<b>PKTLAB_ECRTBADHDAT</b> = 0x20, 
<b>PKTLAB_ECRTNOHDAT</b> = 0x21, 
<b>PKTLAB_ECRTBADFRM</b> = 0x22, 
<br />
&#160;&#160;<b>PKTLAB_ECRTNOSPACE</b> = 0x23, 
<b>PKTLAB_ECRTBADHINT</b> = 0x24, 
<b>PKTLAB_ESYSNOBUFS</b> = 0x30, 
<b>PKTLAB_ESYSNOPERM</b> = 0x31, 
<br />
&#160;&#160;<b>PKTLAB_ESKTINUSE</b> = 0x32, 
<b>PKTLAB_ESKTNOTOPEN</b> = 0x33, 
<b>PKTLAB_ESKTNOPRFAM</b> = 0x34, 
<b>PKTLAB_ESKTNOPROTO</b> = 0x35, 
<br />
&#160;&#160;<b>PKTLAB_ESKTNOADDR</b> = 0x36, 
<b>PKTLAB_ESKTNOMATCH</b> = 0x37, 
<b>PKTLAB_ESKTBADFILT</b> = 0x38, 
<b>PKTLAB_ESKTPKTDENY</b> = 0x39, 
<br />
&#160;&#160;<b>PKTLAB_ESKTOPNDENY</b> = 0x3A, 
<b>PKTLAB_ETCPNOPORT</b> = 0x40, 
<b>PKTLAB_EPKTNOTSENT</b> = 0x41, 
<b>PKTLAB_EUDPNOPORT</b> = 0x42, 
<br />
&#160;&#160;<b>PKTLAB_EPKTTRUNC</b> = 0x43, 
<b>PKTLAB_ENORES</b> = 0x44, 
<b>PKTLAB_EMEMBADADR</b> = 0x48, 
<b>PKTLAB_EPUBBADCHL</b> = 0x50, 
<br />
&#160;&#160;<b>PKTLAB_EPUBBADCHN</b> = 0x51, 
<b>PKTLAB_EPUBBADADDR</b> = 0x52, 
<b>PKTLAB_EPUBBADPR</b> = 0x53, 
<b>PKTLAB_EPUBBADXD</b> = 0x54, 
<br />
&#160;&#160;<b>PKTLAB_ESUBBADCHL</b> = 0x60, 
<b>PKTLAB_ESUBBADCHN</b> = 0x61, 
<b>PKTLAB_ESUBBADDA</b> = 0x62, 
<b>PKTLAB_EUNKFAULT</b> = 0xFFFF
<br />
 }</td></tr>
<tr class="memdesc:abd1908d576437c692d3be8071c75cab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">pktlab defined errid values.  <a href="pktlab_8h.html#abd1908d576437c692d3be8071c75cab9">More...</a><br /></td></tr>
<tr class="separator:abd1908d576437c692d3be8071c75cab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9eddf82925b672a4f40f4428e151be0"><td class="memItemLeft" align="right" valign="top"><a id="ac9eddf82925b672a4f40f4428e151be0"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#ac9eddf82925b672a4f40f4428e151be0">pktlab_cert_type</a> { <br />
&#160;&#160;<b>PKTLAB_CERT_SUBCMD</b> = 0, 
<b>PKTLAB_CERT_PUBCMD</b> = 1, 
<b>PKTLAB_CERT_EXPPRIV</b> = 2, 
<b>PKTLAB_CERT_DELPRIV</b> = 3, 
<br />
&#160;&#160;<b>PKTLAB_CERT_AGENT</b> = 4, 
<b>PKTLAB_CERT_UNKNOWN</b> = 127
<br />
 }</td></tr>
<tr class="memdesc:ac9eddf82925b672a4f40f4428e151be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">pktlab defined certificate types. <br /></td></tr>
<tr class="separator:ac9eddf82925b672a4f40f4428e151be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c7c7e8f7beb03cd5120724814e4ba2"><td class="memItemLeft" align="right" valign="top"><a id="af5c7c7e8f7beb03cd5120724814e4ba2"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_del_type</b> { <b>PKTLAB_DEL_TYPE_EXPPRIV</b> = 0x1, 
<b>PKTLAB_DEL_TYPE_REPPRIV</b> = 0x2, 
<b>PKTLAB_DEL_TYPE_NOT_PRSENT</b> = 0x0
 }</td></tr>
<tr class="separator:af5c7c7e8f7beb03cd5120724814e4ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8c7b5f58a51788e8ee06ca5a1490f4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#abd8c7b5f58a51788e8ee06ca5a1490f4">pktlab_decode_rst</a> { <br />
&#160;&#160;<a class="el" href="pktlab_8h.html#abd8c7b5f58a51788e8ee06ca5a1490f4aca9c9b857b8348f67347b7d3eb35fa4b">PKTLAB_DECODE_SUCCESS</a> = 0, 
<a class="el" href="pktlab_8h.html#abd8c7b5f58a51788e8ee06ca5a1490f4a49e02e998e8cb40766d3bcc8d57e0982">PKTLAB_DECODE_INVAL</a> = 1, 
<a class="el" href="pktlab_8h.html#abd8c7b5f58a51788e8ee06ca5a1490f4a15553def53746a764633074e06b2c02c">PKTLAB_DECODE_BAD_SIGALG</a> = 2, 
<a class="el" href="pktlab_8h.html#abd8c7b5f58a51788e8ee06ca5a1490f4ac2917a8c12f8f7097fc56feabb67397b">PKTLAB_DECODE_BAD_SIGNATURE</a> = 3, 
<br />
&#160;&#160;<a class="el" href="pktlab_8h.html#abd8c7b5f58a51788e8ee06ca5a1490f4a484660c54864d5612472fcadb98d6c24">PKTLAB_DECODE_BAD_X509_VER</a> = 4, 
<a class="el" href="pktlab_8h.html#abd8c7b5f58a51788e8ee06ca5a1490f4af4587f5f1e0d78d91cf493effd455b44">PKTLAB_DECODE_USING_UNUSED_FIELD</a> = 5, 
<a class="el" href="pktlab_8h.html#abd8c7b5f58a51788e8ee06ca5a1490f4aefd39c407937e2f5fd2b79f52a80c489">PKTLAB_DECODE_BAD_CERT_TYPE</a> = 6, 
<a class="el" href="pktlab_8h.html#abd8c7b5f58a51788e8ee06ca5a1490f4adcb08f4990d4faeb59987c1a67269700">PKTLAB_DECODE_BAD_KEYUSAGE</a> = 7, 
<br />
&#160;&#160;<a class="el" href="pktlab_8h.html#abd8c7b5f58a51788e8ee06ca5a1490f4a82aaf4181957f53d3da9959ed22f742c">PKTLAB_DECODE_BAD_SERIAL</a> = 8, 
<a class="el" href="pktlab_8h.html#abd8c7b5f58a51788e8ee06ca5a1490f4a47cae20be6533da201c73dcd716895df">PKTLAB_DECODE_BAD_VALIDITY</a> = 9, 
<a class="el" href="pktlab_8h.html#abd8c7b5f58a51788e8ee06ca5a1490f4a55d4e414653f2800e18596caabc487b0">PKTLAB_DECODE_BAD_SUBJ_PUBKEY</a> = 10, 
<a class="el" href="pktlab_8h.html#abd8c7b5f58a51788e8ee06ca5a1490f4add6f91f303cc3e34f19798a645ed49af">PKTLAB_DECODE_BAD_AID</a> = 11, 
<br />
&#160;&#160;<a class="el" href="pktlab_8h.html#abd8c7b5f58a51788e8ee06ca5a1490f4ac8a5d1bc79cdf57496d8fa4e6fe31509">PKTLAB_DECODE_BAD_SID</a> = 12, 
<a class="el" href="pktlab_8h.html#abd8c7b5f58a51788e8ee06ca5a1490f4a72b6b91315714d4cefe5f1df672e36b5">PKTLAB_DECODE_BAD_BC</a> = 13, 
<a class="el" href="pktlab_8h.html#abd8c7b5f58a51788e8ee06ca5a1490f4af2ca974474df7c013395ef76e2a861d8">PKTLAB_DECODE_BAD_CERT_INFO</a> = 14, 
<a class="el" href="pktlab_8h.html#abd8c7b5f58a51788e8ee06ca5a1490f4a75ddc1ef48cec06fc45efcec103dc525">PKTLAB_DECODE_BAD_CERT_LIMIT</a> = 15, 
<br />
&#160;&#160;<a class="el" href="pktlab_8h.html#abd8c7b5f58a51788e8ee06ca5a1490f4af4d9e5d3756d2d8254be74516be2a5b7">PKTLAB_DECODE_BAD_PRIORITY</a> = 16, 
<a class="el" href="pktlab_8h.html#abd8c7b5f58a51788e8ee06ca5a1490f4a9a35d523b9b86b43d78e81e958d733d3">PKTLAB_DECODE_BAD_MONITOR_DIGESTS</a> = 17, 
<a class="el" href="pktlab_8h.html#abd8c7b5f58a51788e8ee06ca5a1490f4a15e0061da6d977b93462fffabe9406da">PKTLAB_DECODE_BAD_DEL_TYPE</a> = 18, 
<a class="el" href="pktlab_8h.html#abd8c7b5f58a51788e8ee06ca5a1490f4a52ae4573373542449bbf3c91d518b749">PKTLAB_DECODE_BAD_AUX_INFO</a> = 19, 
<br />
&#160;&#160;<a class="el" href="pktlab_8h.html#abd8c7b5f58a51788e8ee06ca5a1490f4a6284f23db5e92cd134738ace48316af4">PKTLAB_DECODE_BAD_CERT_DESC</a> = 20, 
<a class="el" href="pktlab_8h.html#abd8c7b5f58a51788e8ee06ca5a1490f4a10f45b088c2d1bf90f03dc9df28342df">PKTLAB_DECODE_BAD_VALID_DEST</a> = 21, 
<a class="el" href="pktlab_8h.html#abd8c7b5f58a51788e8ee06ca5a1490f4a81bef257e6e39c4f133ac6a684be35df">PKTLAB_DECODE_BAD_SRC_IP_SPOOFING</a> = 22, 
<a class="el" href="pktlab_8h.html#abd8c7b5f58a51788e8ee06ca5a1490f4a80da5595489426a432f81e5a6dc433c6">PKTLAB_DECODE_BAD_MAX_BURST_RATE</a> = 23, 
<br />
&#160;&#160;<a class="el" href="pktlab_8h.html#abd8c7b5f58a51788e8ee06ca5a1490f4a52ff628851da438d3b17f1811bb51282">PKTLAB_DECODE_UNKNOWN_FAULT</a> = 127
<br />
 }</td></tr>
<tr class="memdesc:abd8c7b5f58a51788e8ee06ca5a1490f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">pktlab certificate decoding result values.  <a href="pktlab_8h.html#abd8c7b5f58a51788e8ee06ca5a1490f4">More...</a><br /></td></tr>
<tr class="separator:abd8c7b5f58a51788e8ee06ca5a1490f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3fe0e0f5443851e1a9302772b40b69"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a9a3fe0e0f5443851e1a9302772b40b69">pktlab_auth_mode</a> { <a class="el" href="pktlab_8h.html#a9a3fe0e0f5443851e1a9302772b40b69a2ee445896fff4561c088014085c029ab">PKTLAB_CONTROLLER_AUTH_ENDPOINT</a> = 0, 
<a class="el" href="pktlab_8h.html#a9a3fe0e0f5443851e1a9302772b40b69a5a8bc5276c6e269e729075dcd5790975">PKTLAB_ENDPOINT_AUTH_CONTROLLER</a> = 1, 
<a class="el" href="pktlab_8h.html#a9a3fe0e0f5443851e1a9302772b40b69a0a0e2092d9d988564853b09041c9e332">PKTLAB_AUTH_AGENT</a> = 2, 
<a class="el" href="pktlab_8h.html#a9a3fe0e0f5443851e1a9302772b40b69a7e3e4e0e3f5947f9f7d11e9c5a891bd2">PKTLAB_NO_VERIFY</a> = 127
 }</td></tr>
<tr class="memdesc:a9a3fe0e0f5443851e1a9302772b40b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">pktlab certificate chain verification mode values.  <a href="pktlab_8h.html#a9a3fe0e0f5443851e1a9302772b40b69">More...</a><br /></td></tr>
<tr class="separator:a9a3fe0e0f5443851e1a9302772b40b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed10ca50609b48e4abf6e5356de41bee"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#aed10ca50609b48e4abf6e5356de41bee">pktlab_verify_rst</a> { <br />
&#160;&#160;<a class="el" href="pktlab_8h.html#aed10ca50609b48e4abf6e5356de41beeac4823f20f6098c09e901649704cd678a">PKTLAB_VERIFY_SUCCESS</a> = 0, 
<a class="el" href="pktlab_8h.html#aed10ca50609b48e4abf6e5356de41beea1c84b121e71d7322041e8d7170f11970">PKTLAB_VERIFY_INVAL</a> = 1, 
<a class="el" href="pktlab_8h.html#aed10ca50609b48e4abf6e5356de41beea127d41d0ac33de09dee11bdac09f4614">PKTLAB_VERIFY_BAD_CERT</a> = 2, 
<a class="el" href="pktlab_8h.html#aed10ca50609b48e4abf6e5356de41beea0583adde08ac4ae9f976ca325e54c6c9">PKTLAB_VERIFY_NOT_ENOUGH_CERT</a> = 3, 
<br />
&#160;&#160;<a class="el" href="pktlab_8h.html#aed10ca50609b48e4abf6e5356de41beeaff3239f1f5629068fdc655b36b218855">PKTLAB_VERIFY_TOO_MANY_CERT</a> = 4, 
<a class="el" href="pktlab_8h.html#aed10ca50609b48e4abf6e5356de41beea610a6bf16a92295473abf1ceb4e6a89a">PKTLAB_VERIFY_UNEXPECTED_CERT</a> = 5, 
<a class="el" href="pktlab_8h.html#aed10ca50609b48e4abf6e5356de41beea94ec7a80e374018440f09bcb89392553">PKTLAB_VERIFY_EXPIRED_CERT</a> = 6, 
<a class="el" href="pktlab_8h.html#aed10ca50609b48e4abf6e5356de41beea685deb82a91e9a3d978d090a5087f31b">PKTLAB_VERIFY_NO_MATCHING_SIGN_KEY</a> = 7, 
<br />
&#160;&#160;<a class="el" href="pktlab_8h.html#aed10ca50609b48e4abf6e5356de41beeaa147338b915302515e18c3414b1de050">PKTLAB_VERIFY_PATHLEN_EXCEEDED</a> = 8, 
<a class="el" href="pktlab_8h.html#aed10ca50609b48e4abf6e5356de41beea1852954873431585827684a5310985f5">PKTLAB_VERIFY_END_OF_PHASES</a> = 9, 
<a class="el" href="pktlab_8h.html#aed10ca50609b48e4abf6e5356de41beeaa00cb333231d3a5788526700b8001bae">PKTLAB_VERIFY_BAD_DEL_TYPE</a> = 10, 
<a class="el" href="pktlab_8h.html#aed10ca50609b48e4abf6e5356de41beea15dc090473932746504e31d4a2781ab0">PKTLAB_VERIFY_UNKNOWN_FAULT</a> = 127
<br />
 }</td></tr>
<tr class="memdesc:aed10ca50609b48e4abf6e5356de41bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">pktlab certificate chain verification result values.  <a href="pktlab_8h.html#aed10ca50609b48e4abf6e5356de41bee">More...</a><br /></td></tr>
<tr class="separator:aed10ca50609b48e4abf6e5356de41bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9013dca3f65366f6834a38b13e8933b4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a9013dca3f65366f6834a38b13e8933b4">pktlab_parse_cert_chain_rst</a> { <br />
&#160;&#160;<b>PKTLAB_PARSE_CHAIN_SUCCESS</b> = 0, 
<b>PKTLAB_PARSE_CHAIN_INVAL</b> = 1, 
<b>PKTLAB_PARSE_CHAIN_BAD_CHAIN</b> = 2, 
<b>PKTLAB_PARSE_CHAIN_BAD_KEY</b> = 3, 
<br />
&#160;&#160;<b>PKTLAB_PARSE_CHAIN_UNKNOWN_FAULT</b> = 127
<br />
 }</td></tr>
<tr class="memdesc:a9013dca3f65366f6834a38b13e8933b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">pktlab certificate chain parsing result values.  <a href="pktlab_8h.html#a9013dca3f65366f6834a38b13e8933b4">More...</a><br /></td></tr>
<tr class="separator:a9013dca3f65366f6834a38b13e8933b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a105d5b772f2827d0f09f390d38b9864f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pktlab_8h.html#ae9515e3477c7b07d3cf086e3a3e463c1">pktlab_time_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a105d5b772f2827d0f09f390d38b9864f">pktlab_time_now</a> (void)</td></tr>
<tr class="memdesc:a105d5b772f2827d0f09f390d38b9864f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current pktlab time.  <a href="pktlab_8h.html#a105d5b772f2827d0f09f390d38b9864f">More...</a><br /></td></tr>
<tr class="separator:a105d5b772f2827d0f09f390d38b9864f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d4fa34a4fcc092c65688b58fa32439"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="pktlab_8h.html#ae9515e3477c7b07d3cf086e3a3e463c1">pktlab_time_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a42d4fa34a4fcc092c65688b58fa32439">pktlab_time_sec</a> (uint_fast32_t sec)</td></tr>
<tr class="memdesc:a42d4fa34a4fcc092c65688b58fa32439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert seconds to pktlab ticks.  <a href="pktlab_8h.html#a42d4fa34a4fcc092c65688b58fa32439">More...</a><br /></td></tr>
<tr class="separator:a42d4fa34a4fcc092c65688b58fa32439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1382eb7d33071de905e764236846b9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="pktlab_8h.html#ae9515e3477c7b07d3cf086e3a3e463c1">pktlab_time_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#adf1382eb7d33071de905e764236846b9">pktlab_timeval_to_time</a> (const struct timeval *tv)</td></tr>
<tr class="memdesc:adf1382eb7d33071de905e764236846b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert time period in struct timeval to pktlab ticks.  <a href="pktlab_8h.html#adf1382eb7d33071de905e764236846b9">More...</a><br /></td></tr>
<tr class="separator:adf1382eb7d33071de905e764236846b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15de87064c8013994581d2f0f526d63"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="pktlab_8h.html#ae9515e3477c7b07d3cf086e3a3e463c1">pktlab_time_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#af15de87064c8013994581d2f0f526d63">pktlab_timespec_to_time</a> (const struct timespec *tp)</td></tr>
<tr class="memdesc:af15de87064c8013994581d2f0f526d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert time period in struct timespec to pktlab ticks.  <a href="pktlab_8h.html#af15de87064c8013994581d2f0f526d63">More...</a><br /></td></tr>
<tr class="separator:af15de87064c8013994581d2f0f526d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a8b5663bb6251fef86fd66e880b11f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a09a8b5663bb6251fef86fd66e880b11f">pktlab_time_to_timeval</a> (<a class="el" href="pktlab_8h.html#ae9515e3477c7b07d3cf086e3a3e463c1">pktlab_time_t</a> t, struct timeval *tv)</td></tr>
<tr class="memdesc:a09a8b5663bb6251fef86fd66e880b11f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert time period in pktlab ticks to struct timeval.  <a href="pktlab_8h.html#a09a8b5663bb6251fef86fd66e880b11f">More...</a><br /></td></tr>
<tr class="separator:a09a8b5663bb6251fef86fd66e880b11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116b50578ab12d41aeb46895a323d491"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a116b50578ab12d41aeb46895a323d491">pktlab_time_to_timespec</a> (<a class="el" href="pktlab_8h.html#ae9515e3477c7b07d3cf086e3a3e463c1">pktlab_time_t</a> t, struct timespec *tp)</td></tr>
<tr class="memdesc:a116b50578ab12d41aeb46895a323d491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert time period in pktlab ticks to struct timespec.  <a href="pktlab_8h.html#a116b50578ab12d41aeb46895a323d491">More...</a><br /></td></tr>
<tr class="separator:a116b50578ab12d41aeb46895a323d491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf51f30a382dc01fde04a943051f6ed"><td class="memItemLeft" align="right" valign="top">static uint_fast32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#adbf51f30a382dc01fde04a943051f6ed">pktlab_time_to_unix_time</a> (<a class="el" href="pktlab_8h.html#ae9515e3477c7b07d3cf086e3a3e463c1">pktlab_time_t</a> t)</td></tr>
<tr class="memdesc:adbf51f30a382dc01fde04a943051f6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a pktlab time to Unix time (in second precision).  <a href="pktlab_8h.html#adbf51f30a382dc01fde04a943051f6ed">More...</a><br /></td></tr>
<tr class="separator:adbf51f30a382dc01fde04a943051f6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad268368f2cb84634e924f6bbe8b3165"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pktlab_8h.html#ae9515e3477c7b07d3cf086e3a3e463c1">pktlab_time_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#aad268368f2cb84634e924f6bbe8b3165">pktlab_tm_to_time</a> (const struct tm *tm)</td></tr>
<tr class="memdesc:aad268368f2cb84634e924f6bbe8b3165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert time in struct tm to pktlab time.  <a href="pktlab_8h.html#aad268368f2cb84634e924f6bbe8b3165">More...</a><br /></td></tr>
<tr class="separator:aad268368f2cb84634e924f6bbe8b3165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae4203d86e65c950480989c3a37df51"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a1ae4203d86e65c950480989c3a37df51">pktlab_decode_xdescr</a> (const char *xdescr, uint_fast32_t xdescrlen, struct <a class="el" href="structpktlab__namevalue__pair.html">pktlab_namevalue_pair</a> **pairs, uint_fast32_t *paircnt)</td></tr>
<tr class="memdesc:a1ae4203d86e65c950480989c3a37df51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode an encoded experiment descriptor (xdescr) string.  <a href="pktlab_8h.html#a1ae4203d86e65c950480989c3a37df51">More...</a><br /></td></tr>
<tr class="separator:a1ae4203d86e65c950480989c3a37df51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00b6175847f6fee69812d48b6143500"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#ae00b6175847f6fee69812d48b6143500">pktlab_encode_xdescr</a> (const struct <a class="el" href="structpktlab__namevalue__pair.html">pktlab_namevalue_pair</a> *pairs, uint_fast32_t paircnt, char *buf, uint_fast32_t buflen, uint_fast32_t *used)</td></tr>
<tr class="memdesc:ae00b6175847f6fee69812d48b6143500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode an experiment descriptor (xdescr) string.  <a href="pktlab_8h.html#ae00b6175847f6fee69812d48b6143500">More...</a><br /></td></tr>
<tr class="separator:ae00b6175847f6fee69812d48b6143500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d500bfe2d478128c9a84395a915befd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a0d500bfe2d478128c9a84395a915befd">pktlab_decode_dattr</a> (const char *dattr, uint_fast32_t dattrlen, struct <a class="el" href="structpktlab__namevalue__pair.html">pktlab_namevalue_pair</a> **pairs, uint_fast32_t *paircnt)</td></tr>
<tr class="memdesc:a0d500bfe2d478128c9a84395a915befd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode an encoded endpoint attribute (dattr) string.  <a href="pktlab_8h.html#a0d500bfe2d478128c9a84395a915befd">More...</a><br /></td></tr>
<tr class="separator:a0d500bfe2d478128c9a84395a915befd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabedaec160b02afe6824fc0b2ee80e09"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#aabedaec160b02afe6824fc0b2ee80e09">pktlab_encode_dattr</a> (const struct <a class="el" href="structpktlab__namevalue__pair.html">pktlab_namevalue_pair</a> *pairs, uint_fast32_t paircnt, char *buf, uint_fast32_t buflen, uint_fast32_t *used)</td></tr>
<tr class="memdesc:aabedaec160b02afe6824fc0b2ee80e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode an endpoint attribute (dattr) string.  <a href="pktlab_8h.html#aabedaec160b02afe6824fc0b2ee80e09">More...</a><br /></td></tr>
<tr class="separator:aabedaec160b02afe6824fc0b2ee80e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6108d1f346715330ddffbf00c4fabb9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#aa6108d1f346715330ddffbf00c4fabb9">pktlab_xdescr_dattr_match</a> (const char *xdescr, uint_fast32_t xdescrlen, const char *dattr, uint_fast32_t dattrlen)</td></tr>
<tr class="memdesc:aa6108d1f346715330ddffbf00c4fabb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match an experiment descriptor (xdescr) string to an endpoint attribute (dattr) string.  <a href="pktlab_8h.html#aa6108d1f346715330ddffbf00c4fabb9">More...</a><br /></td></tr>
<tr class="separator:aa6108d1f346715330ddffbf00c4fabb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5fd5afc15a1f1659a9f1aa2ac4bc001"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#ab5fd5afc15a1f1659a9f1aa2ac4bc001">pktlab_encode_chlist</a> (const struct <a class="el" href="structpktlab__channel.html">pktlab_channel</a> *channels, void **chlistptr, uint_fast32_t *chlistlen)</td></tr>
<tr class="memdesc:ab5fd5afc15a1f1659a9f1aa2ac4bc001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode a channel list.  <a href="pktlab_8h.html#ab5fd5afc15a1f1659a9f1aa2ac4bc001">More...</a><br /></td></tr>
<tr class="separator:ab5fd5afc15a1f1659a9f1aa2ac4bc001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11191f0ec3dcdb30cfa402ad42aca759"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a11191f0ec3dcdb30cfa402ad42aca759">pktlab_decode_chlist</a> (const void *chlistptr, uint_fast32_t chlistlen, struct <a class="el" href="structpktlab__channel.html">pktlab_channel</a> **channels)</td></tr>
<tr class="memdesc:a11191f0ec3dcdb30cfa402ad42aca759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a channel list.  <a href="pktlab_8h.html#a11191f0ec3dcdb30cfa402ad42aca759">More...</a><br /></td></tr>
<tr class="separator:a11191f0ec3dcdb30cfa402ad42aca759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d013b2cc5d9c48ba209961865b42dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#ab4d013b2cc5d9c48ba209961865b42dc">pktlab_free_channels</a> (struct <a class="el" href="structpktlab__channel.html">pktlab_channel</a> *channels)</td></tr>
<tr class="memdesc:ab4d013b2cc5d9c48ba209961865b42dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an allocated channel linked list.  <a href="pktlab_8h.html#ab4d013b2cc5d9c48ba209961865b42dc">More...</a><br /></td></tr>
<tr class="separator:ab4d013b2cc5d9c48ba209961865b42dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38fd911b937df605572e03da14661cb5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a38fd911b937df605572e03da14661cb5">pktlab_encode_program</a> (enum <a class="el" href="pktlab_8h.html#ad49ead2ad49df1700b526ccd019854b4">pktlab_prog_type</a> type, const void *prog, uint_fast32_t proglen, void **buf, uint_fast32_t *buflen)</td></tr>
<tr class="memdesc:a38fd911b937df605572e03da14661cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode pktlab program.  <a href="pktlab_8h.html#a38fd911b937df605572e03da14661cb5">More...</a><br /></td></tr>
<tr class="separator:a38fd911b937df605572e03da14661cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d44cc890cc8acd2d7e6328b17b2472"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a75d44cc890cc8acd2d7e6328b17b2472">pktlab_decode_program</a> (const void *buf, uint_fast32_t buflen, enum <a class="el" href="pktlab_8h.html#ad49ead2ad49df1700b526ccd019854b4">pktlab_prog_type</a> *type, void **prog, uint_fast32_t *proglen)</td></tr>
<tr class="memdesc:a75d44cc890cc8acd2d7e6328b17b2472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode pktlab program.  <a href="pktlab_8h.html#a75d44cc890cc8acd2d7e6328b17b2472">More...</a><br /></td></tr>
<tr class="separator:a75d44cc890cc8acd2d7e6328b17b2472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b949eef395e62b0fc6d60a0ce3b785"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#aa2b949eef395e62b0fc6d60a0ce3b785">pktlab_get_program_digest</a> (const void *data, uint_fast32_t datalen, uint8_t *digest)</td></tr>
<tr class="memdesc:aa2b949eef395e62b0fc6d60a0ce3b785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute encoded pktlab program digest.  <a href="pktlab_8h.html#aa2b949eef395e62b0fc6d60a0ce3b785">More...</a><br /></td></tr>
<tr class="separator:aa2b949eef395e62b0fc6d60a0ce3b785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474a11faa38efb191e9ab92735cfa473"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a474a11faa38efb191e9ab92735cfa473">pktlab_load_program</a> (const char *data, uint_fast32_t datalen, enum <a class="el" href="pktlab_8h.html#ad49ead2ad49df1700b526ccd019854b4">pktlab_prog_type</a> type, void **prog, uint_fast32_t *proglen, uint_fast32_t *errlineno)</td></tr>
<tr class="memdesc:a474a11faa38efb191e9ab92735cfa473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load pktlab program from file content.  <a href="pktlab_8h.html#a474a11faa38efb191e9ab92735cfa473">More...</a><br /></td></tr>
<tr class="separator:a474a11faa38efb191e9ab92735cfa473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b92ae4a2175cf16998795281831f53"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a56b92ae4a2175cf16998795281831f53">pktlab_parse_uri</a> (struct <a class="el" href="structpktlab__uri.html">pktlab_uri</a> *restrict uri_info, const void *restrict ptr, uint_fast32_t len)</td></tr>
<tr class="memdesc:a56b92ae4a2175cf16998795281831f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a pktlab URI.  <a href="pktlab_8h.html#a56b92ae4a2175cf16998795281831f53">More...</a><br /></td></tr>
<tr class="separator:a56b92ae4a2175cf16998795281831f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5375bd7ad2395ab8c01874d4fb63016f"><td class="memItemLeft" align="right" valign="top"><a id="a5375bd7ad2395ab8c01874d4fb63016f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_vmem_read</b> (const struct <a class="el" href="structpktlab__vmem__region.html">pktlab_vmem_region</a> *restrict rgn, uint_fast32_t rgncnt, uint_fast32_t addr, uint_fast32_t len, void *restrict dst)</td></tr>
<tr class="separator:a5375bd7ad2395ab8c01874d4fb63016f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac843700d9335b616d761cca8f3c1c538"><td class="memItemLeft" align="right" valign="top"><a id="ac843700d9335b616d761cca8f3c1c538"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_vmem_write</b> (const struct <a class="el" href="structpktlab__vmem__region.html">pktlab_vmem_region</a> *restrict rgn, uint_fast32_t rgncnt, uint_fast32_t addr, uint_fast32_t len, const void *restrict src)</td></tr>
<tr class="separator:ac843700d9335b616d761cca8f3c1c538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251b488a69ccfdacc23d2a88ea657769"><td class="memItemLeft" align="right" valign="top"><a id="a251b488a69ccfdacc23d2a88ea657769"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_buffer_reader</b> (const struct <a class="el" href="structpktlab__vmem__region.html">pktlab_vmem_region</a> *restrict rgn, uint_fast32_t addr, uint_fast32_t len, void *restrict dst)</td></tr>
<tr class="separator:a251b488a69ccfdacc23d2a88ea657769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04edba3041bed824a392c5d7a172783e"><td class="memItemLeft" align="right" valign="top"><a id="a04edba3041bed824a392c5d7a172783e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_buffer_writer</b> (const struct <a class="el" href="structpktlab__vmem__region.html">pktlab_vmem_region</a> *restrict rgn, uint_fast32_t addr, uint_fast32_t len, const void *restrict src)</td></tr>
<tr class="separator:a04edba3041bed824a392c5d7a172783e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae23868914b91e99903b7f8581cee5f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a2ae23868914b91e99903b7f8581cee5f">pktlab_decode_message</a> (struct <a class="el" href="structpktlab__message.html">pktlab_message</a> *restrict msg, const void *restrict ptr, size_t len)</td></tr>
<tr class="memdesc:a2ae23868914b91e99903b7f8581cee5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode pktlab message.  <a href="pktlab_8h.html#a2ae23868914b91e99903b7f8581cee5f">More...</a><br /></td></tr>
<tr class="separator:a2ae23868914b91e99903b7f8581cee5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7992448d296c83dfb78ccece719687f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a7992448d296c83dfb78ccece719687f8">pktlab_encode_message</a> (const struct <a class="el" href="structpktlab__message.html">pktlab_message</a> *restrict msg, void *restrict buf, struct iovec *restrict iov)</td></tr>
<tr class="memdesc:a7992448d296c83dfb78ccece719687f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode pktlab message.  <a href="pktlab_8h.html#a7992448d296c83dfb78ccece719687f8">More...</a><br /></td></tr>
<tr class="separator:a7992448d296c83dfb78ccece719687f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b1653ecc589ccfb1e6852a3f1e9a07"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structpktlab__message.html">pktlab_message</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a94b1653ecc589ccfb1e6852a3f1e9a07">pktlab_create_result_message</a> (enum <a class="el" href="pktlab_8h.html#abd1908d576437c692d3be8071c75cab9">pktlab_status</a> status)</td></tr>
<tr class="memdesc:a94b1653ecc589ccfb1e6852a3f1e9a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get fields-set pktlab result message.  <a href="pktlab_8h.html#a94b1653ecc589ccfb1e6852a3f1e9a07">More...</a><br /></td></tr>
<tr class="separator:a94b1653ecc589ccfb1e6852a3f1e9a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b65a1a8f3339b7b12f17fbbe8ce588e"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structpktlab__message.html">pktlab_message</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a9b65a1a8f3339b7b12f17fbbe8ce588e">pktlab_create_monrej_result_message</a> (uint16_t monindx, uint16_t monerrid)</td></tr>
<tr class="memdesc:a9b65a1a8f3339b7b12f17fbbe8ce588e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get fields-set pktlab result message with status PKTLAB_ECTLMONREJ.  <a href="pktlab_8h.html#a9b65a1a8f3339b7b12f17fbbe8ce588e">More...</a><br /></td></tr>
<tr class="separator:a9b65a1a8f3339b7b12f17fbbe8ce588e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5591f71ffd1b356cc39dd7658cd42b"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structpktlab__message.html">pktlab_message</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a4a5591f71ffd1b356cc39dd7658cd42b">pktlab_create_monukn_result_message</a> (uint16_t monindx)</td></tr>
<tr class="memdesc:a4a5591f71ffd1b356cc39dd7658cd42b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get fields-set pktlab result message with status PKTLAB_ECTLMONUKN.  <a href="pktlab_8h.html#a4a5591f71ffd1b356cc39dd7658cd42b">More...</a><br /></td></tr>
<tr class="separator:a4a5591f71ffd1b356cc39dd7658cd42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab098bfcd9956999449336ea2d86603d7"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structpktlab__reader.html">pktlab_reader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#ab098bfcd9956999449336ea2d86603d7">pktlab_create_reader</a> (<a class="el" href="pktlab_8h.html#a89fe04b2d2e1cd53344b3d0e8b0c7789">pktlab_read_t</a> read, void *aux)</td></tr>
<tr class="memdesc:ab098bfcd9956999449336ea2d86603d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get initialized pktlab reader struct.  <a href="pktlab_8h.html#ab098bfcd9956999449336ea2d86603d7">More...</a><br /></td></tr>
<tr class="separator:ab098bfcd9956999449336ea2d86603d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ac5f5ebe314972be37bdb18887a54d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a65ac5f5ebe314972be37bdb18887a54d">pktlab_close_reader</a> (struct <a class="el" href="structpktlab__reader.html">pktlab_reader</a> *r)</td></tr>
<tr class="memdesc:a65ac5f5ebe314972be37bdb18887a54d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close and free pktlab reader struct.  <a href="pktlab_8h.html#a65ac5f5ebe314972be37bdb18887a54d">More...</a><br /></td></tr>
<tr class="separator:a65ac5f5ebe314972be37bdb18887a54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d2e1da9a8100c9b49af48fba78662b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#ae8d2e1da9a8100c9b49af48fba78662b">pktlab_reader_readaux</a> (const struct <a class="el" href="structpktlab__reader.html">pktlab_reader</a> *r)</td></tr>
<tr class="memdesc:ae8d2e1da9a8100c9b49af48fba78662b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pktlab reader struct aux information.  <a href="pktlab_8h.html#ae8d2e1da9a8100c9b49af48fba78662b">More...</a><br /></td></tr>
<tr class="separator:ae8d2e1da9a8100c9b49af48fba78662b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3ef3c891d623ca8152429834b4fde0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#adb3ef3c891d623ca8152429834b4fde0">pktlab_read_message</a> (struct <a class="el" href="structpktlab__reader.html">pktlab_reader</a> *restrict r, struct <a class="el" href="structpktlab__message.html">pktlab_message</a> **restrict msgptr)</td></tr>
<tr class="memdesc:adb3ef3c891d623ca8152429834b4fde0"><td class="mdescLeft">&#160;</td><td class="mdescRight">pktlab reader read message.  <a href="pktlab_8h.html#adb3ef3c891d623ca8152429834b4fde0">More...</a><br /></td></tr>
<tr class="separator:adb3ef3c891d623ca8152429834b4fde0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b21cba7d11c875b5268542c49e6d2a4"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structpktlab__writer.html">pktlab_writer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a9b21cba7d11c875b5268542c49e6d2a4">pktlab_create_writer</a> (<a class="el" href="pktlab_8h.html#a53f306929ea68ec41259ed659a72134b">pktlab_write_t</a> write, void *aux)</td></tr>
<tr class="memdesc:a9b21cba7d11c875b5268542c49e6d2a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get initialized pktlab writer struct.  <a href="pktlab_8h.html#a9b21cba7d11c875b5268542c49e6d2a4">More...</a><br /></td></tr>
<tr class="separator:a9b21cba7d11c875b5268542c49e6d2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72bb120e12a20032c6ae919cc7a52926"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a72bb120e12a20032c6ae919cc7a52926">pktlab_close_writer</a> (struct <a class="el" href="structpktlab__writer.html">pktlab_writer</a> *w)</td></tr>
<tr class="memdesc:a72bb120e12a20032c6ae919cc7a52926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close and free pktlab writer struct.  <a href="pktlab_8h.html#a72bb120e12a20032c6ae919cc7a52926">More...</a><br /></td></tr>
<tr class="separator:a72bb120e12a20032c6ae919cc7a52926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524fb1985afe251a4ba072fd9176fd98"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a524fb1985afe251a4ba072fd9176fd98">pktlab_flush_writer</a> (struct <a class="el" href="structpktlab__writer.html">pktlab_writer</a> *w)</td></tr>
<tr class="memdesc:a524fb1985afe251a4ba072fd9176fd98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush pktlab writer internal buffer.  <a href="pktlab_8h.html#a524fb1985afe251a4ba072fd9176fd98">More...</a><br /></td></tr>
<tr class="separator:a524fb1985afe251a4ba072fd9176fd98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8895ba48507b6ec6af8fb007c61d31"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#aae8895ba48507b6ec6af8fb007c61d31">pktlab_writer_unsent</a> (const struct <a class="el" href="structpktlab__writer.html">pktlab_writer</a> *w)</td></tr>
<tr class="memdesc:aae8895ba48507b6ec6af8fb007c61d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get writer internal buffered content length.  <a href="pktlab_8h.html#aae8895ba48507b6ec6af8fb007c61d31">More...</a><br /></td></tr>
<tr class="separator:aae8895ba48507b6ec6af8fb007c61d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac5b320dd2821800b6c595abd30c277"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a2ac5b320dd2821800b6c595abd30c277">pktlab_writer_writeaux</a> (const struct <a class="el" href="structpktlab__writer.html">pktlab_writer</a> *w)</td></tr>
<tr class="memdesc:a2ac5b320dd2821800b6c595abd30c277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pktlab writer struct aux information.  <a href="pktlab_8h.html#a2ac5b320dd2821800b6c595abd30c277">More...</a><br /></td></tr>
<tr class="separator:a2ac5b320dd2821800b6c595abd30c277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50455dc8d68498355c5dd5094a8770d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#ae50455dc8d68498355c5dd5094a8770d">pktlab_write_message</a> (struct <a class="el" href="structpktlab__writer.html">pktlab_writer</a> *restrict w, const struct <a class="el" href="structpktlab__message.html">pktlab_message</a> *restrict msg)</td></tr>
<tr class="memdesc:ae50455dc8d68498355c5dd5094a8770d"><td class="mdescLeft">&#160;</td><td class="mdescRight">pktlab writer write message.  <a href="pktlab_8h.html#ae50455dc8d68498355c5dd5094a8770d">More...</a><br /></td></tr>
<tr class="separator:ae50455dc8d68498355c5dd5094a8770d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5370405d8eb6628ec3a1e9f31cd9d70"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#aa5370405d8eb6628ec3a1e9f31cd9d70">pktlab_sktstate_name</a> (enum pktlab_socket_state state)</td></tr>
<tr class="memdesc:aa5370405d8eb6628ec3a1e9f31cd9d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get text description of pktlab endpoint skt state.  <a href="pktlab_8h.html#aa5370405d8eb6628ec3a1e9f31cd9d70">More...</a><br /></td></tr>
<tr class="separator:aa5370405d8eb6628ec3a1e9f31cd9d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737dd716edca6ba83b6024db285c14df"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structpktlab__publickey.html">pktlab_publickey</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a737dd716edca6ba83b6024db285c14df">pktlab_create_publickey</a> (void)</td></tr>
<tr class="memdesc:a737dd716edca6ba83b6024db285c14df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate initialized pktlab public key struct.  <a href="pktlab_8h.html#a737dd716edca6ba83b6024db285c14df">More...</a><br /></td></tr>
<tr class="separator:a737dd716edca6ba83b6024db285c14df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860ac68eae6a58a3a475febf10a503df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a860ac68eae6a58a3a475febf10a503df">pktlab_load_publickey_pem</a> (const char *pem, uint_fast32_t pemlen, struct <a class="el" href="structpktlab__publickey.html">pktlab_publickey</a> *k)</td></tr>
<tr class="memdesc:a860ac68eae6a58a3a475febf10a503df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load pktlab public key struct via PEM-encoded public key char array.  <a href="pktlab_8h.html#a860ac68eae6a58a3a475febf10a503df">More...</a><br /></td></tr>
<tr class="separator:a860ac68eae6a58a3a475febf10a503df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2389ebdfc43cc103c4ec7748fc03ed4a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a2389ebdfc43cc103c4ec7748fc03ed4a">pktlab_load_publickey_der</a> (const uint8_t *der, uint_fast32_t derlen, struct <a class="el" href="structpktlab__publickey.html">pktlab_publickey</a> *k)</td></tr>
<tr class="memdesc:a2389ebdfc43cc103c4ec7748fc03ed4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load pktlab public key struct via raw SubjectPublicKeyInfo byte array.  <a href="pktlab_8h.html#a2389ebdfc43cc103c4ec7748fc03ed4a">More...</a><br /></td></tr>
<tr class="separator:a2389ebdfc43cc103c4ec7748fc03ed4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2d7d0a3b1ad5b463c797dcdcadcc3d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#adc2d7d0a3b1ad5b463c797dcdcadcc3d">pktlab_load_publickey_raw</a> (const uint8_t *bytes, uint_fast32_t len, struct <a class="el" href="structpktlab__publickey.html">pktlab_publickey</a> *k)</td></tr>
<tr class="memdesc:adc2d7d0a3b1ad5b463c797dcdcadcc3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load pktlab public key struct via raw public key byte array.  <a href="pktlab_8h.html#adc2d7d0a3b1ad5b463c797dcdcadcc3d">More...</a><br /></td></tr>
<tr class="separator:adc2d7d0a3b1ad5b463c797dcdcadcc3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bcd697b77d479b45977f5432e97be28"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a5bcd697b77d479b45977f5432e97be28">pktlab_cleanup_publickey</a> (struct <a class="el" href="structpktlab__publickey.html">pktlab_publickey</a> *k)</td></tr>
<tr class="memdesc:a5bcd697b77d479b45977f5432e97be28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an allocated pktlab public key struct.  <a href="pktlab_8h.html#a5bcd697b77d479b45977f5432e97be28">More...</a><br /></td></tr>
<tr class="separator:a5bcd697b77d479b45977f5432e97be28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3640de2d82007424d1151036a05485"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a6c3640de2d82007424d1151036a05485">pktlab_get_publickey_bytes</a> (const struct <a class="el" href="structpktlab__publickey.html">pktlab_publickey</a> *k, void *buf, uint_fast32_t buflen)</td></tr>
<tr class="memdesc:a6c3640de2d82007424d1151036a05485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get raw public key byte array from loaded pktlab public key struct.  <a href="pktlab_8h.html#a6c3640de2d82007424d1151036a05485">More...</a><br /></td></tr>
<tr class="separator:a6c3640de2d82007424d1151036a05485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b69032d1a52cdcab113d89bd1ceb9f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a1b69032d1a52cdcab113d89bd1ceb9f6">pktlab_get_key_identifier</a> (const struct <a class="el" href="structpktlab__publickey.html">pktlab_publickey</a> *k, void *buf, uint_fast32_t buflen)</td></tr>
<tr class="memdesc:a1b69032d1a52cdcab113d89bd1ceb9f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get key identifier for a loaded pktlab public key struct.  <a href="pktlab_8h.html#a1b69032d1a52cdcab113d89bd1ceb9f6">More...</a><br /></td></tr>
<tr class="separator:a1b69032d1a52cdcab113d89bd1ceb9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36fa688be315248159d774f84beea8de"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structpktlab__privatekey.html">pktlab_privatekey</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a36fa688be315248159d774f84beea8de">pktlab_create_privatekey</a> (void)</td></tr>
<tr class="memdesc:a36fa688be315248159d774f84beea8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate initialized pktlab private key struct.  <a href="pktlab_8h.html#a36fa688be315248159d774f84beea8de">More...</a><br /></td></tr>
<tr class="separator:a36fa688be315248159d774f84beea8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eaff9c7a04dab9e1346a9cfb9128e01"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a9eaff9c7a04dab9e1346a9cfb9128e01">pktlab_load_privatekey_pem</a> (const char *pem, uint_fast32_t pemlen, const char *passphrase, struct <a class="el" href="structpktlab__privatekey.html">pktlab_privatekey</a> *k)</td></tr>
<tr class="memdesc:a9eaff9c7a04dab9e1346a9cfb9128e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load pktlab private key struct via PEM-encoded private key char array.  <a href="pktlab_8h.html#a9eaff9c7a04dab9e1346a9cfb9128e01">More...</a><br /></td></tr>
<tr class="separator:a9eaff9c7a04dab9e1346a9cfb9128e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14401636d8628029fba6b0d65948bed7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a14401636d8628029fba6b0d65948bed7">pktlab_load_privatekey_der</a> (const uint8_t *der, uint_fast32_t derlen, const char *passphrase, struct <a class="el" href="structpktlab__privatekey.html">pktlab_privatekey</a> *k)</td></tr>
<tr class="memdesc:a14401636d8628029fba6b0d65948bed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load pktlab private key struct via raw PKCS8 byte array.  <a href="pktlab_8h.html#a14401636d8628029fba6b0d65948bed7">More...</a><br /></td></tr>
<tr class="separator:a14401636d8628029fba6b0d65948bed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9276942f170f7919afced0fba4f2b81f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a9276942f170f7919afced0fba4f2b81f">pktlab_load_privatekey_raw</a> (const uint8_t *bytes, uint_fast32_t len, struct <a class="el" href="structpktlab__privatekey.html">pktlab_privatekey</a> *k)</td></tr>
<tr class="memdesc:a9276942f170f7919afced0fba4f2b81f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load pktlab private key struct via raw private key byte array.  <a href="pktlab_8h.html#a9276942f170f7919afced0fba4f2b81f">More...</a><br /></td></tr>
<tr class="separator:a9276942f170f7919afced0fba4f2b81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8438bd0e861dcca6190531cee5d3f3e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#ab8438bd0e861dcca6190531cee5d3f3e">pktlab_cleanup_privatekey</a> (struct <a class="el" href="structpktlab__privatekey.html">pktlab_privatekey</a> *k)</td></tr>
<tr class="memdesc:ab8438bd0e861dcca6190531cee5d3f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an allocated pktlab private key struct.  <a href="pktlab_8h.html#ab8438bd0e861dcca6190531cee5d3f3e">More...</a><br /></td></tr>
<tr class="separator:ab8438bd0e861dcca6190531cee5d3f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41d41e22e6227a80f35e5a7cbac485e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#ad41d41e22e6227a80f35e5a7cbac485e">pktlab_get_privatekey_bytes</a> (const struct <a class="el" href="structpktlab__privatekey.html">pktlab_privatekey</a> *k, void *buf, uint_fast32_t buflen)</td></tr>
<tr class="memdesc:ad41d41e22e6227a80f35e5a7cbac485e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get raw private key byte array from loaded pktlab private key struct.  <a href="pktlab_8h.html#ad41d41e22e6227a80f35e5a7cbac485e">More...</a><br /></td></tr>
<tr class="separator:ad41d41e22e6227a80f35e5a7cbac485e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae213d220889b409669983cbba1f41f19"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structpktlab__publickey.html">pktlab_publickey</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#ae213d220889b409669983cbba1f41f19">pktlab_get_publickey_from_privatekey</a> (const struct <a class="el" href="structpktlab__privatekey.html">pktlab_privatekey</a> *k)</td></tr>
<tr class="memdesc:ae213d220889b409669983cbba1f41f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get loaded pktlab public key struct from loaded pktlab private key struct.  <a href="pktlab_8h.html#ae213d220889b409669983cbba1f41f19">More...</a><br /></td></tr>
<tr class="separator:ae213d220889b409669983cbba1f41f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac782909f422cfc761a53fce7069a8660"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structpktlab__certificate.html">pktlab_certificate</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#ac782909f422cfc761a53fce7069a8660">pktlab_create_cert</a> (void)</td></tr>
<tr class="memdesc:ac782909f422cfc761a53fce7069a8660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate initialized pktlab certificate struct.  <a href="pktlab_8h.html#ac782909f422cfc761a53fce7069a8660">More...</a><br /></td></tr>
<tr class="separator:ac782909f422cfc761a53fce7069a8660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f92ccf1f8dbfb5aece5adb38b50cf03"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a5f92ccf1f8dbfb5aece5adb38b50cf03">pktlab_load_cert_pem</a> (const char *pem, uint_fast32_t pemlen, struct <a class="el" href="structpktlab__certificate.html">pktlab_certificate</a> *cert)</td></tr>
<tr class="memdesc:a5f92ccf1f8dbfb5aece5adb38b50cf03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load pktlab certificate struct via PEM-encoded pktlab certificate char array.  <a href="pktlab_8h.html#a5f92ccf1f8dbfb5aece5adb38b50cf03">More...</a><br /></td></tr>
<tr class="separator:a5f92ccf1f8dbfb5aece5adb38b50cf03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b189227e6fb95b9485b7d3cc6a77de1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a8b189227e6fb95b9485b7d3cc6a77de1">pktlab_load_cert_der</a> (const uint8_t *der, uint_fast32_t derlen, struct <a class="el" href="structpktlab__certificate.html">pktlab_certificate</a> *cert)</td></tr>
<tr class="memdesc:a8b189227e6fb95b9485b7d3cc6a77de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load pktlab certificate struct via DER-encode pktlab certificate byte array.  <a href="pktlab_8h.html#a8b189227e6fb95b9485b7d3cc6a77de1">More...</a><br /></td></tr>
<tr class="separator:a8b189227e6fb95b9485b7d3cc6a77de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9593d93f15ad31ed06951a05c7c8e5a9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a9593d93f15ad31ed06951a05c7c8e5a9">pktlab_get_cert_der</a> (const struct <a class="el" href="structpktlab__certificate.html">pktlab_certificate</a> *cert, void **der, uint_fast32_t *derlen)</td></tr>
<tr class="memdesc:a9593d93f15ad31ed06951a05c7c8e5a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get DER-encoded pktlab certificate bytes from loaded pktlab certificate struct.  <a href="pktlab_8h.html#a9593d93f15ad31ed06951a05c7c8e5a9">More...</a><br /></td></tr>
<tr class="separator:a9593d93f15ad31ed06951a05c7c8e5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab323a06486397ae2c1548ab02d41c07b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#ab323a06486397ae2c1548ab02d41c07b">pktlab_decode_certificate</a> (const struct <a class="el" href="structpktlab__certificate.html">pktlab_certificate</a> *cert, const struct <a class="el" href="structpktlab__publickey.html">pktlab_publickey</a> *signkey, struct <a class="el" href="structpktlab__decoded__certificate.html">pktlab_decoded_certificate</a> **decoded_cert)</td></tr>
<tr class="memdesc:ab323a06486397ae2c1548ab02d41c07b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode pktlab certificate information from loaded pktlab certificate struct.  <a href="pktlab_8h.html#ab323a06486397ae2c1548ab02d41c07b">More...</a><br /></td></tr>
<tr class="separator:ab323a06486397ae2c1548ab02d41c07b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a9edef5aa6e7663fc0317aa66d70c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a09a9edef5aa6e7663fc0317aa66d70c3">pktlab_decode_cert_detail</a> (const struct <a class="el" href="structpktlab__certificate.html">pktlab_certificate</a> *cert, const struct <a class="el" href="structpktlab__publickey.html">pktlab_publickey</a> *signkey, struct <a class="el" href="structpktlab__cert__detail.html">pktlab_cert_detail</a> **ptr)</td></tr>
<tr class="memdesc:a09a9edef5aa6e7663fc0317aa66d70c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode pktlab certificate detail information from loaded pktlab certificate struct.  <a href="pktlab_8h.html#a09a9edef5aa6e7663fc0317aa66d70c3">More...</a><br /></td></tr>
<tr class="separator:a09a9edef5aa6e7663fc0317aa66d70c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ad8bfcedd3681b33bb7b119a22b185"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a10ad8bfcedd3681b33bb7b119a22b185">pktlab_decoded_cert_get_cert_type</a> (const struct <a class="el" href="structpktlab__decoded__certificate.html">pktlab_decoded_certificate</a> *decoded_cert, enum <a class="el" href="pktlab_8h.html#ac9eddf82925b672a4f40f4428e151be0">pktlab_cert_type</a> *cert_type)</td></tr>
<tr class="memdesc:a10ad8bfcedd3681b33bb7b119a22b185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pktlab certificate type from decoded pktlab certificate information.  <a href="pktlab_8h.html#a10ad8bfcedd3681b33bb7b119a22b185">More...</a><br /></td></tr>
<tr class="separator:a10ad8bfcedd3681b33bb7b119a22b185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9554cecbdd1ed9fc353edb343190b09"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#ab9554cecbdd1ed9fc353edb343190b09">pktlab_verify_certificate_signature</a> (const struct <a class="el" href="structpktlab__certificate.html">pktlab_certificate</a> *cert, const struct <a class="el" href="structpktlab__publickey.html">pktlab_publickey</a> *signkey)</td></tr>
<tr class="memdesc:ab9554cecbdd1ed9fc353edb343190b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify the pktlab certificate signature.  <a href="pktlab_8h.html#ab9554cecbdd1ed9fc353edb343190b09">More...</a><br /></td></tr>
<tr class="separator:ab9554cecbdd1ed9fc353edb343190b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334e9a28204e1746db431cf9224a95f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a334e9a28204e1746db431cf9224a95f1">pktlab_cleanup_cert</a> (struct <a class="el" href="structpktlab__certificate.html">pktlab_certificate</a> *cert)</td></tr>
<tr class="memdesc:a334e9a28204e1746db431cf9224a95f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an allocated pktlab certificate struct.  <a href="pktlab_8h.html#a334e9a28204e1746db431cf9224a95f1">More...</a><br /></td></tr>
<tr class="separator:a334e9a28204e1746db431cf9224a95f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b11cc45f5c62dd146b8bd3c62220a2b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a8b11cc45f5c62dd146b8bd3c62220a2b">pktlab_cleanup_detail_ls</a> (struct <a class="el" href="structpktlab__cert__detail.html">pktlab_cert_detail</a> *head)</td></tr>
<tr class="memdesc:a8b11cc45f5c62dd146b8bd3c62220a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the chain of allocated pktlab certificate detail structs.  <a href="pktlab_8h.html#a8b11cc45f5c62dd146b8bd3c62220a2b">More...</a><br /></td></tr>
<tr class="separator:a8b11cc45f5c62dd146b8bd3c62220a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4beefc3893f9e66d024e76f2820a873b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a4beefc3893f9e66d024e76f2820a873b">pktlab_cert_type_name</a> (int cert_type)</td></tr>
<tr class="memdesc:a4beefc3893f9e66d024e76f2820a873b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pktlab certificate type string from pktlab certificate type value.  <a href="pktlab_8h.html#a4beefc3893f9e66d024e76f2820a873b">More...</a><br /></td></tr>
<tr class="separator:a4beefc3893f9e66d024e76f2820a873b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac974cbd7d56c4e288887d92d5d160ed7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#ac974cbd7d56c4e288887d92d5d160ed7">pktlab_cert_type_name_to_id</a> (const char *name)</td></tr>
<tr class="memdesc:ac974cbd7d56c4e288887d92d5d160ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pktlab certificate type value from pktlab certificate type string.  <a href="pktlab_8h.html#ac974cbd7d56c4e288887d92d5d160ed7">More...</a><br /></td></tr>
<tr class="separator:ac974cbd7d56c4e288887d92d5d160ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f902f2e335c6c293456682ce0e64ee5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a7f902f2e335c6c293456682ce0e64ee5">pktlab_get_agent_key</a> (const struct <a class="el" href="structpktlab__certificate.html">pktlab_certificate</a> *agent_cert, uint8_t *agent_pubkey)</td></tr>
<tr class="memdesc:a7f902f2e335c6c293456682ce0e64ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pktlab agent certificate subject (signee) public key.  <a href="pktlab_8h.html#a7f902f2e335c6c293456682ce0e64ee5">More...</a><br /></td></tr>
<tr class="separator:a7f902f2e335c6c293456682ce0e64ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac162f6029387610678b4ccb6bd05e546"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#ac162f6029387610678b4ccb6bd05e546">pktlab_verify_cert_chain</a> (int auth_mode, struct <a class="el" href="structpktlab__certificate.html">pktlab_certificate</a> **cert_ls, struct <a class="el" href="structpktlab__publickey.html">pktlab_publickey</a> **root_ls, struct <a class="el" href="structpktlab__certificate.html">pktlab_certificate</a> ***verified_cert_ls, uint_fast32_t certnum, uint_fast32_t rootnum, uint_fast32_t *verified_certnum, uint_fast32_t *used_root_indx)</td></tr>
<tr class="memdesc:ac162f6029387610678b4ccb6bd05e546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify pktlab certificate chain.  <a href="pktlab_8h.html#ac162f6029387610678b4ccb6bd05e546">More...</a><br /></td></tr>
<tr class="separator:ac162f6029387610678b4ccb6bd05e546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b83aa47fcdd78a54849319e1a3f0db"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a96b83aa47fcdd78a54849319e1a3f0db">pktlab_parse_endpoint_rep_cert_chain</a> (struct <a class="el" href="structpktlab__certificate.html">pktlab_certificate</a> **cert_ls, uint_fast32_t certnum, const uint8_t *endpoint_key, struct <a class="el" href="structpktlab__publickey.html">pktlab_publickey</a> *root_eop_key, uint8_t **subable_channels, uint_fast32_t *channelnum)</td></tr>
<tr class="memdesc:a96b83aa47fcdd78a54849319e1a3f0db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse pktlab endpoint representation privilege certificate chain for subscribable channel information.  <a href="pktlab_8h.html#a96b83aa47fcdd78a54849319e1a3f0db">More...</a><br /></td></tr>
<tr class="separator:a96b83aa47fcdd78a54849319e1a3f0db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a36ddf5c4621ce092f54e95a570d55"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a62a36ddf5c4621ce092f54e95a570d55">pktlab_parse_controller_exp_cert_chain</a> (struct <a class="el" href="structpktlab__certificate.html">pktlab_certificate</a> **cert_ls, uint_fast32_t certnum, const uint8_t *controller_key, struct <a class="el" href="structpktlab__publickey.html">pktlab_publickey</a> *trusted_eop_key, struct <a class="el" href="structpktlab__cert__detail.html">pktlab_cert_detail</a> **cert_details, uint8_t *subable_channel)</td></tr>
<tr class="memdesc:a62a36ddf5c4621ce092f54e95a570d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse pktlab controller experiment privilege certificate chain for subscribable channel and experiment privilege information.  <a href="pktlab_8h.html#a62a36ddf5c4621ce092f54e95a570d55">More...</a><br /></td></tr>
<tr class="separator:a62a36ddf5c4621ce092f54e95a570d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7a896804739609b1965f92be8db014"><td class="memItemLeft" align="right" valign="top">static uint_fast8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#ade7a896804739609b1965f92be8db014">pktlab_get8</a> (const void *ptr)</td></tr>
<tr class="memdesc:ade7a896804739609b1965f92be8db014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get 8-bit unsigned integer from byte array.  <a href="pktlab_8h.html#ade7a896804739609b1965f92be8db014">More...</a><br /></td></tr>
<tr class="separator:ade7a896804739609b1965f92be8db014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20000535214a295139bc12b28b439bbe"><td class="memItemLeft" align="right" valign="top"><a id="a20000535214a295139bc12b28b439bbe"></a>
static uint_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_get16b</b> (const void *ptr)</td></tr>
<tr class="separator:a20000535214a295139bc12b28b439bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af021c5f03241b5e63bd379fc34e1a532"><td class="memItemLeft" align="right" valign="top"><a id="af021c5f03241b5e63bd379fc34e1a532"></a>
static uint_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_get16l</b> (const void *ptr)</td></tr>
<tr class="separator:af021c5f03241b5e63bd379fc34e1a532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c277f08c420b3f3609cb1a785e2c6e6"><td class="memItemLeft" align="right" valign="top"><a id="a6c277f08c420b3f3609cb1a785e2c6e6"></a>
static uint_fast32_t&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_get24b</b> (const void *ptr)</td></tr>
<tr class="separator:a6c277f08c420b3f3609cb1a785e2c6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7392de8db695f65bdfc38a2d33749efb"><td class="memItemLeft" align="right" valign="top"><a id="a7392de8db695f65bdfc38a2d33749efb"></a>
static uint_fast32_t&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_get24l</b> (const void *ptr)</td></tr>
<tr class="separator:a7392de8db695f65bdfc38a2d33749efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600961ce81e6de7203049ec913364807"><td class="memItemLeft" align="right" valign="top"><a id="a600961ce81e6de7203049ec913364807"></a>
static uint_fast32_t&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_get32b</b> (const void *ptr)</td></tr>
<tr class="separator:a600961ce81e6de7203049ec913364807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3af0367a21a0cfcea3e1752477856d"><td class="memItemLeft" align="right" valign="top"><a id="acf3af0367a21a0cfcea3e1752477856d"></a>
static uint_fast32_t&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_get32l</b> (const void *ptr)</td></tr>
<tr class="separator:acf3af0367a21a0cfcea3e1752477856d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb42abc754f784a0c71c63530ce634dd"><td class="memItemLeft" align="right" valign="top"><a id="afb42abc754f784a0c71c63530ce634dd"></a>
static uint_fast64_t&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_get64b</b> (const void *ptr)</td></tr>
<tr class="separator:afb42abc754f784a0c71c63530ce634dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97c53622e55ac47f455387b93fc6023"><td class="memItemLeft" align="right" valign="top"><a id="aa97c53622e55ac47f455387b93fc6023"></a>
static uint_fast64_t&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_get64l</b> (const void *ptr)</td></tr>
<tr class="separator:aa97c53622e55ac47f455387b93fc6023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe48b122672a01f75f928b371d4456ce"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#afe48b122672a01f75f928b371d4456ce">pktlab_set8</a> (void *ptr, uint_fast8_t val)</td></tr>
<tr class="memdesc:afe48b122672a01f75f928b371d4456ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set 8-bit unsigned integer to byte array.  <a href="pktlab_8h.html#afe48b122672a01f75f928b371d4456ce">More...</a><br /></td></tr>
<tr class="separator:afe48b122672a01f75f928b371d4456ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71713785eb9428327a60efb30e10dc94"><td class="memItemLeft" align="right" valign="top"><a id="a71713785eb9428327a60efb30e10dc94"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_set16b</b> (void *ptr, uint_fast16_t val)</td></tr>
<tr class="separator:a71713785eb9428327a60efb30e10dc94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd56a56c77e527ae0626cf9c6fcfcfce"><td class="memItemLeft" align="right" valign="top"><a id="abd56a56c77e527ae0626cf9c6fcfcfce"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_set16l</b> (void *ptr, uint_fast16_t val)</td></tr>
<tr class="separator:abd56a56c77e527ae0626cf9c6fcfcfce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94dec7f319954e7e28326eae3a708125"><td class="memItemLeft" align="right" valign="top"><a id="a94dec7f319954e7e28326eae3a708125"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_set24b</b> (void *ptr, uint_fast32_t val)</td></tr>
<tr class="separator:a94dec7f319954e7e28326eae3a708125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa151ca9e16baf9e0828cad0aa3b2fb"><td class="memItemLeft" align="right" valign="top"><a id="a8aa151ca9e16baf9e0828cad0aa3b2fb"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_set24l</b> (void *ptr, uint_fast32_t val)</td></tr>
<tr class="separator:a8aa151ca9e16baf9e0828cad0aa3b2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8104aae1c6172007aab9111dd6bffb1"><td class="memItemLeft" align="right" valign="top"><a id="ae8104aae1c6172007aab9111dd6bffb1"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_set32b</b> (void *ptr, uint_fast32_t val)</td></tr>
<tr class="separator:ae8104aae1c6172007aab9111dd6bffb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9264ddb2bdad6eb145bb17a41e62adc2"><td class="memItemLeft" align="right" valign="top"><a id="a9264ddb2bdad6eb145bb17a41e62adc2"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_set32l</b> (void *ptr, uint_fast32_t val)</td></tr>
<tr class="separator:a9264ddb2bdad6eb145bb17a41e62adc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30736178742240c5d21d33d8251c7e07"><td class="memItemLeft" align="right" valign="top"><a id="a30736178742240c5d21d33d8251c7e07"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_set64b</b> (void *ptr, uint_fast64_t val)</td></tr>
<tr class="separator:a30736178742240c5d21d33d8251c7e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafded5976413ed4865bb5f31b02a70d3"><td class="memItemLeft" align="right" valign="top"><a id="aafded5976413ed4865bb5f31b02a70d3"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_set64l</b> (void *ptr, uint_fast64_t val)</td></tr>
<tr class="separator:aafded5976413ed4865bb5f31b02a70d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366dafc33b44301d8926d5e947883959"><td class="memItemLeft" align="right" valign="top">static uint_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a366dafc33b44301d8926d5e947883959">pktlab_hton16</a> (uint_fast16_t x)</td></tr>
<tr class="memdesc:a366dafc33b44301d8926d5e947883959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert 16-bit unsigned integer from host byte order to network byte order.  <a href="pktlab_8h.html#a366dafc33b44301d8926d5e947883959">More...</a><br /></td></tr>
<tr class="separator:a366dafc33b44301d8926d5e947883959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c8fff54219135e087dd33939bc1420"><td class="memItemLeft" align="right" valign="top"><a id="af3c8fff54219135e087dd33939bc1420"></a>
static uint_fast32_t&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_hton32</b> (uint_fast32_t x)</td></tr>
<tr class="separator:af3c8fff54219135e087dd33939bc1420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2956f911067407ec273e57aa4a63fe"><td class="memItemLeft" align="right" valign="top"><a id="abf2956f911067407ec273e57aa4a63fe"></a>
static uint_fast64_t&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_hton64</b> (uint_fast64_t x)</td></tr>
<tr class="separator:abf2956f911067407ec273e57aa4a63fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3056780cc676ee6614e10fe719d25c"><td class="memItemLeft" align="right" valign="top"><a id="a1e3056780cc676ee6614e10fe719d25c"></a>
static uint_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_ntoh16</b> (uint_fast16_t x)</td></tr>
<tr class="separator:a1e3056780cc676ee6614e10fe719d25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dae5d527ea8d4575d288018c56552f9"><td class="memItemLeft" align="right" valign="top"><a id="a5dae5d527ea8d4575d288018c56552f9"></a>
static uint_fast32_t&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_ntoh32</b> (uint_fast32_t x)</td></tr>
<tr class="separator:a5dae5d527ea8d4575d288018c56552f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740b462c632d555c25d82d95e969a1a3"><td class="memItemLeft" align="right" valign="top"><a id="a740b462c632d555c25d82d95e969a1a3"></a>
static uint_fast64_t&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_ntoh64</b> (uint_fast64_t x)</td></tr>
<tr class="separator:a740b462c632d555c25d82d95e969a1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18b8c8e2d5fd29965550720f868c168"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#ad18b8c8e2d5fd29965550720f868c168">pktlab_getbit8</a> (uint_fast8_t bits, uint_fast8_t pos)</td></tr>
<tr class="memdesc:ad18b8c8e2d5fd29965550720f868c168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get bit from unsigned integer at bit position.  <a href="pktlab_8h.html#ad18b8c8e2d5fd29965550720f868c168">More...</a><br /></td></tr>
<tr class="separator:ad18b8c8e2d5fd29965550720f868c168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f89eeeab5e16fe3befa83e09de16a8"><td class="memItemLeft" align="right" valign="top"><a id="a08f89eeeab5e16fe3befa83e09de16a8"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_getbit16</b> (uint_fast16_t bits, uint_fast8_t pos)</td></tr>
<tr class="separator:a08f89eeeab5e16fe3befa83e09de16a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368816226d47dd7b361c47e69843bf07"><td class="memItemLeft" align="right" valign="top"><a id="a368816226d47dd7b361c47e69843bf07"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_getbit32</b> (uint_fast32_t bits, uint_fast8_t pos)</td></tr>
<tr class="separator:a368816226d47dd7b361c47e69843bf07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16172abf66d4def51d6abf3b0a5ae4b"><td class="memItemLeft" align="right" valign="top"><a id="ac16172abf66d4def51d6abf3b0a5ae4b"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_getbit64</b> (uint_fast64_t bits, uint_fast8_t pos)</td></tr>
<tr class="separator:ac16172abf66d4def51d6abf3b0a5ae4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97605a8c344ea996080c7fb47f6e3139"><td class="memItemLeft" align="right" valign="top">static uint_fast8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a97605a8c344ea996080c7fb47f6e3139">pktlab_setbit8</a> (uint_fast8_t bits, uint_fast8_t pos)</td></tr>
<tr class="memdesc:a97605a8c344ea996080c7fb47f6e3139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bit in unsigned integer at bit position.  <a href="pktlab_8h.html#a97605a8c344ea996080c7fb47f6e3139">More...</a><br /></td></tr>
<tr class="separator:a97605a8c344ea996080c7fb47f6e3139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac872e6241b863aea863c76c170b83d17"><td class="memItemLeft" align="right" valign="top"><a id="ac872e6241b863aea863c76c170b83d17"></a>
static uint_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_setbit16</b> (uint_fast16_t bits, uint_fast8_t pos)</td></tr>
<tr class="separator:ac872e6241b863aea863c76c170b83d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37921c3e0ea5803098ac04fe14d11f1"><td class="memItemLeft" align="right" valign="top"><a id="ac37921c3e0ea5803098ac04fe14d11f1"></a>
static uint_fast32_t&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_setbit32</b> (uint_fast32_t bits, uint_fast8_t pos)</td></tr>
<tr class="separator:ac37921c3e0ea5803098ac04fe14d11f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5810584b7028ac27d43f72635e29b0b"><td class="memItemLeft" align="right" valign="top"><a id="ad5810584b7028ac27d43f72635e29b0b"></a>
static uint_fast64_t&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_setbit64</b> (uint_fast64_t bits, uint_fast8_t pos)</td></tr>
<tr class="separator:ad5810584b7028ac27d43f72635e29b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425a3a4213d76d8f25c223780b0dcb8a"><td class="memItemLeft" align="right" valign="top">static uint_fast8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pktlab_8h.html#a425a3a4213d76d8f25c223780b0dcb8a">pktlab_clrbit8</a> (uint_fast8_t bits, uint_fast8_t pos)</td></tr>
<tr class="memdesc:a425a3a4213d76d8f25c223780b0dcb8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear bit in unsigned integer at bit position.  <a href="pktlab_8h.html#a425a3a4213d76d8f25c223780b0dcb8a">More...</a><br /></td></tr>
<tr class="separator:a425a3a4213d76d8f25c223780b0dcb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37fd7374e07c2ae9f4ef02b01df7120"><td class="memItemLeft" align="right" valign="top"><a id="ac37fd7374e07c2ae9f4ef02b01df7120"></a>
static uint_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_clrbit16</b> (uint_fast16_t bits, uint_fast8_t pos)</td></tr>
<tr class="separator:ac37fd7374e07c2ae9f4ef02b01df7120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226abbc748f5a03dffaf1509e8a1340b"><td class="memItemLeft" align="right" valign="top"><a id="a226abbc748f5a03dffaf1509e8a1340b"></a>
static uint_fast32_t&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_clrbit32</b> (uint_fast32_t bits, uint_fast8_t pos)</td></tr>
<tr class="separator:a226abbc748f5a03dffaf1509e8a1340b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e31410f1bac425b96f85e6980e3389a"><td class="memItemLeft" align="right" valign="top"><a id="a5e31410f1bac425b96f85e6980e3389a"></a>
static uint_fast64_t&#160;</td><td class="memItemRight" valign="bottom"><b>pktlab_clrbit64</b> (uint_fast64_t bits, uint_fast8_t pos)</td></tr>
<tr class="separator:a5e31410f1bac425b96f85e6980e3389a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>General utilities for pktlab. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="af670b820e48b24237b89be83c7b4d3ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af670b820e48b24237b89be83c7b4d3ff">&#9670;&nbsp;</a></span>PKTLAB_FILTER_DIGEST_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKTLAB_FILTER_DIGEST_LEN&#160;&#160;&#160;PKTLAB_SHA256_DIGEST_LEN</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pktlab filter program digest length. </p>
<p>In pktlab, the filter program digest of some filter program is the SHA256 hash of the filter program bytes. </p>

</div>
</div>
<a id="abb65359f0d7ebfe825501b474a737d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb65359f0d7ebfe825501b474a737d4d">&#9670;&nbsp;</a></span>PKTLAB_IP4_PROTO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKTLAB_IP4_PROTO&#160;&#160;&#160;0x4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defined IPv4 protocol family value. </p>
<p>For setting the "family" fields in the <a class="el" href="structpktlab__message.html" title="Structure for storing the decoded form of pktlab messages.">pktlab_message</a> struct </p>

</div>
</div>
<a id="a48014a171001ff1db03930d3b01e033c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48014a171001ff1db03930d3b01e033c">&#9670;&nbsp;</a></span>PKTLAB_IP6_PROTO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKTLAB_IP6_PROTO&#160;&#160;&#160;0x6</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defined IPv6 protocol family value. </p>
<p>For setting the "family" fields in the <a class="el" href="structpktlab__message.html" title="Structure for storing the decoded form of pktlab messages.">pktlab_message</a> struct </p>

</div>
</div>
<a id="ab49742fc9f57d4109040fdf1a011de7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49742fc9f57d4109040fdf1a011de7d">&#9670;&nbsp;</a></span>PKTLAB_KEYID_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKTLAB_KEYID_LEN&#160;&#160;&#160;PKTLAB_SHA256_DIGEST_LEN</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Key identifier length for pktlab keys in bytes. </p>
<p>The key identifier for a pktlab key is the SHA-256 checksum of the pktlab key raw public key. PKTLAB_KEYID_LEN is thus the length of a SHA-256 checksum. </p>

</div>
</div>
<a id="ab336cc7b06ec9ed6b6db7c64fb0ffec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab336cc7b06ec9ed6b6db7c64fb0ffec0">&#9670;&nbsp;</a></span>PKTLAB_MONITOR_DIGEST_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKTLAB_MONITOR_DIGEST_LEN&#160;&#160;&#160;PKTLAB_SHA256_DIGEST_LEN</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pktlab monitor program digest length. </p>
<p>In pktlab, the monitor program digest of some monitor program is the SHA256 hash of the monitor program bytes. </p>

</div>
</div>
<a id="a3412d3e3fe79e6b706043cbdaf5ef28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3412d3e3fe79e6b706043cbdaf5ef28f">&#9670;&nbsp;</a></span>PKTLAB_NCTL_TCP_FIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKTLAB_NCTL_TCP_FIN&#160;&#160;&#160;0x1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defined nctl TCP fin command. </p>
<p>For setting the nctl message "command" field in the <a class="el" href="structpktlab__message.html" title="Structure for storing the decoded form of pktlab messages.">pktlab_message</a> struct. <br  />
The command requests the endpoint to shutdown the writing end of some TCP socket. </p>

</div>
</div>
<a id="a05c03ad73951df5c59a4c31afcc90237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05c03ad73951df5c59a4c31afcc90237">&#9670;&nbsp;</a></span>PKTLAB_PRIVATEKEY_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKTLAB_PRIVATEKEY_LEN&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raw private key length for pktlab keys in bytes. </p>
<p>I.e. Raw Ed25519 private key length. </p>

</div>
</div>
<a id="ac06a8648c5bd937e965b2ad64e020b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac06a8648c5bd937e965b2ad64e020b48">&#9670;&nbsp;</a></span>PKTLAB_PUBLICKEY_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKTLAB_PUBLICKEY_LEN&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raw public key length for pktlab keys in bytes. </p>
<p>I.e. Raw Ed25519 public key length. </p>

</div>
</div>
<a id="a87646191b516860e3f4f23aacf35596c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87646191b516860e3f4f23aacf35596c">&#9670;&nbsp;</a></span>PKTLAB_RAW_PROTO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKTLAB_RAW_PROTO&#160;&#160;&#160;0x00</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defined raw socket protocol value. </p>
<p>For setting the "proto" fields in the <a class="el" href="structpktlab__message.html" title="Structure for storing the decoded form of pktlab messages.">pktlab_message</a> struct </p>

</div>
</div>
<a id="a58765601952334f2a1df7eda84936566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58765601952334f2a1df7eda84936566">&#9670;&nbsp;</a></span>PKTLAB_SIGNATURE_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKTLAB_SIGNATURE_LEN&#160;&#160;&#160;PKTLAB_ED25519_SIG_LEN</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raw signature length for pktlab keys in bytes. </p>
<p>I.e. Raw Ed25519 signature length. </p>

</div>
</div>
<a id="a51c0fac40037af8b910207a6ba40471a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c0fac40037af8b910207a6ba40471a">&#9670;&nbsp;</a></span>PKTLAB_TCP_PROTO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKTLAB_TCP_PROTO&#160;&#160;&#160;0x06</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defined TCP socket protocol value. </p>
<p>For setting the "proto" fields in the <a class="el" href="structpktlab__message.html" title="Structure for storing the decoded form of pktlab messages.">pktlab_message</a> struct </p>

</div>
</div>
<a id="a58bba85c64bbbcbb38e5d72287560fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58bba85c64bbbcbb38e5d72287560fba">&#9670;&nbsp;</a></span>PKTLAB_UDP_PROTO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKTLAB_UDP_PROTO&#160;&#160;&#160;0x11</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defined UDP socket protocol value. </p>
<p>For setting the "proto" fields in the <a class="el" href="structpktlab__message.html" title="Structure for storing the decoded form of pktlab messages.">pktlab_message</a> struct </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a89fe04b2d2e1cd53344b3d0e8b0c7789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89fe04b2d2e1cd53344b3d0e8b0c7789">&#9670;&nbsp;</a></span>pktlab_read_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ssize_t(* pktlab_read_t) (void *aux, void *buf, size_t buflen)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function pointer type for reader read function. </p>
<ul>
<li>The expected behavior of a pktlab_read_t function: per function call with valid input, the function should either (1) read in x \in [1, buflen] consecutive bytes and place them in buf in order from the start of buf (returning the number of bytes read), (2) return 0 for EOF, or (3) return a negative value for other failures (potentially setting errno). If no byte is read due to the system being busy (e.g. read would block), the function should set errno to EAGAIN or EWOULDBLOCK. If no byte is read due to signal interruption, the function should set errno to EINTR. </li>
</ul>

</div>
</div>
<a id="ae9515e3477c7b07d3cf086e3a3e463c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9515e3477c7b07d3cf086e3a3e463c1">&#9670;&nbsp;</a></span>pktlab_time_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint64_t <a class="el" href="pktlab_8h.html#ae9515e3477c7b07d3cf086e3a3e463c1">pktlab_time_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variable type for pktlab time. </p>
<p>Note pktlab time is in pktlab ticks (1 pktlab tick = 1 nanosecond) from the Unix Epoch. </p>

</div>
</div>
<a id="a53f306929ea68ec41259ed659a72134b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f306929ea68ec41259ed659a72134b">&#9670;&nbsp;</a></span>pktlab_write_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ssize_t(* pktlab_write_t) (void *aux, const void *buf, size_t nbyte)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function pointer type for writer write function. </p>
<ul>
<li>The expected behavior of a pktlab_write_t function: per function call with valid input, the function should either send out x \in [1, nbyte] bytes stored in buf in order from the start of buf (returning the number of bytes sent) or fail with a negative return value (potentially setting errno). If no byte is sent due to the system being busy (e.g. write would block), the function should set errno to EAGAIN or EWOULDBLOCK. If no byte is sent due to signal interruption, the function should set errno to EINTR. </li>
</ul>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a9a3fe0e0f5443851e1a9302772b40b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a3fe0e0f5443851e1a9302772b40b69">&#9670;&nbsp;</a></span>pktlab_auth_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="pktlab_8h.html#a9a3fe0e0f5443851e1a9302772b40b69">pktlab_auth_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pktlab certificate chain verification mode values. </p>
<ul>
<li>PKTLAB_AUTH_AGENT is used for authentication between broker and controller/endpoint (both directions). </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9a3fe0e0f5443851e1a9302772b40b69a2ee445896fff4561c088014085c029ab"></a>PKTLAB_CONTROLLER_AUTH_ENDPOINT&#160;</td><td class="fielddoc"><p>Controller authenticate endpoint case. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9a3fe0e0f5443851e1a9302772b40b69a5a8bc5276c6e269e729075dcd5790975"></a>PKTLAB_ENDPOINT_AUTH_CONTROLLER&#160;</td><td class="fielddoc"><p>Endpoint authenticate controller case. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9a3fe0e0f5443851e1a9302772b40b69a0a0e2092d9d988564853b09041c9e332"></a>PKTLAB_AUTH_AGENT&#160;</td><td class="fielddoc"><p>Agent authentication case. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9a3fe0e0f5443851e1a9302772b40b69a7e3e4e0e3f5947f9f7d11e9c5a891bd2"></a>PKTLAB_NO_VERIFY&#160;</td><td class="fielddoc"><p>No verify case (accept all certificates and return them; USE AT YOUR OWN RISK!) </p>
</td></tr>
</table>

</div>
</div>
<a id="abd8c7b5f58a51788e8ee06ca5a1490f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8c7b5f58a51788e8ee06ca5a1490f4">&#9670;&nbsp;</a></span>pktlab_decode_rst</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="pktlab_8h.html#abd8c7b5f58a51788e8ee06ca5a1490f4">pktlab_decode_rst</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pktlab certificate decoding result values. </p>
<p>Returned by <a class="el" href="pktlab_8h.html#ab323a06486397ae2c1548ab02d41c07b" title="Decode pktlab certificate information from loaded pktlab certificate struct.">pktlab_decode_certificate()</a> to indicate pktlab certificate decoding result. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abd8c7b5f58a51788e8ee06ca5a1490f4aca9c9b857b8348f67347b7d3eb35fa4b"></a>PKTLAB_DECODE_SUCCESS&#160;</td><td class="fielddoc"><p>Success. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd8c7b5f58a51788e8ee06ca5a1490f4a49e02e998e8cb40766d3bcc8d57e0982"></a>PKTLAB_DECODE_INVAL&#160;</td><td class="fielddoc"><p>Bad arguments passed to decoding function </p>
</td></tr>
<tr><td class="fieldname"><a id="abd8c7b5f58a51788e8ee06ca5a1490f4a15553def53746a764633074e06b2c02c"></a>PKTLAB_DECODE_BAD_SIGALG&#160;</td><td class="fielddoc"><p>Not using Ed25519 signature algorithm. Note this is used for both signed and unsigned sigalg. <br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="abd8c7b5f58a51788e8ee06ca5a1490f4ac2917a8c12f8f7097fc56feabb67397b"></a>PKTLAB_DECODE_BAD_SIGNATURE&#160;</td><td class="fielddoc"><p>Bad cert signature. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd8c7b5f58a51788e8ee06ca5a1490f4a484660c54864d5612472fcadb98d6c24"></a>PKTLAB_DECODE_BAD_X509_VER&#160;</td><td class="fielddoc"><p>Bad X509 ver. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd8c7b5f58a51788e8ee06ca5a1490f4af4587f5f1e0d78d91cf493effd455b44"></a>PKTLAB_DECODE_USING_UNUSED_FIELD&#160;</td><td class="fielddoc"><p>Cert contains fields that should not be used. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd8c7b5f58a51788e8ee06ca5a1490f4aefd39c407937e2f5fd2b79f52a80c489"></a>PKTLAB_DECODE_BAD_CERT_TYPE&#160;</td><td class="fielddoc"><p>Bad cert type. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd8c7b5f58a51788e8ee06ca5a1490f4adcb08f4990d4faeb59987c1a67269700"></a>PKTLAB_DECODE_BAD_KEYUSAGE&#160;</td><td class="fielddoc"><p>Bad keyusage. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd8c7b5f58a51788e8ee06ca5a1490f4a82aaf4181957f53d3da9959ed22f742c"></a>PKTLAB_DECODE_BAD_SERIAL&#160;</td><td class="fielddoc"><p>Bad serial. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd8c7b5f58a51788e8ee06ca5a1490f4a47cae20be6533da201c73dcd716895df"></a>PKTLAB_DECODE_BAD_VALIDITY&#160;</td><td class="fielddoc"><p>Bad validity (i.e. not_before/not_after). </p>
</td></tr>
<tr><td class="fieldname"><a id="abd8c7b5f58a51788e8ee06ca5a1490f4a55d4e414653f2800e18596caabc487b0"></a>PKTLAB_DECODE_BAD_SUBJ_PUBKEY&#160;</td><td class="fielddoc"><p>Bad subject public key. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd8c7b5f58a51788e8ee06ca5a1490f4add6f91f303cc3e34f19798a645ed49af"></a>PKTLAB_DECODE_BAD_AID&#160;</td><td class="fielddoc"><p>Bad authority key identifier. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd8c7b5f58a51788e8ee06ca5a1490f4ac8a5d1bc79cdf57496d8fa4e6fe31509"></a>PKTLAB_DECODE_BAD_SID&#160;</td><td class="fielddoc"><p>Bad subject key identifier. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd8c7b5f58a51788e8ee06ca5a1490f4a72b6b91315714d4cefe5f1df672e36b5"></a>PKTLAB_DECODE_BAD_BC&#160;</td><td class="fielddoc"><p>Bad basic constraints. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd8c7b5f58a51788e8ee06ca5a1490f4af2ca974474df7c013395ef76e2a861d8"></a>PKTLAB_DECODE_BAD_CERT_INFO&#160;</td><td class="fielddoc"><p>Bad pktlab certificate information. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd8c7b5f58a51788e8ee06ca5a1490f4a75ddc1ef48cec06fc45efcec103dc525"></a>PKTLAB_DECODE_BAD_CERT_LIMIT&#160;</td><td class="fielddoc"><p>Bad pktlab certificate limit. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd8c7b5f58a51788e8ee06ca5a1490f4af4d9e5d3756d2d8254be74516be2a5b7"></a>PKTLAB_DECODE_BAD_PRIORITY&#160;</td><td class="fielddoc"><p>Bad pktlab priority string. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd8c7b5f58a51788e8ee06ca5a1490f4a9a35d523b9b86b43d78e81e958d733d3"></a>PKTLAB_DECODE_BAD_MONITOR_DIGESTS&#160;</td><td class="fielddoc"><p>Bad pktlab monitor digests. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd8c7b5f58a51788e8ee06ca5a1490f4a15e0061da6d977b93462fffabe9406da"></a>PKTLAB_DECODE_BAD_DEL_TYPE&#160;</td><td class="fielddoc"><p>Bad pktlab delegation type. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd8c7b5f58a51788e8ee06ca5a1490f4a52ae4573373542449bbf3c91d518b749"></a>PKTLAB_DECODE_BAD_AUX_INFO&#160;</td><td class="fielddoc"><p>Bad pktlab auxiliary information. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd8c7b5f58a51788e8ee06ca5a1490f4a6284f23db5e92cd134738ace48316af4"></a>PKTLAB_DECODE_BAD_CERT_DESC&#160;</td><td class="fielddoc"><p>Bad pktlab certificate description. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd8c7b5f58a51788e8ee06ca5a1490f4a10f45b088c2d1bf90f03dc9df28342df"></a>PKTLAB_DECODE_BAD_VALID_DEST&#160;</td><td class="fielddoc"><p>Bad pktlab valid destination. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd8c7b5f58a51788e8ee06ca5a1490f4a81bef257e6e39c4f133ac6a684be35df"></a>PKTLAB_DECODE_BAD_SRC_IP_SPOOFING&#160;</td><td class="fielddoc"><p>Bad pktlab source IP spoofing. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd8c7b5f58a51788e8ee06ca5a1490f4a80da5595489426a432f81e5a6dc433c6"></a>PKTLAB_DECODE_BAD_MAX_BURST_RATE&#160;</td><td class="fielddoc"><p>Bad pktlab maximum burst rate. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd8c7b5f58a51788e8ee06ca5a1490f4a52ff628851da438d3b17f1811bb51282"></a>PKTLAB_DECODE_UNKNOWN_FAULT&#160;</td><td class="fielddoc"><p>Unknwon error during decoding. </p>
</td></tr>
</table>

</div>
</div>
<a id="a2e7e374911bec712eb0ae2b4b0ae950a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e7e374911bec712eb0ae2b4b0ae950a">&#9670;&nbsp;</a></span>pktlab_message_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="pktlab_8h.html#a2e7e374911bec712eb0ae2b4b0ae950a">pktlab_message_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pktlab defined message types. </p>
<p>For setting the "type" field in the <a class="el" href="structpktlab__message.html" title="Structure for storing the decoded form of pktlab messages.">pktlab_message</a> struct. </p>

</div>
</div>
<a id="a9013dca3f65366f6834a38b13e8933b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9013dca3f65366f6834a38b13e8933b4">&#9670;&nbsp;</a></span>pktlab_parse_cert_chain_rst</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="pktlab_8h.html#a9013dca3f65366f6834a38b13e8933b4">pktlab_parse_cert_chain_rst</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pktlab certificate chain parsing result values. </p>
<p>Returned by <a class="el" href="pktlab_8h.html#a96b83aa47fcdd78a54849319e1a3f0db" title="Parse pktlab endpoint representation privilege certificate chain for subscribable channel information...">pktlab_parse_endpoint_rep_cert_chain()</a> and <a class="el" href="pktlab_8h.html#a62a36ddf5c4621ce092f54e95a570d55" title="Parse pktlab controller experiment privilege certificate chain for subscribable channel and experimen...">pktlab_parse_controller_exp_cert_chain()</a> to indicate pktlab certificate chain parsing result. </p>

</div>
</div>
<a id="ad49ead2ad49df1700b526ccd019854b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49ead2ad49df1700b526ccd019854b4">&#9670;&nbsp;</a></span>pktlab_prog_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="pktlab_8h.html#ad49ead2ad49df1700b526ccd019854b4">pktlab_prog_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pktlab defined program types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad49ead2ad49df1700b526ccd019854b4aa29cf4ad46e78fe5321871fcd688ac72"></a>PKTLAB_EBPF&#160;</td><td class="fielddoc"><p>Extended BPF </p>
</td></tr>
<tr><td class="fieldname"><a id="ad49ead2ad49df1700b526ccd019854b4a655b6ea8f28516c086aa56775644d2d1"></a>PKTLAB_WASM&#160;</td><td class="fielddoc"><p>WebAssembly </p>
</td></tr>
</table>

</div>
</div>
<a id="abd1908d576437c692d3be8071c75cab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1908d576437c692d3be8071c75cab9">&#9670;&nbsp;</a></span>pktlab_status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="pktlab_8h.html#abd1908d576437c692d3be8071c75cab9">pktlab_status</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pktlab defined errid values. </p>
<p>For setting the "errid" field in the <a class="el" href="structpktlab__message.html" title="Structure for storing the decoded form of pktlab messages.">pktlab_message</a> struct. </p>

</div>
</div>
<a id="a1fd81e57a11c1eb72355c39c6106d166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fd81e57a11c1eb72355c39c6106d166">&#9670;&nbsp;</a></span>pktlab_uri_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="pktlab_8h.html#a1fd81e57a11c1eb72355c39c6106d166">pktlab_uri_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pktlab defined URI types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1fd81e57a11c1eb72355c39c6106d166a4ea0fb6aec1a9b390d67b4f039de2a02"></a>EXP_URI_TYPE&#160;</td><td class="fielddoc"><p>Experiment controller URI type. In URI: "exp" </p>
</td></tr>
<tr><td class="fieldname"><a id="a1fd81e57a11c1eb72355c39c6106d166ade2c3206bfb5d7cb0ca959a22712a385"></a>BROKER_URI_TYPE&#160;</td><td class="fielddoc"><p>Broker URI type. In URI: "broker" </p>
</td></tr>
<tr><td class="fieldname"><a id="a1fd81e57a11c1eb72355c39c6106d166aadf39f2e8a566cc3f6124a8a37f8515f"></a>MALFORMED_URI_TYPE&#160;</td><td class="fielddoc"><p>Malformed/unknown URI type. </p>
</td></tr>
</table>

</div>
</div>
<a id="aed10ca50609b48e4abf6e5356de41bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed10ca50609b48e4abf6e5356de41bee">&#9670;&nbsp;</a></span>pktlab_verify_rst</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="pktlab_8h.html#aed10ca50609b48e4abf6e5356de41bee">pktlab_verify_rst</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pktlab certificate chain verification result values. </p>
<p>Returned by <a class="el" href="pktlab_8h.html#ac162f6029387610678b4ccb6bd05e546" title="Verify pktlab certificate chain.">pktlab_verify_cert_chain()</a> to indicate pktlab certificate chain verification result. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aed10ca50609b48e4abf6e5356de41beeac4823f20f6098c09e901649704cd678a"></a>PKTLAB_VERIFY_SUCCESS&#160;</td><td class="fielddoc"><p>Success. </p>
</td></tr>
<tr><td class="fieldname"><a id="aed10ca50609b48e4abf6e5356de41beea1c84b121e71d7322041e8d7170f11970"></a>PKTLAB_VERIFY_INVAL&#160;</td><td class="fielddoc"><p>Bad arguments passed to verification function. </p>
</td></tr>
<tr><td class="fieldname"><a id="aed10ca50609b48e4abf6e5356de41beea127d41d0ac33de09dee11bdac09f4614"></a>PKTLAB_VERIFY_BAD_CERT&#160;</td><td class="fielddoc"><p>Bad certificate passed (general). </p>
</td></tr>
<tr><td class="fieldname"><a id="aed10ca50609b48e4abf6e5356de41beea0583adde08ac4ae9f976ca325e54c6c9"></a>PKTLAB_VERIFY_NOT_ENOUGH_CERT&#160;</td><td class="fielddoc"><p>Cert chain too short (i.e. passed chain shorter than minimum chain len). </p>
</td></tr>
<tr><td class="fieldname"><a id="aed10ca50609b48e4abf6e5356de41beeaff3239f1f5629068fdc655b36b218855"></a>PKTLAB_VERIFY_TOO_MANY_CERT&#160;</td><td class="fielddoc"><p>Cert chain too long (i.e. passed chain longer than maximum chain len). </p>
</td></tr>
<tr><td class="fieldname"><a id="aed10ca50609b48e4abf6e5356de41beea610a6bf16a92295473abf1ceb4e6a89a"></a>PKTLAB_VERIFY_UNEXPECTED_CERT&#160;</td><td class="fielddoc"><p>Cert with unexpected type appearing in chain. </p>
</td></tr>
<tr><td class="fieldname"><a id="aed10ca50609b48e4abf6e5356de41beea94ec7a80e374018440f09bcb89392553"></a>PKTLAB_VERIFY_EXPIRED_CERT&#160;</td><td class="fielddoc"><p>Cert expired. </p>
</td></tr>
<tr><td class="fieldname"><a id="aed10ca50609b48e4abf6e5356de41beea685deb82a91e9a3d978d090a5087f31b"></a>PKTLAB_VERIFY_NO_MATCHING_SIGN_KEY&#160;</td><td class="fielddoc"><p>Cannot find the signing key for a cert in the cert chain. </p>
</td></tr>
<tr><td class="fieldname"><a id="aed10ca50609b48e4abf6e5356de41beeaa147338b915302515e18c3414b1de050"></a>PKTLAB_VERIFY_PATHLEN_EXCEEDED&#160;</td><td class="fielddoc"><p>Pathlen constraint for a cert exceeded in the chain. </p>
</td></tr>
<tr><td class="fieldname"><a id="aed10ca50609b48e4abf6e5356de41beea1852954873431585827684a5310985f5"></a>PKTLAB_VERIFY_END_OF_PHASES&#160;</td><td class="fielddoc"><p>No more phases left in the checking process. </p>
</td></tr>
<tr><td class="fieldname"><a id="aed10ca50609b48e4abf6e5356de41beeaa00cb333231d3a5788526700b8001bae"></a>PKTLAB_VERIFY_BAD_DEL_TYPE&#160;</td><td class="fielddoc"><p>Privilege delegation cert having incorrect delegation type. </p>
</td></tr>
<tr><td class="fieldname"><a id="aed10ca50609b48e4abf6e5356de41beea15dc090473932746504e31d4a2781ab0"></a>PKTLAB_VERIFY_UNKNOWN_FAULT&#160;</td><td class="fielddoc"><p>Unknown fault in verification function. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4beefc3893f9e66d024e76f2820a873b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4beefc3893f9e66d024e76f2820a873b">&#9670;&nbsp;</a></span>pktlab_cert_type_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* pktlab_cert_type_name </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cert_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pktlab certificate type string from pktlab certificate type value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cert_type</td><td>pktlab certificate type value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a pktlab certificate type string or NULL if undefined cert_type value. </dd></dl>

</div>
</div>
<a id="ac974cbd7d56c4e288887d92d5d160ed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac974cbd7d56c4e288887d92d5d160ed7">&#9670;&nbsp;</a></span>pktlab_cert_type_name_to_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_cert_type_name_to_id </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pktlab certificate type value from pktlab certificate type string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Pointer to a '\0'-terminated pktlab certificate type string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pktlab certificate type value corresponding to name or PKTLAB_CERT_UNKNOWN for undefined pktlab certificate type value. </dd></dl>

</div>
</div>
<a id="a334e9a28204e1746db431cf9224a95f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a334e9a28204e1746db431cf9224a95f1">&#9670;&nbsp;</a></span>pktlab_cleanup_cert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_cleanup_cert </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpktlab__certificate.html">pktlab_certificate</a> *&#160;</td>
          <td class="paramname"><em>cert</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an allocated pktlab certificate struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cert</td><td>Pointer to an allocated pktlab certificate struct to free. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success. &lt; 0 if failed.</dd></dl>
<ul>
<li>Do not call <a class="el" href="pktlab_8h.html#a334e9a28204e1746db431cf9224a95f1" title="Free an allocated pktlab certificate struct.">pktlab_cleanup_cert()</a> again if failed. </li>
</ul>

</div>
</div>
<a id="a8b11cc45f5c62dd146b8bd3c62220a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b11cc45f5c62dd146b8bd3c62220a2b">&#9670;&nbsp;</a></span>pktlab_cleanup_detail_ls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_cleanup_detail_ls </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpktlab__cert__detail.html">pktlab_cert_detail</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the chain of allocated pktlab certificate detail structs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">head</td><td>Pointer to the head of the chain of allocated pktlab certificate detail structs to free. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success. &lt; 0 if failed. </dd></dl>

</div>
</div>
<a id="ab8438bd0e861dcca6190531cee5d3f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8438bd0e861dcca6190531cee5d3f3e">&#9670;&nbsp;</a></span>pktlab_cleanup_privatekey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_cleanup_privatekey </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpktlab__privatekey.html">pktlab_privatekey</a> *&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an allocated pktlab private key struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">k</td><td>Pointer to an allocated pktlab private key struct to free. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success. &lt; 0 if failed.</dd></dl>
<ul>
<li>Do not call <a class="el" href="pktlab_8h.html#ab8438bd0e861dcca6190531cee5d3f3e" title="Free an allocated pktlab private key struct.">pktlab_cleanup_privatekey()</a> again if failed. </li>
</ul>

</div>
</div>
<a id="a5bcd697b77d479b45977f5432e97be28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bcd697b77d479b45977f5432e97be28">&#9670;&nbsp;</a></span>pktlab_cleanup_publickey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_cleanup_publickey </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpktlab__publickey.html">pktlab_publickey</a> *&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an allocated pktlab public key struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">k</td><td>Allocated pktlab public key struct to free. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success. &lt; 0 if failed.</dd></dl>
<ul>
<li>Do not call <a class="el" href="pktlab_8h.html#a5bcd697b77d479b45977f5432e97be28" title="Free an allocated pktlab public key struct.">pktlab_cleanup_publickey()</a> again if failed. </li>
</ul>

</div>
</div>
<a id="a65ac5f5ebe314972be37bdb18887a54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ac5f5ebe314972be37bdb18887a54d">&#9670;&nbsp;</a></span>pktlab_close_reader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pktlab_close_reader </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpktlab__reader.html">pktlab_reader</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close and free pktlab reader struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">r</td><td>Allocated pktlab reader struct to free.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Note reader aux (passed in during <a class="el" href="pktlab_8h.html#ab098bfcd9956999449336ea2d86603d7" title="Get initialized pktlab reader struct.">pktlab_create_reader()</a>) is not freed or closed. </li>
</ul>

</div>
</div>
<a id="a72bb120e12a20032c6ae919cc7a52926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72bb120e12a20032c6ae919cc7a52926">&#9670;&nbsp;</a></span>pktlab_close_writer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pktlab_close_writer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpktlab__writer.html">pktlab_writer</a> *&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close and free pktlab writer struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">w</td><td>Allocated pktlab writer struct to free.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Note writer aux (passed in during <a class="el" href="pktlab_8h.html#a9b21cba7d11c875b5268542c49e6d2a4" title="Get initialized pktlab writer struct.">pktlab_create_writer()</a>) is not freed or closed. </li>
</ul>

</div>
</div>
<a id="a425a3a4213d76d8f25c223780b0dcb8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425a3a4213d76d8f25c223780b0dcb8a">&#9670;&nbsp;</a></span>pktlab_clrbit8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint_fast8_t pktlab_clrbit8 </td>
          <td>(</td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear bit in unsigned integer at bit position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bits</td><td>Target unsigned interger to clear bit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Target bit position (0-indexed). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Clear result.</dd></dl>
<ul>
<li>Note there also exist similar functions (pktlab_clrbitN) that clear bit in larger unsigned integers (N being either 16, 32, or 64).</li>
<li>Clearing bit for pos &gt;= N will be ignored with unchanged bits value returned. </li>
</ul>

</div>
</div>
<a id="ac782909f422cfc761a53fce7069a8660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac782909f422cfc761a53fce7069a8660">&#9670;&nbsp;</a></span>pktlab_create_cert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structpktlab__certificate.html">pktlab_certificate</a>* pktlab_create_cert </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate initialized pktlab certificate struct. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to an allocated initialized pktlab certificate struct.</dd></dl>
<ul>
<li>The allocated pktlab certificate struct should be freed with <a class="el" href="pktlab_8h.html#a334e9a28204e1746db431cf9224a95f1" title="Free an allocated pktlab certificate struct.">pktlab_cleanup_cert()</a>. </li>
</ul>

</div>
</div>
<a id="a9b65a1a8f3339b7b12f17fbbe8ce588e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b65a1a8f3339b7b12f17fbbe8ce588e">&#9670;&nbsp;</a></span>pktlab_create_monrej_result_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structpktlab__message.html">pktlab_message</a>* pktlab_create_monrej_result_message </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>monindx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>monerrid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get fields-set pktlab result message with status PKTLAB_ECTLMONREJ. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Result message errid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">monindx</td><td>The index of the monitor that the result message is for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">monerrid</td><td>The errid of the monitor that the result message is for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated pktlab result message with errid set.</dd></dl>
<ul>
<li>The returned message pointer should be freed with free() in stdlib.h. </li>
</ul>

</div>
</div>
<a id="a4a5591f71ffd1b356cc39dd7658cd42b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a5591f71ffd1b356cc39dd7658cd42b">&#9670;&nbsp;</a></span>pktlab_create_monukn_result_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structpktlab__message.html">pktlab_message</a>* pktlab_create_monukn_result_message </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>monindx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get fields-set pktlab result message with status PKTLAB_ECTLMONUKN. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Result message errid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">monindx</td><td>The index of the monitor that the result message is for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated pktlab result message with errid set.</dd></dl>
<ul>
<li>The returned message pointer should be freed with free() in stdlib.h. </li>
</ul>

</div>
</div>
<a id="a36fa688be315248159d774f84beea8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36fa688be315248159d774f84beea8de">&#9670;&nbsp;</a></span>pktlab_create_privatekey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structpktlab__privatekey.html">pktlab_privatekey</a>* pktlab_create_privatekey </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate initialized pktlab private key struct. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to an allocated initialized pktlab private key struct.</dd></dl>
<ul>
<li>The allocated pktlab private key struct should be freed with <a class="el" href="pktlab_8h.html#ab8438bd0e861dcca6190531cee5d3f3e" title="Free an allocated pktlab private key struct.">pktlab_cleanup_privatekey()</a>. </li>
</ul>

</div>
</div>
<a id="a737dd716edca6ba83b6024db285c14df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a737dd716edca6ba83b6024db285c14df">&#9670;&nbsp;</a></span>pktlab_create_publickey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structpktlab__publickey.html">pktlab_publickey</a>* pktlab_create_publickey </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate initialized pktlab public key struct. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to an allocated initialized pktlab public key struct.</dd></dl>
<ul>
<li>The allocated pktlab public key struct should be freed with <a class="el" href="pktlab_8h.html#a5bcd697b77d479b45977f5432e97be28" title="Free an allocated pktlab public key struct.">pktlab_cleanup_publickey()</a>. </li>
</ul>

</div>
</div>
<a id="ab098bfcd9956999449336ea2d86603d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab098bfcd9956999449336ea2d86603d7">&#9670;&nbsp;</a></span>pktlab_create_reader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structpktlab__reader.html">pktlab_reader</a>* pktlab_create_reader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pktlab_8h.html#a89fe04b2d2e1cd53344b3d0e8b0c7789">pktlab_read_t</a>&#160;</td>
          <td class="paramname"><em>read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>aux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get initialized pktlab reader struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">read</td><td>Read function to use for this reader. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aux</td><td>Auxiliary information needed by read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated and initialized pktlab reader struct.</dd></dl>
<ul>
<li>Note to use read() in unistd.h with reader, one will need to wrap read() so that the fd is taken in via a pointer to an int variable storing the fd instead.</li>
<li>The returned allocated struct should be freed with <a class="el" href="pktlab_8h.html#a65ac5f5ebe314972be37bdb18887a54d" title="Close and free pktlab reader struct.">pktlab_close_reader()</a>.</li>
<li>Normally, one would use the pktctrl module instead to read/recv pktlab messages rather than using the pktlab reader utilities. </li>
</ul>

</div>
</div>
<a id="a94b1653ecc589ccfb1e6852a3f1e9a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94b1653ecc589ccfb1e6852a3f1e9a07">&#9670;&nbsp;</a></span>pktlab_create_result_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structpktlab__message.html">pktlab_message</a>* pktlab_create_result_message </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="pktlab_8h.html#abd1908d576437c692d3be8071c75cab9">pktlab_status</a>&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get fields-set pktlab result message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Result message errid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated pktlab result message with errid set.</dd></dl>
<ul>
<li>The returned message pointer should be freed with free() in stdlib.h. </li>
</ul>

</div>
</div>
<a id="a9b21cba7d11c875b5268542c49e6d2a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b21cba7d11c875b5268542c49e6d2a4">&#9670;&nbsp;</a></span>pktlab_create_writer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structpktlab__writer.html">pktlab_writer</a>* pktlab_create_writer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pktlab_8h.html#a53f306929ea68ec41259ed659a72134b">pktlab_write_t</a>&#160;</td>
          <td class="paramname"><em>write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>aux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get initialized pktlab writer struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">write</td><td>Write function to use for this writer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aux</td><td>Auxiliary information needed by write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated and initialized pktlab writer struct.</dd></dl>
<ul>
<li>Note to use write() in unistd.h with writer, one will need to wrap write() so that the fd is taken in via a pointer to an int variable storing the fd instead.</li>
<li>The returned allocated struct should be freed with <a class="el" href="pktlab_8h.html#a72bb120e12a20032c6ae919cc7a52926" title="Close and free pktlab writer struct.">pktlab_close_writer()</a>.</li>
<li>Normally, one would use the pktctrl module instead to write/send pktlab messages rather than using the pktlab writer utilities. </li>
</ul>

</div>
</div>
<a id="a09a9edef5aa6e7663fc0317aa66d70c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a9edef5aa6e7663fc0317aa66d70c3">&#9670;&nbsp;</a></span>pktlab_decode_cert_detail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_decode_cert_detail </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structpktlab__certificate.html">pktlab_certificate</a> *&#160;</td>
          <td class="paramname"><em>cert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structpktlab__publickey.html">pktlab_publickey</a> *&#160;</td>
          <td class="paramname"><em>signkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpktlab__cert__detail.html">pktlab_cert_detail</a> **&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode pktlab certificate detail information from loaded pktlab certificate struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cert</td><td>Pointer to a loaded pktlab certificate struct. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signkey</td><td>Pointer to a loaded pktlab public key struct for verifying certificate signature. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ptr</td><td>Pointer to return an allocated struct storing decoded certificate detail information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the enum pktlab_decode_rst defined values representing the decoding result. Decoded certificate information struct is returned via ptr when decoding is successful.</dd></dl>
<ul>
<li>If signkey is NULL, the function still attempts to decode the certificate, but does not check if the certificate signature is valid w.r.t. signkey.</li>
<li>The returned ptr should be freed with free() in stdlib.h.</li>
<li>As <code><a class="el" href="structpktlab__cert__detail.html" title="Structure for storing pktlab certificate detail information, including cert_info and cert_limit.">pktlab_cert_detail</a></code> struct is a linked list and there is only one <code>cert</code>, this function will only return a single node with the next pointer set to NULL. </li>
</ul>

</div>
</div>
<a id="ab323a06486397ae2c1548ab02d41c07b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab323a06486397ae2c1548ab02d41c07b">&#9670;&nbsp;</a></span>pktlab_decode_certificate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_decode_certificate </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structpktlab__certificate.html">pktlab_certificate</a> *&#160;</td>
          <td class="paramname"><em>cert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structpktlab__publickey.html">pktlab_publickey</a> *&#160;</td>
          <td class="paramname"><em>signkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpktlab__decoded__certificate.html">pktlab_decoded_certificate</a> **&#160;</td>
          <td class="paramname"><em>decoded_cert</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode pktlab certificate information from loaded pktlab certificate struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cert</td><td>Pointer to a loaded pktlab certificate struct. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signkey</td><td>Pointer to a loaded pktlab public key struct for verifying certificate signature. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ptr</td><td>Pointer to return an allocated struct storing decoded certificate information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the enum pktlab_decode_rst defined values representing the decoding result. Decoded certificate information struct is returned via ptr when decoding is successful.</dd></dl>
<ul>
<li>If signkey is NULL, the function still attempts to decode the certificate, but does not check if the certificate signature is valid w.r.t. signkey.</li>
<li>The returned ptr should be freed with free() in stdlib.h. </li>
</ul>

</div>
</div>
<a id="a11191f0ec3dcdb30cfa402ad42aca759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11191f0ec3dcdb30cfa402ad42aca759">&#9670;&nbsp;</a></span>pktlab_decode_chlist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_decode_chlist </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>chlistptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>chlistlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpktlab__channel.html">pktlab_channel</a> **&#160;</td>
          <td class="paramname"><em>channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a channel list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">chlistptr</td><td>Encoded channel list to decode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chlistlen</td><td>Length of encoded channel list. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">channels</td><td>Pointer to return the allocated decoded channel linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ol type="1">
<li>0 for success.</li>
<li>-1 for bad argument.</li>
<li>-2 for malformed chlist.</li>
<li>Other &lt; 0 values for unknown errors.</li>
</ol>
</dd></dl>
<ul>
<li>The returned channels should be freed with <a class="el" href="pktlab_8h.html#ab4d013b2cc5d9c48ba209961865b42dc" title="Free an allocated channel linked list.">pktlab_free_channels()</a>. </li>
</ul>

</div>
</div>
<a id="a0d500bfe2d478128c9a84395a915befd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d500bfe2d478128c9a84395a915befd">&#9670;&nbsp;</a></span>pktlab_decode_dattr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_decode_dattr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dattr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>dattrlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpktlab__namevalue__pair.html">pktlab_namevalue_pair</a> **&#160;</td>
          <td class="paramname"><em>pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t *&#160;</td>
          <td class="paramname"><em>paircnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode an encoded endpoint attribute (dattr) string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dattr</td><td>Pointer to the encoded dattr string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dattrlen</td><td>Encoded dattr string length. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pairs</td><td>Pointer to return an allocated array of decoded dattr name-value pair(s). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">paircnt</td><td>Pointer to return the number of dattr name-value pair(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, &lt; 0 for failure.</dd></dl>
<ul>
<li>Note when dattr is NULL, dattrlen must be 0 and vice versa.</li>
<li>The returned pairs should be freed with free() in stdlib.h. </li>
</ul>

</div>
</div>
<a id="a2ae23868914b91e99903b7f8581cee5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae23868914b91e99903b7f8581cee5f">&#9670;&nbsp;</a></span>pktlab_decode_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t pktlab_decode_message </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpktlab__message.html">pktlab_message</a> *restrict&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *restrict&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode pktlab message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">msg</td><td>Pointer to a struct for returning decoded message content. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Encoded message bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of encoded message bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in ptr used for decoding. 0 if not enough bytes supplied. msg is set when &gt; 0 bytes are used.</dd></dl>
<ul>
<li>Note pktlab_decode_message only checks for message well-formedness as defined in the pktlab protocol documentation.</li>
<li>When receiving pktlab messages from a socket, rather than directly calling this function with the received bytes, it is recommended to use the pktctrl module (<a class="el" href="pktctrl_8h.html#abd20ed6c8d0d9e3a0a73d5d61c420234" title="Read pktctrl message from established pktctrl session.">pktctrl_read_message()</a>) instead.</li>
<li>Note the msg fields rely on the passed ptr. If the content in ptr is changed after the call to <a class="el" href="pktlab_8h.html#a2ae23868914b91e99903b7f8581cee5f" title="Decode pktlab message.">pktlab_decode_message()</a>, the msg fields may change as well. </li>
</ul>

</div>
</div>
<a id="a75d44cc890cc8acd2d7e6328b17b2472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d44cc890cc8acd2d7e6328b17b2472">&#9670;&nbsp;</a></span>pktlab_decode_program()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_decode_program </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>buflen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="pktlab_8h.html#ad49ead2ad49df1700b526ccd019854b4">pktlab_prog_type</a> *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t *&#160;</td>
          <td class="paramname"><em>proglen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode pktlab program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Pointer to encoded program bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buflen</td><td>Length of encoded program in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">type</td><td>Pointer to return decoded program type. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">prog</td><td>Pointer to return allocated decoded pktlab program bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">proglen</td><td>Pointer to return decoded pktlab program length in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, &lt; 0 for failure.</dd></dl>
<ul>
<li>Note prog and proglen are set only when the decoding is successful.</li>
<li>The returned prog should be freed with free() in stdlib.h. </li>
</ul>

</div>
</div>
<a id="a1ae4203d86e65c950480989c3a37df51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae4203d86e65c950480989c3a37df51">&#9670;&nbsp;</a></span>pktlab_decode_xdescr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_decode_xdescr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>xdescr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>xdescrlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpktlab__namevalue__pair.html">pktlab_namevalue_pair</a> **&#160;</td>
          <td class="paramname"><em>pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t *&#160;</td>
          <td class="paramname"><em>paircnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode an encoded experiment descriptor (xdescr) string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xdescr</td><td>Pointer to the encoded xdescr string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xdescrlen</td><td>Encoded xdescr string length. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pairs</td><td>Pointer to return an allocated array of decoded xdescr name-value pair(s). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">paircnt</td><td>Pointer to return the number of xdescr name-value pair(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, &lt; 0 for failure. Decoded pairs are returned via pairs and paircnt upon success.</dd></dl>
<ul>
<li>Note when xdescr is NULL, xdescrlen must be 0 and vice versa.</li>
<li>The returned pairs should be freed with free() in stdlib.h. </li>
</ul>

</div>
</div>
<a id="a10ad8bfcedd3681b33bb7b119a22b185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10ad8bfcedd3681b33bb7b119a22b185">&#9670;&nbsp;</a></span>pktlab_decoded_cert_get_cert_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_decoded_cert_get_cert_type </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structpktlab__decoded__certificate.html">pktlab_decoded_certificate</a> *&#160;</td>
          <td class="paramname"><em>decoded_cert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="pktlab_8h.html#ac9eddf82925b672a4f40f4428e151be0">pktlab_cert_type</a> *&#160;</td>
          <td class="paramname"><em>cert_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pktlab certificate type from decoded pktlab certificate information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cert</td><td>Pointer to a loaded pktlab certificate struct. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cert_type</td><td>Pointer to return pktlab certificate type value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success. &lt; 0 if failed. </dd></dl>

</div>
</div>
<a id="ab5fd5afc15a1f1659a9f1aa2ac4bc001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5fd5afc15a1f1659a9f1aa2ac4bc001">&#9670;&nbsp;</a></span>pktlab_encode_chlist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_encode_chlist </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structpktlab__channel.html">pktlab_channel</a> *&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>chlistptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t *&#160;</td>
          <td class="paramname"><em>chlistlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode a channel list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channels</td><td>Linked list of channels to encode. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">chlistptr</td><td>Pointer to return the allocated encoded channel list. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">chlistlen</td><td>Length of encoded channel list returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ol type="1">
<li>0 for success.</li>
<li>-1 for bad argument.</li>
<li>-2 for bad channel in channels.</li>
<li>Other &lt; 0 values for unknown errors.</li>
</ol>
</dd></dl>
<ul>
<li>The returned chlistptr should be freed with free() in stdlib.h. </li>
</ul>

</div>
</div>
<a id="aabedaec160b02afe6824fc0b2ee80e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabedaec160b02afe6824fc0b2ee80e09">&#9670;&nbsp;</a></span>pktlab_encode_dattr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_encode_dattr </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structpktlab__namevalue__pair.html">pktlab_namevalue_pair</a> *&#160;</td>
          <td class="paramname"><em>pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>paircnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>buflen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t *&#160;</td>
          <td class="paramname"><em>used</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode an endpoint attribute (dattr) string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pairs</td><td>Pointer to an array of name-value pair(s) to encode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paircnt</td><td>Length of name-value pair array. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Pointer to buffer for storing the encoded dattr string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buflen</td><td>Size of buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">used</td><td>Pointer to return the length of the encoded dattr string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, &lt; 0 for failure.</dd></dl>
<ul>
<li>Note when pairs is NULL, paircnt must be 0 and vice versa.</li>
<li>One can estimate the buffer size the same way as described for <a class="el" href="pktlab_8h.html#ae00b6175847f6fee69812d48b6143500" title="Encode an experiment descriptor (xdescr) string.">pktlab_encode_xdescr()</a>.</li>
<li>The returned dattr string is NOT '\0'-terminated. </li>
</ul>

</div>
</div>
<a id="a7992448d296c83dfb78ccece719687f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7992448d296c83dfb78ccece719687f8">&#9670;&nbsp;</a></span>pktlab_encode_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_encode_message </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structpktlab__message.html">pktlab_message</a> *restrict&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *restrict&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *restrict&#160;</td>
          <td class="paramname"><em>iov</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode pktlab message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Pointer to a fields-set msg struct for message encoding. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer of at least PKTLAB_ENCODE_BUFSZ size for msg encoding. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">iov</td><td>Pointer to an array of PKTLAB_ENCODE_IOVCNT iovec elements for msg encoding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of iovec elements used in iov to encode msg. &lt; 0 if encoding failed.</dd></dl>
<ul>
<li>Note for how to fill the msg struct, refer to the pktlab protocol documentation.</li>
<li>In case of successful encoding, one can use writev() in sys/uio.h to send the encoded bytes.</li>
<li>When sending pktlab messages via a socket, rather than directly calling this function and afterwards writev() to send the encoded bytes, it is recommended to use the pktctrl module (<a class="el" href="pktctrl_8h.html#a50ec6e10884502f16184ac0921e173be" title="Write pktctrl message to established pktctrl session.">pktctrl_write_message()</a>) instead. </li>
</ul>

</div>
</div>
<a id="a38fd911b937df605572e03da14661cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38fd911b937df605572e03da14661cb5">&#9670;&nbsp;</a></span>pktlab_encode_program()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_encode_program </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="pktlab_8h.html#ad49ead2ad49df1700b526ccd019854b4">pktlab_prog_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>proglen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t *&#160;</td>
          <td class="paramname"><em>buflen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode pktlab program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Program type to be encoded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prog</td><td>Pointer to the pktlab program bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">proglen</td><td>Length of pktlab program in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Pointer to return allocated encoded program bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buflen</td><td>Pointer to return length of encoded program bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, &lt; 0 for failure.</dd></dl>
<ul>
<li>The returned buf should be freed with free() in stdlib.h. </li>
</ul>

</div>
</div>
<a id="ae00b6175847f6fee69812d48b6143500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae00b6175847f6fee69812d48b6143500">&#9670;&nbsp;</a></span>pktlab_encode_xdescr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_encode_xdescr </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structpktlab__namevalue__pair.html">pktlab_namevalue_pair</a> *&#160;</td>
          <td class="paramname"><em>pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>paircnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>buflen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t *&#160;</td>
          <td class="paramname"><em>used</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode an experiment descriptor (xdescr) string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pairs</td><td>Pointer to an array of name-value pair(s) to encode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paircnt</td><td>Length of name-value pair array. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Pointer to buffer for storing the encoded xdescr string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buflen</td><td>Size of buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">used</td><td>Pointer to return the length of the encoded xdescr string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, &lt; 0 for failure.</dd></dl>
<ul>
<li>Note when pairs is NULL, paircnt must be 0 and vice versa.</li>
<li>One can estimate the buffer size needed by summing up the name length and value length of all pairs, with an additional overhead of two characters per pair. I.e. with two pairs {name:"foo",value:"bar"} and {name:"hello",value:"world"}, the length needed is 3+3+2=8 for the first pair and 5+5+2=12 for the second pair.</li>
<li>One would therefore need a buffer size of at least 20 characters for encoding.</li>
<li>The returned xdescr string is NOT '\0'-terminated. </li>
</ul>

</div>
</div>
<a id="a524fb1985afe251a4ba072fd9176fd98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a524fb1985afe251a4ba072fd9176fd98">&#9670;&nbsp;</a></span>pktlab_flush_writer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_flush_writer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpktlab__writer.html">pktlab_writer</a> *&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush pktlab writer internal buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">w</td><td>Initialized pktlab writer struct to be flushed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ol type="1">
<li>If success, return the number of bytes flushed out of writer buffer (can be 0).</li>
<li>&lt; 0 for write errors. Check errno for more information.</li>
</ol>
</dd></dl>
<ul>
<li>Note it is possible for <a class="el" href="pktlab_8h.html#a524fb1985afe251a4ba072fd9176fd98" title="Flush pktlab writer internal buffer.">pktlab_flush_writer()</a> to only flush a portion of the internally buffered bytes. To ensure all internally buffered bytes are flushed, one should use <a class="el" href="pktlab_8h.html#a524fb1985afe251a4ba072fd9176fd98" title="Flush pktlab writer internal buffer.">pktlab_flush_writer()</a> in conjunction with <a class="el" href="pktlab_8h.html#aae8895ba48507b6ec6af8fb007c61d31" title="Get writer internal buffered content length.">pktlab_writer_unsent()</a> to check whether after a flush there are no internally buffered bytes left.</li>
<li>w should be closed afterwards if <a class="el" href="pktlab_8h.html#a524fb1985afe251a4ba072fd9176fd98" title="Flush pktlab writer internal buffer.">pktlab_flush_writer()</a> failed with an error. </li>
</ul>

</div>
</div>
<a id="ab4d013b2cc5d9c48ba209961865b42dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4d013b2cc5d9c48ba209961865b42dc">&#9670;&nbsp;</a></span>pktlab_free_channels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pktlab_free_channels </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpktlab__channel.html">pktlab_channel</a> *&#160;</td>
          <td class="paramname"><em>channels</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an allocated channel linked list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">channels</td><td>Allocated channel linked list to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade7a896804739609b1965f92be8db014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade7a896804739609b1965f92be8db014">&#9670;&nbsp;</a></span>pktlab_get8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint_fast8_t pktlab_get8 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get 8-bit unsigned integer from byte array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Target byte array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>8 bit unsigned integer.</dd></dl>
<ul>
<li>Note there also exist similar functions (pktlab_getN[b|l|n]) that gets N-bit unsigned integer from byte array (N being either 16, 24, 32 or 64). The b/l/n suffix specifies the function treats the byte array as in big endian/little endian/network byte order, respectively. </li>
</ul>

</div>
</div>
<a id="a7f902f2e335c6c293456682ce0e64ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f902f2e335c6c293456682ce0e64ee5">&#9670;&nbsp;</a></span>pktlab_get_agent_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_get_agent_key </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structpktlab__certificate.html">pktlab_certificate</a> *&#160;</td>
          <td class="paramname"><em>agent_cert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>agent_pubkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pktlab agent certificate subject (signee) public key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">agent_cert</td><td>Pointer to a loaded pktlab agent certificate struct. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">agent_pubkey</td><td>Pointer to buffer for storing raw subject (signee) public key. The buffer size must be at least PKTLAB_PUBLICKEY_LEN bytes large. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success. &lt; 0 if failed. </dd></dl>

</div>
</div>
<a id="a9593d93f15ad31ed06951a05c7c8e5a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9593d93f15ad31ed06951a05c7c8e5a9">&#9670;&nbsp;</a></span>pktlab_get_cert_der()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_get_cert_der </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structpktlab__certificate.html">pktlab_certificate</a> *&#160;</td>
          <td class="paramname"><em>cert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>der</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t *&#160;</td>
          <td class="paramname"><em>derlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get DER-encoded pktlab certificate bytes from loaded pktlab certificate struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cert</td><td>Pointer to a loaded pktlab certificate struct. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">der</td><td>Pointer to return pointer to an allocated array storing DER-encoded pktlab certificate bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">derlen</td><td>Pointer to return DER-encoded pktlab certificate byte array length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success. &lt; 0 if failed.</dd></dl>
<ul>
<li>This function is useful when setting <a class="el" href="structpktlab__message.html" title="Structure for storing the decoded form of pktlab messages.">pktlab_message</a> struct fields for xcert messages.</li>
<li>The returned der should be freed with free() in stdlib.h. </li>
</ul>

</div>
</div>
<a id="a1b69032d1a52cdcab113d89bd1ceb9f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b69032d1a52cdcab113d89bd1ceb9f6">&#9670;&nbsp;</a></span>pktlab_get_key_identifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_get_key_identifier </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structpktlab__publickey.html">pktlab_publickey</a> *&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>buflen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get key identifier for a loaded pktlab public key struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>Pointer to a loaded pktlab public key struct. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Pointer to buffer for storing computed key identifier. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buflen</td><td>Size of buffer, should be at least PKTLAB_KEYID_LEN large. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success. &lt; 0 if failed. </dd></dl>

</div>
</div>
<a id="ad41d41e22e6227a80f35e5a7cbac485e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad41d41e22e6227a80f35e5a7cbac485e">&#9670;&nbsp;</a></span>pktlab_get_privatekey_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_get_privatekey_bytes </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structpktlab__privatekey.html">pktlab_privatekey</a> *&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>buflen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get raw private key byte array from loaded pktlab private key struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>Pointer to a loaded pktlab private key struct. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Pointer to buffer for storing raw private key bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buflen</td><td>Size of buffer, should be at least PKTLAB_PRIVATEKEY_LEN large. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success. &lt; 0 if failed. </dd></dl>

</div>
</div>
<a id="aa2b949eef395e62b0fc6d60a0ce3b785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b949eef395e62b0fc6d60a0ce3b785">&#9670;&nbsp;</a></span>pktlab_get_program_digest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_get_program_digest </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>datalen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute encoded pktlab program digest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to encoded program bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">datalen</td><td>Length of encoded program in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">digest</td><td>Pointer to return digest of encoded pktlab program. Should point to buffer of at least PKTLAB_SHA256_DIGEST_LEN large. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, &lt; 0 for failure. </dd></dl>

</div>
</div>
<a id="a6c3640de2d82007424d1151036a05485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c3640de2d82007424d1151036a05485">&#9670;&nbsp;</a></span>pktlab_get_publickey_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_get_publickey_bytes </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structpktlab__publickey.html">pktlab_publickey</a> *&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>buflen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get raw public key byte array from loaded pktlab public key struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>Pointer to a loaded pktlab public key struct. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Pointer to buffer for storing raw public key bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buflen</td><td>Size of buffer, should be at least PKTLAB_PUBLICKEY_LEN large. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success. &lt; 0 if failed. </dd></dl>

</div>
</div>
<a id="ae213d220889b409669983cbba1f41f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae213d220889b409669983cbba1f41f19">&#9670;&nbsp;</a></span>pktlab_get_publickey_from_privatekey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structpktlab__publickey.html">pktlab_publickey</a>* pktlab_get_publickey_from_privatekey </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structpktlab__privatekey.html">pktlab_privatekey</a> *&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get loaded pktlab public key struct from loaded pktlab private key struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>Pointer to a loaded pktlab private key struct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to an allocated loaded pktlab public key struct if success. Otherwise NULL. </dd></dl>

</div>
</div>
<a id="ad18b8c8e2d5fd29965550720f868c168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad18b8c8e2d5fd29965550720f868c168">&#9670;&nbsp;</a></span>pktlab_getbit8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool pktlab_getbit8 </td>
          <td>(</td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get bit from unsigned integer at bit position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bits</td><td>Target unsigned interger to get bit from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Target bit position (0-indexed). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bit.</dd></dl>
<ul>
<li>Note there also exist similar functions (pktlab_getbitN) that get bit from larger unsigned integer (N being either 16, 32, or 64).</li>
<li>Getting bit for pos &gt;= N will result in false. </li>
</ul>

</div>
</div>
<a id="a366dafc33b44301d8926d5e947883959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366dafc33b44301d8926d5e947883959">&#9670;&nbsp;</a></span>pktlab_hton16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint_fast16_t pktlab_hton16 </td>
          <td>(</td>
          <td class="paramtype">uint_fast16_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert 16-bit unsigned integer from host byte order to network byte order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Target value to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted value.</dd></dl>
<ul>
<li>Note there also exist similar functions (pktlab_htonN and pktlab_ntohN) that convert unsigned integer from host byte order to network byte order and vice versa (N being either 16, 32, or 64). </li>
</ul>

</div>
</div>
<a id="a8b189227e6fb95b9485b7d3cc6a77de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b189227e6fb95b9485b7d3cc6a77de1">&#9670;&nbsp;</a></span>pktlab_load_cert_der()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_load_cert_der </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>der</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>derlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpktlab__certificate.html">pktlab_certificate</a> *&#160;</td>
          <td class="paramname"><em>cert</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load pktlab certificate struct via DER-encode pktlab certificate byte array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">der</td><td>Pointer to the DER-encode pktlab certificate byte array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">derlen</td><td>DER-encode pktlab certificate byte array length. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cert</td><td>Pointer to an initialized pktlab certificate struct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success. &lt; 0 if failed.</dd></dl>
<ul>
<li>To obtain an initialized pktlab certificate struct, see <a class="el" href="pktlab_8h.html#ac782909f422cfc761a53fce7069a8660" title="Allocate initialized pktlab certificate struct.">pktlab_create_cert()</a>.</li>
<li>Note cert remains initialized if <a class="el" href="pktlab_8h.html#a8b189227e6fb95b9485b7d3cc6a77de1" title="Load pktlab certificate struct via DER-encode pktlab certificate byte array.">pktlab_load_cert_der()</a> failed;</li>
<li><a class="el" href="pktlab_8h.html#a8b189227e6fb95b9485b7d3cc6a77de1" title="Load pktlab certificate struct via DER-encode pktlab certificate byte array.">pktlab_load_cert_der()</a> should NOT be called on an already loaded pktlab certificate struct. </li>
</ul>

</div>
</div>
<a id="a5f92ccf1f8dbfb5aece5adb38b50cf03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f92ccf1f8dbfb5aece5adb38b50cf03">&#9670;&nbsp;</a></span>pktlab_load_cert_pem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_load_cert_pem </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>pemlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpktlab__certificate.html">pktlab_certificate</a> *&#160;</td>
          <td class="paramname"><em>cert</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load pktlab certificate struct via PEM-encoded pktlab certificate char array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pem</td><td>Pointer to the PEM-encoded pktlab certificate char array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pemlen</td><td>PEM-encoded pktlab certificate char array length. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cert</td><td>Pointer to an initialized pktlab certificate struct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success. &lt; 0 if failed.</dd></dl>
<ul>
<li>To obtain an initialized pktlab certificate struct, see <a class="el" href="pktlab_8h.html#ac782909f422cfc761a53fce7069a8660" title="Allocate initialized pktlab certificate struct.">pktlab_create_cert()</a>.</li>
<li>Note cert remains initialized if <a class="el" href="pktlab_8h.html#a5f92ccf1f8dbfb5aece5adb38b50cf03" title="Load pktlab certificate struct via PEM-encoded pktlab certificate char array.">pktlab_load_cert_pem()</a> failed;</li>
<li><a class="el" href="pktlab_8h.html#a5f92ccf1f8dbfb5aece5adb38b50cf03" title="Load pktlab certificate struct via PEM-encoded pktlab certificate char array.">pktlab_load_cert_pem()</a> should NOT be called on an already loaded pktlab certificate struct.</li>
<li>The underlying content being PEM-encoded should be a DER-encoded pktlab certificate. </li>
</ul>

</div>
</div>
<a id="a14401636d8628029fba6b0d65948bed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14401636d8628029fba6b0d65948bed7">&#9670;&nbsp;</a></span>pktlab_load_privatekey_der()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_load_privatekey_der </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>der</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>derlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>passphrase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpktlab__privatekey.html">pktlab_privatekey</a> *&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load pktlab private key struct via raw PKCS8 byte array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">der</td><td>Pointer to the raw PKCS8 byte array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">derlen</td><td>Raw PKCS8 byte array length. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">passphrase</td><td>Pointer to '\0'-terminated passphrase string if the loaded private key is encrypted. For unencrypted private key one should pass in NULL. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">k</td><td>Pointer to an initialized pktlab private key struct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success. &lt; 0 if failed.</dd></dl>
<ul>
<li>To obtain an initialized pktlab private key struct, see <a class="el" href="pktlab_8h.html#a36fa688be315248159d774f84beea8de" title="Allocate initialized pktlab private key struct.">pktlab_create_privatekey()</a>.</li>
<li>Note k remains initialized if <a class="el" href="pktlab_8h.html#a14401636d8628029fba6b0d65948bed7" title="Load pktlab private key struct via raw PKCS8 byte array.">pktlab_load_privatekey_der()</a> failed;</li>
<li><a class="el" href="pktlab_8h.html#a14401636d8628029fba6b0d65948bed7" title="Load pktlab private key struct via raw PKCS8 byte array.">pktlab_load_privatekey_der()</a> should NOT be called on an already loaded pktlab private key struct.</li>
<li>The raw PKCS8 byte array should be an Ed25519 private key in DER-encoded PKCS8 format. </li>
</ul>

</div>
</div>
<a id="a9eaff9c7a04dab9e1346a9cfb9128e01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eaff9c7a04dab9e1346a9cfb9128e01">&#9670;&nbsp;</a></span>pktlab_load_privatekey_pem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_load_privatekey_pem </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>pemlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>passphrase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpktlab__privatekey.html">pktlab_privatekey</a> *&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load pktlab private key struct via PEM-encoded private key char array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pem</td><td>Pointer to PEM-encoded private key char array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pemlen</td><td>PEM-encoded private key char array length. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">passphrase</td><td>Pointer to '\0'-terminated passphrase string if the loaded private key is encrypted. For unencrypted private key one should pass in NULL. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">k</td><td>Pointer to an initialized pktlab private key struct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success. &lt; 0 if failed.</dd></dl>
<ul>
<li>To obtain an initialized pktlab private key struct, see <a class="el" href="pktlab_8h.html#a36fa688be315248159d774f84beea8de" title="Allocate initialized pktlab private key struct.">pktlab_create_privatekey()</a>.</li>
<li>Note k remains initialized if <a class="el" href="pktlab_8h.html#a9eaff9c7a04dab9e1346a9cfb9128e01" title="Load pktlab private key struct via PEM-encoded private key char array.">pktlab_load_privatekey_pem()</a> failed;</li>
<li><a class="el" href="pktlab_8h.html#a9eaff9c7a04dab9e1346a9cfb9128e01" title="Load pktlab private key struct via PEM-encoded private key char array.">pktlab_load_privatekey_pem()</a> should NOT be called on an already loaded pktlab private key struct.</li>
<li>The underlying content being PEM-encoded should be an Ed25519 private key in DER-encoded PKCS8 format. </li>
</ul>

</div>
</div>
<a id="a9276942f170f7919afced0fba4f2b81f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9276942f170f7919afced0fba4f2b81f">&#9670;&nbsp;</a></span>pktlab_load_privatekey_raw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_load_privatekey_raw </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpktlab__privatekey.html">pktlab_privatekey</a> *&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load pktlab private key struct via raw private key byte array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bytes</td><td>Pointer to the raw private key byte array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Raw private key byte array length. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">k</td><td>Pointer to an initialized pktlab private key struct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success. &lt; 0 if failed.</dd></dl>
<ul>
<li>To obtain an initialized pktlab private key struct, see <a class="el" href="pktlab_8h.html#a36fa688be315248159d774f84beea8de" title="Allocate initialized pktlab private key struct.">pktlab_create_privatekey()</a>.</li>
<li>Note k remains initialized if <a class="el" href="pktlab_8h.html#a9276942f170f7919afced0fba4f2b81f" title="Load pktlab private key struct via raw private key byte array.">pktlab_load_privatekey_raw()</a> failed;</li>
<li><a class="el" href="pktlab_8h.html#a9276942f170f7919afced0fba4f2b81f" title="Load pktlab private key struct via raw private key byte array.">pktlab_load_privatekey_raw()</a> should NOT be called on an already loaded pktlab private key struct.</li>
<li>Normally, len should be equal to PKTLAB_PRIVATEKEY_LEN. </li>
</ul>

</div>
</div>
<a id="a474a11faa38efb191e9ab92735cfa473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474a11faa38efb191e9ab92735cfa473">&#9670;&nbsp;</a></span>pktlab_load_program()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_load_program </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>datalen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="pktlab_8h.html#ad49ead2ad49df1700b526ccd019854b4">pktlab_prog_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t *&#160;</td>
          <td class="paramname"><em>proglen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t *&#160;</td>
          <td class="paramname"><em>errlineno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load pktlab program from file content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to program file content. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">datalen</td><td>Length of program file content in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Program file content program type. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">prog</td><td>Pointer to return allocated loaded pktlab program bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">proglen</td><td>Pointer to return loaded pktlab program length in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errlineno</td><td>Pointer to return the line number when a parsing error occurred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, &lt; 0 for failure.</dd></dl>
<ul>
<li>The returned prog should be freed with free() in stdlib.h.</li>
<li>For program file content, line starting with '#', empty new line (only '<br  />
'), and carriage-return-only line ('\r<br  />
') are ignored.</li>
<li>For eBPF programs, each non-ignored line should consist of 5 unsigned integers in the format acceptable to strtoull.</li>
<li>If pktlab_load_program failed due to a malformed line, the errlineno (if non-NULL) is set to the line number (1 indexed). Otherwise it is set to 0. </li>
</ul>

</div>
</div>
<a id="a2389ebdfc43cc103c4ec7748fc03ed4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2389ebdfc43cc103c4ec7748fc03ed4a">&#9670;&nbsp;</a></span>pktlab_load_publickey_der()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_load_publickey_der </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>der</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>derlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpktlab__publickey.html">pktlab_publickey</a> *&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load pktlab public key struct via raw SubjectPublicKeyInfo byte array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">der</td><td>Raw SubjectPublicKeyInfo byte array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">derlen</td><td>Raw SubjectPublicKeyInfo byte array length. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">k</td><td>Pointer to an initialized pktlab public key struct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success. &lt; 0 if failed.</dd></dl>
<ul>
<li>To obtain an initialized pktlab public key struct, see <a class="el" href="pktlab_8h.html#a737dd716edca6ba83b6024db285c14df" title="Allocate initialized pktlab public key struct.">pktlab_create_publickey()</a>.</li>
<li>Note k remains initialized if <a class="el" href="pktlab_8h.html#a2389ebdfc43cc103c4ec7748fc03ed4a" title="Load pktlab public key struct via raw SubjectPublicKeyInfo byte array.">pktlab_load_publickey_der()</a> failed;</li>
<li><a class="el" href="pktlab_8h.html#a2389ebdfc43cc103c4ec7748fc03ed4a" title="Load pktlab public key struct via raw SubjectPublicKeyInfo byte array.">pktlab_load_publickey_der()</a> should NOT be called on an already loaded pktlab public key struct.</li>
<li>The raw SubjectPublicKeyInfo byte array should be an Ed25519 public key in DER-encoded SubjectPublicKeyInfo format. </li>
</ul>

</div>
</div>
<a id="a860ac68eae6a58a3a475febf10a503df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860ac68eae6a58a3a475febf10a503df">&#9670;&nbsp;</a></span>pktlab_load_publickey_pem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_load_publickey_pem </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>pemlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpktlab__publickey.html">pktlab_publickey</a> *&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load pktlab public key struct via PEM-encoded public key char array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pem</td><td>PEM-encoded public key char array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pemlen</td><td>PEM-encoded public key char array length. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">k</td><td>Pointer to an initialized pktlab public key struct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success. &lt; 0 if failed.</dd></dl>
<ul>
<li>To obtain an initialized pktlab public key struct, see <a class="el" href="pktlab_8h.html#a737dd716edca6ba83b6024db285c14df" title="Allocate initialized pktlab public key struct.">pktlab_create_publickey()</a>.</li>
<li>Note k remains initialized if <a class="el" href="pktlab_8h.html#a860ac68eae6a58a3a475febf10a503df" title="Load pktlab public key struct via PEM-encoded public key char array.">pktlab_load_publickey_pem()</a> failed;</li>
<li><a class="el" href="pktlab_8h.html#a860ac68eae6a58a3a475febf10a503df" title="Load pktlab public key struct via PEM-encoded public key char array.">pktlab_load_publickey_pem()</a> should NOT be called on an already loaded pktlab public key struct.</li>
<li>The underlying content being PEM-encoded should be an Ed25519 public key in DER-encoded SubjectPublicKeyInfo format. </li>
</ul>

</div>
</div>
<a id="adc2d7d0a3b1ad5b463c797dcdcadcc3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc2d7d0a3b1ad5b463c797dcdcadcc3d">&#9670;&nbsp;</a></span>pktlab_load_publickey_raw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_load_publickey_raw </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpktlab__publickey.html">pktlab_publickey</a> *&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load pktlab public key struct via raw public key byte array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bytes</td><td>Raw public key byte array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Raw public key byte array length. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">k</td><td>Pointer to an initialized pktlab public key struct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success. &lt; 0 if failed.</dd></dl>
<ul>
<li>To obtain an initialized pktlab public key struct, see <a class="el" href="pktlab_8h.html#a737dd716edca6ba83b6024db285c14df" title="Allocate initialized pktlab public key struct.">pktlab_create_publickey()</a>.</li>
<li>Note k remains initialized if <a class="el" href="pktlab_8h.html#adc2d7d0a3b1ad5b463c797dcdcadcc3d" title="Load pktlab public key struct via raw public key byte array.">pktlab_load_publickey_raw()</a> failed;</li>
<li><a class="el" href="pktlab_8h.html#adc2d7d0a3b1ad5b463c797dcdcadcc3d" title="Load pktlab public key struct via raw public key byte array.">pktlab_load_publickey_raw()</a> should NOT be called on an already loaded pktlab public key struct.</li>
<li>Normally, len should be equal to PKTLAB_PUBLICKEY_LEN. </li>
</ul>

</div>
</div>
<a id="a62a36ddf5c4621ce092f54e95a570d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a36ddf5c4621ce092f54e95a570d55">&#9670;&nbsp;</a></span>pktlab_parse_controller_exp_cert_chain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_parse_controller_exp_cert_chain </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpktlab__certificate.html">pktlab_certificate</a> **&#160;</td>
          <td class="paramname"><em>cert_ls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>certnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>controller_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpktlab__publickey.html">pktlab_publickey</a> *&#160;</td>
          <td class="paramname"><em>trusted_eop_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpktlab__cert__detail.html">pktlab_cert_detail</a> **&#160;</td>
          <td class="paramname"><em>cert_details</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>subable_channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse pktlab controller experiment privilege certificate chain for subscribable channel and experiment privilege information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cert_ls</td><td>A potential controller experiment privilege chain (in the form of an array of pointers to loaded pktlab certificate structs consisting) that should be parsed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">certnum</td><td>The number of loaded pktlab certificate struct pointers in cert_ls. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">controller_key</td><td>Raw pktlab public key bytes for checking if the certificate chain leaf entity is some expected key. Should point to an array of at least PKTLAB_PUBLICKEY_LEN bytes long. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trusted_eop_key</td><td>A loaded pktlab public key struct for checking if the certificate chain root entity is some expected key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cert_details</td><td>Head pointer to return an allocated struct storing decoded certificate detail information. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">subable_channel</td><td>Pointer to return a private channel ID allowed to be subscribed based on cert_ls. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the enum pktlab_parse_cert_chain_rst defined values representing the parsing result. Digests, priority strings, and channel information returned when parsing successful.</dd></dl>
<ul>
<li>It is allowed to pass in NULL for controller_key/trusted_eop_key. If controller_key/trusted_eop_key is NULL, the corresponding leaf/root entity check is not conducted.</li>
<li>It is allowed to pass in NULL for cert_details. If a field is NULL, no value is returned for the field.</li>
<li>Note the first certificate in cert_ls is expected to be a pubcmd certificate (the others need not be in order). See PPKS documentation for more information on the expected format for a controller experiment privilege chain. </li>
</ul>

</div>
</div>
<a id="a96b83aa47fcdd78a54849319e1a3f0db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b83aa47fcdd78a54849319e1a3f0db">&#9670;&nbsp;</a></span>pktlab_parse_endpoint_rep_cert_chain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_parse_endpoint_rep_cert_chain </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpktlab__certificate.html">pktlab_certificate</a> **&#160;</td>
          <td class="paramname"><em>cert_ls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>certnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>endpoint_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpktlab__publickey.html">pktlab_publickey</a> *&#160;</td>
          <td class="paramname"><em>root_eop_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t **&#160;</td>
          <td class="paramname"><em>subable_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t *&#160;</td>
          <td class="paramname"><em>channelnum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse pktlab endpoint representation privilege certificate chain for subscribable channel information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cert_ls</td><td>A potential endpoint representation privilege chain (in the form of an array of pointers to loaded pktlab certificate structs consisting) that should be parsed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">certnum</td><td>The number of loaded pktlab certificate struct pointers in cert_ls. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endpoint_key</td><td>Raw pktlab public key bytes for checking if the certificate chain leaf entity is some expected key. Should point to an array of at least PKTLAB_PUBLICKEY_LEN bytes long. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root_eop_key</td><td>A loaded pktlab public key struct for checking if the certificate chain root entity is some expected key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">subable_channels</td><td>Pointer to return a list of private channel IDs allowed to be subscribed based on cert_ls. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">channelnum</td><td>Pointer to return the number of channel IDs in subable_channels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the enum pktlab_parse_cert_chain_rst defined values representing the parsing result. subable_channels &amp; channelnum returned when parsing successful.</dd></dl>
<ul>
<li>subable_channels is returned with all channel IDs back-to-back concatenated. Note the channel IDs returned are all PKTLAB_CHANNELID_LEN_MAX bytes long.</li>
<li>It is allowed to pass in NULL for endpoint_key/root_eop_key. If endpoint_key/root_eop_key is NULL, the corresponding leaf/root entity check is not conducted.</li>
<li>Note the first certificate in cert_ls is expected to be a subcmd certificate (the others need not be in order). See PPKS documentation for more information on the expected format for an endpoint representation privilege chain. </li>
</ul>

</div>
</div>
<a id="a56b92ae4a2175cf16998795281831f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b92ae4a2175cf16998795281831f53">&#9670;&nbsp;</a></span>pktlab_parse_uri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_parse_uri </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpktlab__uri.html">pktlab_uri</a> *restrict&#160;</td>
          <td class="paramname"><em>uri_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *restrict&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a pktlab URI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">uri_info</td><td>Pointer to a struct for storing the decoded result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>pktlab URI to decode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of pktlab URI. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ol type="1">
<li>0 for success.</li>
<li>-1 for bad argument.</li>
<li>-2 for malformed URI.</li>
<li>Other &lt; 0 values for unknown errors.</li>
</ol>
</dd></dl>
<ul>
<li>Note the uri_info is set only when either the decoding is successful, or the URI is malformed. When the decoding is successful, type is set to the decoded URI type with the decoded information being set in the uri struct. Otherwise, the malformed struct is set with the type set to MALFORMED_URI_TYPE.</li>
<li>Note the uri_info fields rely on the passed ptr. If the content in ptr is changed after the call to <a class="el" href="pktlab_8h.html#a56b92ae4a2175cf16998795281831f53" title="Decode a pktlab URI.">pktlab_parse_uri()</a>, the uri_info fields may change as well.</li>
<li>The expected URI format: "pktlab://HOST[:PORT]/exp|broker/". </li>
</ul>

</div>
</div>
<a id="adb3ef3c891d623ca8152429834b4fde0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb3ef3c891d623ca8152429834b4fde0">&#9670;&nbsp;</a></span>pktlab_read_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_read_message </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpktlab__reader.html">pktlab_reader</a> *restrict&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpktlab__message.html">pktlab_message</a> **restrict&#160;</td>
          <td class="paramname"><em>msgptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pktlab reader read message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">r</td><td>Initialized pktlab reader struct. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">msgptr</td><td>Pointer to return an allocated msg that was read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>When msgptr is not NULL:<ol type="1">
<li>1 for successful read with decoded read msg returned via msgptr. If EOF is encountered, a NULL is returned via msgptr.</li>
<li>0 for try again later.</li>
<li>&lt; 0 for read errors. Check errno for more information.</li>
</ol>
</li>
<li>When msgptr is NULL:<ol type="1">
<li>1 for there exists new msg available for reading.</li>
<li>0 for not enough data for a new msg.</li>
<li>&lt; 0 for reader is in error state.</li>
</ol>
</li>
</ul>
</dd></dl>
<ul>
<li>To obtain an initialized pktlab reader struct, see <a class="el" href="pktlab_8h.html#ab098bfcd9956999449336ea2d86603d7" title="Get initialized pktlab reader struct.">pktlab_create_reader()</a>.</li>
<li>Note whenever &lt; 0 is returned, r should not be called with msgptr being non-NULL afterwards. </li>
</ul>

</div>
</div>
<a id="ae8d2e1da9a8100c9b49af48fba78662b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8d2e1da9a8100c9b49af48fba78662b">&#9670;&nbsp;</a></span>pktlab_reader_readaux()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* pktlab_reader_readaux </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structpktlab__reader.html">pktlab_reader</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pktlab reader struct aux information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>Initialized pktlab reader struct to get aux from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reader aux (passed in during <a class="el" href="pktlab_8h.html#ab098bfcd9956999449336ea2d86603d7" title="Get initialized pktlab reader struct.">pktlab_create_reader()</a>). </dd></dl>

</div>
</div>
<a id="afe48b122672a01f75f928b371d4456ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe48b122672a01f75f928b371d4456ce">&#9670;&nbsp;</a></span>pktlab_set8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pktlab_set8 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set 8-bit unsigned integer to byte array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Target byte array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Target set value.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Note there also exist similar functions (pktlab_setN[b|l|n]) that sets N-bit unsigned integer to byte array (N being either 16, 24, 32 or 64). The b/l/n suffix specifies the function treats the byte array as in big endian/little endian/network byte order, respectively. </li>
</ul>

</div>
</div>
<a id="a97605a8c344ea996080c7fb47f6e3139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97605a8c344ea996080c7fb47f6e3139">&#9670;&nbsp;</a></span>pktlab_setbit8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint_fast8_t pktlab_setbit8 </td>
          <td>(</td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set bit in unsigned integer at bit position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bits</td><td>Target unsigned interger to set bit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Target bit position (0-indexed). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Set result.</dd></dl>
<ul>
<li>Note there also exist similar functions (pktlab_setbitN) that set bit to larger unsigned integers (N being either 16, 32, or 64).</li>
<li>Setting bit for pos &gt;= N will be ignored with unchanged bits value returned. </li>
</ul>

</div>
</div>
<a id="aa5370405d8eb6628ec3a1e9f31cd9d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5370405d8eb6628ec3a1e9f31cd9d70">&#9670;&nbsp;</a></span>pktlab_sktstate_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* pktlab_sktstate_name </td>
          <td>(</td>
          <td class="paramtype">enum pktlab_socket_state&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get text description of pktlab endpoint skt state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>pktlab endpoint skt state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the text description string for pktlab endpoint skt state. </dd></dl>

</div>
</div>
<a id="a105d5b772f2827d0f09f390d38b9864f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105d5b772f2827d0f09f390d38b9864f">&#9670;&nbsp;</a></span>pktlab_time_now()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pktlab_8h.html#ae9515e3477c7b07d3cf086e3a3e463c1">pktlab_time_t</a> pktlab_time_now </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current pktlab time. </p>
<dl class="section return"><dt>Returns</dt><dd>Current pktlab time. </dd></dl>

</div>
</div>
<a id="a42d4fa34a4fcc092c65688b58fa32439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d4fa34a4fcc092c65688b58fa32439">&#9670;&nbsp;</a></span>pktlab_time_sec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="pktlab_8h.html#ae9515e3477c7b07d3cf086e3a3e463c1">pktlab_time_t</a> pktlab_time_sec </td>
          <td>(</td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>sec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert seconds to pktlab ticks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sec</td><td>The number of seconds to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted result in pktlab ticks. </dd></dl>

</div>
</div>
<a id="a116b50578ab12d41aeb46895a323d491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116b50578ab12d41aeb46895a323d491">&#9670;&nbsp;</a></span>pktlab_time_to_timespec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pktlab_time_to_timespec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pktlab_8h.html#ae9515e3477c7b07d3cf086e3a3e463c1">pktlab_time_t</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&#160;</td>
          <td class="paramname"><em>tp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert time period in pktlab ticks to struct timespec. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The number of pktlab ticks to convert. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tp</td><td>Pointer to a timespec struct to store the converted result. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09a8b5663bb6251fef86fd66e880b11f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a8b5663bb6251fef86fd66e880b11f">&#9670;&nbsp;</a></span>pktlab_time_to_timeval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pktlab_time_to_timeval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pktlab_8h.html#ae9515e3477c7b07d3cf086e3a3e463c1">pktlab_time_t</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timeval *&#160;</td>
          <td class="paramname"><em>tv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert time period in pktlab ticks to struct timeval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The number of pktlab ticks to convert. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tv</td><td>Pointer to a timeval struct to store the converted result. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbf51f30a382dc01fde04a943051f6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf51f30a382dc01fde04a943051f6ed">&#9670;&nbsp;</a></span>pktlab_time_to_unix_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint_fast32_t pktlab_time_to_unix_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pktlab_8h.html#ae9515e3477c7b07d3cf086e3a3e463c1">pktlab_time_t</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a pktlab time to Unix time (in second precision). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The pktlab time to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted Unix time. </dd></dl>

</div>
</div>
<a id="af15de87064c8013994581d2f0f526d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af15de87064c8013994581d2f0f526d63">&#9670;&nbsp;</a></span>pktlab_timespec_to_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="pktlab_8h.html#ae9515e3477c7b07d3cf086e3a3e463c1">pktlab_time_t</a> pktlab_timespec_to_time </td>
          <td>(</td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert time period in struct timespec to pktlab ticks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tp</td><td>Pointer to time period in struct timespec to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted result in pktlab ticks. </dd></dl>

</div>
</div>
<a id="adf1382eb7d33071de905e764236846b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf1382eb7d33071de905e764236846b9">&#9670;&nbsp;</a></span>pktlab_timeval_to_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="pktlab_8h.html#ae9515e3477c7b07d3cf086e3a3e463c1">pktlab_time_t</a> pktlab_timeval_to_time </td>
          <td>(</td>
          <td class="paramtype">const struct timeval *&#160;</td>
          <td class="paramname"><em>tv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert time period in struct timeval to pktlab ticks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tv</td><td>Pointer to time period in struct timeval to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted result in pktlab ticks. </dd></dl>

</div>
</div>
<a id="aad268368f2cb84634e924f6bbe8b3165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad268368f2cb84634e924f6bbe8b3165">&#9670;&nbsp;</a></span>pktlab_tm_to_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pktlab_8h.html#ae9515e3477c7b07d3cf086e3a3e463c1">pktlab_time_t</a> pktlab_tm_to_time </td>
          <td>(</td>
          <td class="paramtype">const struct tm *&#160;</td>
          <td class="paramname"><em>tm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert time in struct tm to pktlab time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tm</td><td>Pointer to time in struct tm to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted pktlab time. </dd></dl>

</div>
</div>
<a id="ac162f6029387610678b4ccb6bd05e546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac162f6029387610678b4ccb6bd05e546">&#9670;&nbsp;</a></span>pktlab_verify_cert_chain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_verify_cert_chain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>auth_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpktlab__certificate.html">pktlab_certificate</a> **&#160;</td>
          <td class="paramname"><em>cert_ls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpktlab__publickey.html">pktlab_publickey</a> **&#160;</td>
          <td class="paramname"><em>root_ls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpktlab__certificate.html">pktlab_certificate</a> ***&#160;</td>
          <td class="paramname"><em>verified_cert_ls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>certnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>rootnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t *&#160;</td>
          <td class="paramname"><em>verified_certnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t *&#160;</td>
          <td class="paramname"><em>used_root_indx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify pktlab certificate chain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">auth_mode</td><td>Verification mode to use when verifying certificate chain. Must be one of enum pktlab_auth_mode values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cert_ls</td><td>Array of pointers to loaded pktlab certificate structs that should be verified. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root_ls</td><td>Array of pointers to loaded pktlab public key structs that could serve as the certificate chain root. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">verified_cert_ls</td><td>Pointer to return the verified certificate chain (in the form of an allocated array of pointers to loaded pktlab certificate structs). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">certnum</td><td>The number of loaded pktlab certificate struct pointers in cert_ls. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rootnum</td><td>The number of loaded pktlab public key struct pointers in root_ls. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">verified_certnum</td><td>Pointer to return the verified certificate chain length. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">used_root_indx</td><td>Pointer to return the verified certificate chain root (in the form of indx to root_ls). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the enum pktlab_verify_rst defined values representing verification result. Verified certificate chain information (verified_cert_ls/verified_certnum/used_root_indx) returned only when verification successful.</dd></dl>
<ul>
<li>The returned verified_cert_ls pointer should be freed with free() in stdlib.h. Note the pointers to loaded pktlab certificate structs in verified_cert_ls are the same ones as in cert_ls (i.e. if one frees all certificate struct in cert_ls, the certificate structs in verified_cert_ls are freed as well).</li>
<li>It is allowed to pass in NULL for cert_ls/root_ls/verified_cert_ls/verified_certnum/used_root_indx. If cert_ls/root_ls is NULL, the corresponding certnum/rootnum must be 0 and vice versa. If verified_cert_ls/verified_certnum/used_root_indx is NULL, no value is returned and no freeing is needed. </li>
</ul>

</div>
</div>
<a id="ab9554cecbdd1ed9fc353edb343190b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9554cecbdd1ed9fc353edb343190b09">&#9670;&nbsp;</a></span>pktlab_verify_certificate_signature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_verify_certificate_signature </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structpktlab__certificate.html">pktlab_certificate</a> *&#160;</td>
          <td class="paramname"><em>cert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structpktlab__publickey.html">pktlab_publickey</a> *&#160;</td>
          <td class="paramname"><em>signkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify the pktlab certificate signature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cert</td><td>Pointer to a loaded pktlab certificate struct. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signkey</td><td>Pointer to a loaded pktlab public key struct for verifying pktlab certificate signature. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if verification success. &lt; 0 if verification failed.</dd></dl>
<ul>
<li>Note invalid input argument is considered verification failure as well. </li>
</ul>

</div>
</div>
<a id="ae50455dc8d68498355c5dd5094a8770d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae50455dc8d68498355c5dd5094a8770d">&#9670;&nbsp;</a></span>pktlab_write_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pktlab_write_message </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpktlab__writer.html">pktlab_writer</a> *restrict&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structpktlab__message.html">pktlab_message</a> *restrict&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pktlab writer write message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">w</td><td>Initialized pktlab writer struct. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Pointer to an initialized msg struct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ol type="1">
<li>1 for successful encoding and buffering of msg (some message bytes have been sent).</li>
<li>0 for try again later (message bytes are not buffered).</li>
<li>&lt; 0 for write errors. Check errno for more information.</li>
</ol>
</dd></dl>
<ul>
<li>To obtain an initialized pktlab writer struct, see <a class="el" href="pktlab_8h.html#a9b21cba7d11c875b5268542c49e6d2a4" title="Get initialized pktlab writer struct.">pktlab_create_writer()</a>.</li>
<li>Note even though the function signature is similar to <a class="el" href="pktlab_8h.html#adb3ef3c891d623ca8152429834b4fde0" title="pktlab reader read message.">pktlab_read_message()</a>, msg must NOT be NULL.</li>
<li><a class="el" href="pktlab_8h.html#ae50455dc8d68498355c5dd5094a8770d" title="pktlab writer write message.">pktlab_write_message()</a> always first tries to flush any buffered bytes within the writer before working on sending the new message bytes. It is therefore fine to perform a consecutive call of <a class="el" href="pktlab_8h.html#ae50455dc8d68498355c5dd5094a8770d" title="pktlab writer write message.">pktlab_write_message()</a> on a series of messages, while only stopping when <a class="el" href="pktlab_8h.html#ae50455dc8d68498355c5dd5094a8770d" title="pktlab writer write message.">pktlab_write_message()</a> returns &lt;= 0.</li>
<li>Note in case there isn't any other message to be sent, to flush the internal buffered unsent bytes and ensure that all message bytes are sent, one can use a combination of <a class="el" href="pktlab_8h.html#a524fb1985afe251a4ba072fd9176fd98" title="Flush pktlab writer internal buffer.">pktlab_flush_writer()</a> and <a class="el" href="pktlab_8h.html#aae8895ba48507b6ec6af8fb007c61d31" title="Get writer internal buffered content length.">pktlab_writer_unsent()</a> to make sure buffered bytes are flushed.</li>
<li>w should be closed afterwards if <a class="el" href="pktlab_8h.html#ae50455dc8d68498355c5dd5094a8770d" title="pktlab writer write message.">pktlab_write_message()</a> failed with an error. </li>
</ul>

</div>
</div>
<a id="aae8895ba48507b6ec6af8fb007c61d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae8895ba48507b6ec6af8fb007c61d31">&#9670;&nbsp;</a></span>pktlab_writer_unsent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t pktlab_writer_unsent </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structpktlab__writer.html">pktlab_writer</a> *&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get writer internal buffered content length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>Initialized pktlab writer struct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of buffered bytes in w.</dd></dl>
<ul>
<li><a class="el" href="pktlab_8h.html#aae8895ba48507b6ec6af8fb007c61d31" title="Get writer internal buffered content length.">pktlab_writer_unsent()</a> is often used in conjunction with <a class="el" href="pktlab_8h.html#a524fb1985afe251a4ba072fd9176fd98" title="Flush pktlab writer internal buffer.">pktlab_flush_writer()</a> to flush out all writer-internally buffered bytes. See <a class="el" href="pktlab_8h.html#a524fb1985afe251a4ba072fd9176fd98" title="Flush pktlab writer internal buffer.">pktlab_flush_writer()</a> for more information. </li>
</ul>

</div>
</div>
<a id="a2ac5b320dd2821800b6c595abd30c277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac5b320dd2821800b6c595abd30c277">&#9670;&nbsp;</a></span>pktlab_writer_writeaux()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* pktlab_writer_writeaux </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structpktlab__writer.html">pktlab_writer</a> *&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pktlab writer struct aux information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>pktlab writer struct to get aux from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Writer aux (passed in during <a class="el" href="pktlab_8h.html#a9b21cba7d11c875b5268542c49e6d2a4" title="Get initialized pktlab writer struct.">pktlab_create_writer()</a>). </dd></dl>

</div>
</div>
<a id="aa6108d1f346715330ddffbf00c4fabb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6108d1f346715330ddffbf00c4fabb9">&#9670;&nbsp;</a></span>pktlab_xdescr_dattr_match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pktlab_xdescr_dattr_match </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>xdescr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>xdescrlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dattr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>dattrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Match an experiment descriptor (xdescr) string to an endpoint attribute (dattr) string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xdescr</td><td>xdescr string as the matching pattern. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xdescrlen</td><td>Length of xdescr string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dattr</td><td>dattr string as the matching target. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dattrlen</td><td>Length of dattr string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>When both xdescr and dattr are well-formed (can be decoded), true for a match between the two, false otherwise. If either is malformed, false is returned.</dd></dl>
<ul>
<li>This function is used by the broker/rendezvous server to match between experiment publication and subscription and decide whether an experiment notification should be sent to an endpoint. A notification is sent iff when there is a match.</li>
<li>Note when xdescr is NULL, xdescrlen must be 0 and vice versa. The same applies to dattr and dattrlen.</li>
<li>Whether there is a match between (the well-formed) xdescr and dattr is decided based on the following:<ol type="1">
<li>If dattr is empty (0-length/no pairs), it is a match.</li>
<li>Otherwise, for all pairs in dattr, look for pairs in xdescr with the same name.</li>
<li>If there is no such pair in xdescr, it is considered a match for this dattr pair.</li>
<li>Else, if among all pairs in xdescr that have the same name, there exist at least one pair that has a value string matching the dattr pair value string (after wildcard matching), it is a match for this dattr pair. If no such pair exists, it is a no match for this dattr pair.</li>
<li>The overall matching result is the logical AND of per-dattr-pair matching results. </li>
</ol>
</li>
</ul>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
